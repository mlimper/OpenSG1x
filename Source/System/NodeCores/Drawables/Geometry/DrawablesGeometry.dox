#include <OSGConfig.h>

using namespace OSG;

// the used groups

/*! \defgroup GrpSystemNodeCoresDrawablesGeometry Geometry
    \ingroup GrpSystemNodeCoresDrawables
    
    Geometry is the primary leaf node of the tree. It wraps polygonal
    primitives as defined by OpenGLs glBegin()/glEnd() loops. See \ref
    PageSystemGeometry for a description. 
*/

/*! \defgroup GrpSystemDrawablesGeometryIterators Geometry Iterators
    \ingroup GrpSystemNodeCoresDrawablesGeometry
    
    Helpers to access Geometry in a generic way. See \ref PageSystemGeoIterators 
    for a description.
*/

/*! \defgroup GrpSystemDrawablesGeometryFunctions Geometry Functions
    \ingroup GrpSystemNodeCoresDrawablesGeometry

    The GeoFunctions group contains different different functions to
    manipulate geometry. See \ref PageSystemGeoFunctions for a description.
*/

/*! \defgroup GrpSystemDrawablesGeometryProperties Geometry Properties
    \ingroup GrpSystemNodeCoresDrawablesGeometry

    GeoProperties are the wrapper classes for the geometry's attributes. They
    encapsulate and abstract the specific types of the attributes and offer an
    interface that is targeted at glVertexArrays. To simplify usage they also
    have a generic interface, which is easy to use, but not as efficient as
    the specific one.

*/

/*! \defgroup GrpSystemDrawablesGeometrySimpleGeometry Simple Geometry
    \ingroup GrpSystemNodeCoresDrawablesGeometry  

    SimpleGeometry combines a number of functions to create some specialized 
    geometry very easily. See \ref PageSystemSimpleGeometry for a description.
*/

// the page(s)

/*! \page PageSystemGeometry Geometry

Geometries make up most of the leaves of the graph and ultimately define
what's being rendered. Geometry has to be flexible, to accommodate the needs
of the application. Different data types for the data that defines the
geometry are useful, as well as different indexing capabilities to reuse data
as much as possible. On the other hand, it also has to be efficient to render.
Flexibility and performance don't always go well together, thus, there are
some simplifications to make.

OpenSG geometry is modeled closely following OpenGL. The data that make up the
geometry are stored in separate arrays. Positions, Colors, Normals and Texture
Coordinates all have their own arrays, (or MultiFields, to stay in OpenSG
terminology)). As OpenGL can handle a lot of different formats for the data,
some of which might be more appropriate due to speed and memory consumption
than others, depending on the application, OpenSG features different version
of this data, allowing all the variants that OpenGL allows. To allow that with
type safety and without having a separate geometry class for every possible
combination the data fields are stored in separate field containers, so called
GeoProperties. There are separate GeoProperties for different attributes, and
variants for different data types for each kind of GeoProperty. The most
prominent types are probably GeoPositions3f for Pnt3f positions, GeoNormals3f
for Vec3f normals, GeoColors3f for Color3f colors and GeoTexCoords2f for Vec2f
texture coordinates, but all other variants are possible. 

As properties only have a single field they can mimic that field by exposing
parts of the standard MultiField interface for their contents, so you can use
a GeoProperty pretty much just like a MultiField. One problem with the type
variety is that writing functions that work on every type of property can
become tedious, as you have to have a big switch for every kind of data that
could arrive. To make that easier for every property there is defined generic
format, e.g. for Positions the format is Pnt3f. A property has a
getValue()/setValue() interface for these generic types, i.e. every property,
no matter in what format it stores the data, can be used as if it used the
generic format. Of course, this is not as efficient as directly accessing the
data, but if speed is not the highest priority or as a fall-back it's quite
useful. And, finally, GeoProperties feature an interface for OpenGL vertex
arrays, giving access to the data and the types involved, which is used for
rendering.

In addition to the above-mentioned data there are some other GeoProperties.
OpenSG allows multiple primitive types per geometry, i.e. you can freely mix
triangles, triangle strips and polygons in a single geometry node. The
GeoPTypes property defines the type of the primitives used. Right now, it only
exists as a GeoPTypesUI32 variant, but others may follow. The number of
vertices per primitive is defined by another property, the GeoPLengths
property. This, too, only exists in a GeoPLengthsUI32 variant right now. 

\section PageSystemGeoIndexing Indexing

Using these properties it is possible to define geometry. Note that OpenSG inherits the constraints and
specifications that concern geometry from OpenGL. Vertex orientation is
counterclockwise when seen from the outside, and concave polygons are not
supported.

\image html geo_nonindexed.png "Non-Indexed Geometry"
\image latex geo_nonindexed.eps "Non-Indexed Geometry" width=8cm

One additional advantage of separating properties from Geometry is the ability
to share properties between geometry NodeCores. As geometries can only have
one material right now that's useful for simplifying the handling of objects
with multiple materials.

This simple geometry has one problem: there is no way to reuse vertex data.
When a vertex is to be used multiple times, it has to be replicated, which can
increase the amount of memory needed significantly. Thus, some sort of
indexing to reuse vertices is needed. You can guess what's coming? Right,
another property.

Indices are stored in the GeoIndices property, which only exists in the
GeoIndicesUI32 variant right now. When indices are present the given lengths
define how many indices are used to define the primitive, while that actual
data is indexed by the indices.

\image html geo_indexed.png "Indexed Geometry"
\image latex geo_indexed.eps "Indexed Geometry" width=8cm

Indexed geometry is very close to OpenGL, and probably the most often used
type of geometry. It doesn't handle all the cases, though.

Sometimes vertices need different additional attributes, even though they have
the same position. One example are discontinuities in texture coordinates,
e.g. when texturing a simple cube. The edges of the cube don't necessarily use
the same texture coordinate. To support that a single indexed geometry has to
replicate the vertices.

To get around that you need multiple indices per vertex to index the different
attributes. Adding an index for every attribute would blow up the geometry
significantly and not necessarily make it easier to use. We decided to use
another way: interleaved indices.

\image html geo_multiindexed.png "Multi-Indexed Geometry"
\image latex geo_multiindexed.eps "Multi-Indexed Geometry" width=8cm

Interleaved indices require every vertex to hold multiple indices. Which index
is used for what attribute is defined by a separate indexMapping field. The
indexMapping field is a UInt32 MultiField. The possible values are bitwise
combinations of the available attribute masks: Geometry::MapPosition,
Geometry::MapNormal etc. The length of the indexMapping defines how many
indices are used per vertex. If it's not set a single index for all available
properties is used (or none at all).

In addition to the properties geometry keeps a MaterialPtr to define the
material that's used for rendering the geometry (see sec. [sec:materials]) and
a flag that activates caching the geometry in OpenGL display lists. As
geometry rendering is not optimized very much right now that's the best way to
get decent performance. Display lists are turned on by default.

\section PageSystemGeometryIterators Geometry Iterators

The above setup is very nice and flexible to define: you can mix different
kinds of primitives in an object, you can have properties and different kinds
and the indexing allows the reuse of some or all of the data.

From the other side of the fence things look difficult: if you want to walk
over all triangles of a geometry to calculate the average triangle size or the
surface area, or for calculating face normals or for whatever reason you have
to take care of all the flexibility and be prepared for lots of different ways
to define geometry.

To simplify that the concept of a geometry iterator has been introduced. A
geometry iterator allows to iterate over a given geometry primitive by
primitive, face by face (a face being a triangle or quad), or triangle by
triangle. 

All of them are used like STL iterators: the geometry has methods to pass the
first or last+1th iterator (begin() and end()) , and to step from one element
to the next use ++. They can also unify the different indices: when using an
iterator you can access the index value for each attribute of each vertex of
the iterator separately. Or you can directly access the data that's behind the
index in its generic form. 

If you're used to having a separate Face object that keeps all the data for a
separate face, the Iterators pretty much mimic that behavior. The one thing
you can't do using iterators is changing the data.

\subsection PageSystemPrimitiveIterator Primitive Iterator

The PrimitiveIterator is the basic iterator that just iterates through the
GeoPTypes property and gives access to the primitive's data. It is useful to
solve the index mapping complications and to get access to the generic data,
but it's primarily a base class for the following two iterator types.

\subsection PageSystemFaceIterator Face Iterator

The FaceIterator only iterates over polygonal geometry and ignores points and
lines. It also splits the geometry into triangles or quads. 

\subsection PageSystemTriangleIterator Triangle Iterator

The TriangleIterator behaves like the FaceIterator, but it also splits Quads
into two triangles, thus it does an implicit triangulation. As OpenSG just
like OpenGL doesn't support concave geometry that's not as hard as it sounds.

The iterators can also be used to indicate a specific primitive/face/triangle.
Each of these has an associated index that the iterator keeps and that can be
accessed using getIndex(). A new iterator can be used to seek() a given
primitive/face/triangle again and work on it. This is used for example in the
IntersectAction.


\subsection PageSystemSimpleGeometry Simple Geometry

OpenSG does not have NodeCores for geometric primitives like spheres, cones,
cylinders etc. Instead there are a number of utility functions that can create
these objects. They can be created as a ready-to-use node and as a naked node
core.

\dev We definitely need a Teapot here... :) \enddev

\subsubsection PageSystemSimpleGeometryPlane Plane

makeplane

\subsubsection PageSystemSimpleGeometryBox Box

makebox

\subsubsection SimpleGeometryCone Cone

makecone

\subsubsection PageSystemSimpleGeometryCylinder Cylinder

makecylinder

\subsubsection PageSystemSimpleGeometryTorus Torus

maketorus

\subsubsection PageSystemSimpleGeometrySphere Sphere

makesphere, makelatlongsphere

\subsubsection PageSystemSimpleGeometryConicalFrustum ConicalFrustum

makeConicalFrustum 

\subsection PageSystemGeoFunctions Helper Functions

A number of helper functions can be used in conjunction with manipulating and
optimizing geometry.

void calcVertexNormals(GeometryPtr geo);

void calcVertexNormals( GeometryPtr geo,  Real32 creaseAngle );

void calcFaceNormals( GeometryPtr geo );

Int32 setIndexFromVRMLData(      GeometryPtr    geo,
                            std::vector<Int32> &coordIndex,
                            std::vector<Int32> &normalIndex,
                            std::vector<Int32> &colorIndex,
                            std::vector<Int32> &texCoordIndex,
                                 bool           convex          = true,
                                 bool           ccw             = true,
                                 bool           normalPerVertex = true,
                                 bool           colorPerVertex  = true,
                                 bool           createNormal    = true,
                                 bool           faceSet         = true);

Int32 createOptimizedPrimitives (GeometryPtr geo,
                                 UInt32      iteration       = 1,
                                 bool        createStrips    = true,
                                 bool        createFans      = true,
                                 UInt32      minFanEdgeCount = 8,
                                 bool        colorCode       = false );

Int32 createSharedIndex ( GeometryPtr geo );

Int32 createSingleIndex ( GeometryPtr geo );

UInt32 calcPrimitiveCount ( GeometryPtr geo,
                            UInt32 &triangle, UInt32 &line, UInt32 &point );

void mergeGeometries(std::vector<NodePtr> &nodes, 
                     std::vector<NodePtr> &results);

NodePtr getNormals( GeometryPtr geo, Real32 length );

NodePtr getFaceNormals(GeometryPtr geo, Real32 length);

*/

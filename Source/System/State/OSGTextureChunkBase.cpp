/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *             Copyright (C) 2000,2001 by the OpenSG Forum                   *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILETEXTURECHUNKINST

#include <stdlib.h>
#include <stdio.h>

#include <OSGConfig.h>

#include "OSGTextureChunkBase.h"
#include "OSGTextureChunk.h"

#include <OSGGL.h>                        // InternalFormat default header
#include <OSGGL.h>                        // ExternalFormat default header
#include <OSGGL.h>                        // MinFilter default header
#include <OSGGL.h>                        // MagFilter default header
#include <OSGGL.h>                        // WrapS default header
#include <OSGGL.h>                        // WrapT default header
#include <OSGGL.h>                        // WrapR default header
#include <OSGGL.h>                        // EnvMode default header

OSG_USING_NAMESPACE

const OSG::BitVector  TextureChunkBase::ImageFieldMask = 
    (1 << TextureChunkBase::ImageFieldId);

const OSG::BitVector  TextureChunkBase::InternalFormatFieldMask = 
    (1 << TextureChunkBase::InternalFormatFieldId);

const OSG::BitVector  TextureChunkBase::ExternalFormatFieldMask = 
    (1 << TextureChunkBase::ExternalFormatFieldId);

const OSG::BitVector  TextureChunkBase::ScaleFieldMask = 
    (1 << TextureChunkBase::ScaleFieldId);

const OSG::BitVector  TextureChunkBase::FrameFieldMask = 
    (1 << TextureChunkBase::FrameFieldId);

const OSG::BitVector  TextureChunkBase::MinFilterFieldMask = 
    (1 << TextureChunkBase::MinFilterFieldId);

const OSG::BitVector  TextureChunkBase::MagFilterFieldMask = 
    (1 << TextureChunkBase::MagFilterFieldId);

const OSG::BitVector  TextureChunkBase::WrapSFieldMask = 
    (1 << TextureChunkBase::WrapSFieldId);

const OSG::BitVector  TextureChunkBase::WrapTFieldMask = 
    (1 << TextureChunkBase::WrapTFieldId);

const OSG::BitVector  TextureChunkBase::WrapRFieldMask = 
    (1 << TextureChunkBase::WrapRFieldId);

const OSG::BitVector  TextureChunkBase::EnvModeFieldMask = 
    (1 << TextureChunkBase::EnvModeFieldId);

const OSG::BitVector  TextureChunkBase::EnvColorFieldMask = 
    (1 << TextureChunkBase::EnvColorFieldId);

const OSG::BitVector  TextureChunkBase::GLIdFieldMask = 
    (1 << TextureChunkBase::GLIdFieldId);



// Field descriptions

/*! \var ImageP          TextureChunkBase::_sfImage
    
*/
/*! \var UInt32          TextureChunkBase::_sfInternalFormat
    The internal texture format.
*/
/*! \var UInt32          TextureChunkBase::_sfExternalFormat
    The external texture format - overwrites          external format of image when set to a value not equal to          GL_NONE (which is the default).
*/
/*! \var bool            TextureChunkBase::_sfScale
    Specifies whether the image should be scaled to the next power of two,         thus filling the whole texture coordinate range, or if it should be put         in the lower left corner, leaving the rest of the texture undefined.         This is mainly used for rapidly changing non power of two textures, to         get around the scaling overhead.
*/
/*! \var UInt32          TextureChunkBase::_sfFrame
    Select the frame of the image to be used. See osg::Image about details         concerning multi-frame images.         \hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap         creation is slow right now. \endhint
*/
/*! \var UInt32          TextureChunkBase::_sfMinFilter
    The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.
*/
/*! \var UInt32          TextureChunkBase::_sfMagFilter
    The magnification filter, default GL_LINEAR.
*/
/*! \var UInt32          TextureChunkBase::_sfWrapS
    Texture coordinate S wrapping, default GL_REPEAT.
*/
/*! \var UInt32          TextureChunkBase::_sfWrapT
    Texture coordinate T wrapping, default GL_REPEAT.
*/
/*! \var UInt32          TextureChunkBase::_sfWrapR
    Texture coordinate R wrapping, default GL_REPEAT.
*/
/*! \var UInt32          TextureChunkBase::_sfEnvMode
    Texture environment mode, default GL_REPLACE
*/
/*! \var Color4f         TextureChunkBase::_sfEnvColor
    Texture environment color default transparent black.
*/
/*! \var UInt32          TextureChunkBase::_sfGLId
    The OpenGL texture id for this texture.
*/

//! TextureChunk description

FieldDescription *TextureChunkBase::_desc[] = 
{
    new FieldDescription(SFImageP::getClassType(), 
                     "image", 
                     ImageFieldId, ImageFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFImage),
    new FieldDescription(SFUInt32::getClassType(), 
                     "internalFormat", 
                     InternalFormatFieldId, InternalFormatFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFInternalFormat),
    new FieldDescription(SFUInt32::getClassType(), 
                     "externalFormat", 
                     ExternalFormatFieldId, ExternalFormatFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFExternalFormat),
    new FieldDescription(SFBool::getClassType(), 
                     "scale", 
                     ScaleFieldId, ScaleFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFScale),
    new FieldDescription(SFUInt32::getClassType(), 
                     "frame", 
                     FrameFieldId, FrameFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFFrame),
    new FieldDescription(SFUInt32::getClassType(), 
                     "minFilter", 
                     MinFilterFieldId, MinFilterFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFMinFilter),
    new FieldDescription(SFUInt32::getClassType(), 
                     "magFilter", 
                     MagFilterFieldId, MagFilterFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFMagFilter),
    new FieldDescription(SFUInt32::getClassType(), 
                     "wrapS", 
                     WrapSFieldId, WrapSFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFWrapS),
    new FieldDescription(SFUInt32::getClassType(), 
                     "wrapT", 
                     WrapTFieldId, WrapTFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFWrapT),
    new FieldDescription(SFUInt32::getClassType(), 
                     "wrapR", 
                     WrapRFieldId, WrapRFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFWrapR),
    new FieldDescription(SFUInt32::getClassType(), 
                     "envMode", 
                     EnvModeFieldId, EnvModeFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFEnvMode),
    new FieldDescription(SFColor4f::getClassType(), 
                     "envColor", 
                     EnvColorFieldId, EnvColorFieldMask,
                     false,
                     (FieldAccessMethod) &TextureChunkBase::getSFEnvColor),
    new FieldDescription(SFUInt32::getClassType(), 
                     "GLId", 
                     GLIdFieldId, GLIdFieldMask,
                     true,
                     (FieldAccessMethod) &TextureChunkBase::getSFGLId)
};


FieldContainerType TextureChunkBase::_type(
    "TextureChunk",
    "StateChunk",
    NULL,
    (PrototypeCreateF) &TextureChunkBase::createEmpty,
    TextureChunk::initMethod,
    _desc,
    sizeof(_desc));

//OSG_FIELD_CONTAINER_DEF(TextureChunkBase, TextureChunkPtr)

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureChunkBase::getType(void) 
{
    return _type; 
} 

const FieldContainerType &TextureChunkBase::getType(void) const 
{
    return _type;
} 


FieldContainerPtr TextureChunkBase::shallowCopy(void) const 
{ 
    TextureChunkPtr returnValue; 

    newPtr(returnValue, dynamic_cast<const TextureChunk *>(this)); 

    return returnValue; 
}

UInt32 TextureChunkBase::getContainerSize(void) const 
{ 
    return sizeof(TextureChunk); 
}


void TextureChunkBase::executeSync(      FieldContainer &other,
                                    const BitVector      &whichField)
{
    this->executeSyncImpl((TextureChunkBase *) &other, whichField);
}

/*------------------------- constructors ----------------------------------*/

#ifdef OSG_WIN32_ICL
#pragma warning (disable : 383)
#endif

TextureChunkBase::TextureChunkBase(void) :
    _sfImage                  (ImageP(0)), 
    _sfInternalFormat         (UInt32(GL_NONE)), 
    _sfExternalFormat         (UInt32(GL_NONE)), 
    _sfScale                  (bool(true)), 
    _sfFrame                  (UInt32(0)), 
    _sfMinFilter              (UInt32(GL_LINEAR_MIPMAP_LINEAR)), 
    _sfMagFilter              (UInt32(GL_LINEAR)), 
    _sfWrapS                  (UInt32(GL_REPEAT)), 
    _sfWrapT                  (UInt32(GL_REPEAT)), 
    _sfWrapR                  (UInt32(GL_REPEAT)), 
    _sfEnvMode                (UInt32(GL_REPLACE)), 
    _sfEnvColor               (Color4f(0,0,0,0)), 
    _sfGLId                   (UInt32(0)), 
    Inherited() 
{
}

#ifdef OSG_WIN32_ICL
#pragma warning (default : 383)
#endif

TextureChunkBase::TextureChunkBase(const TextureChunkBase &source) :
    _sfImage                  (source._sfImage                  ), 
    _sfInternalFormat         (source._sfInternalFormat         ), 
    _sfExternalFormat         (source._sfExternalFormat         ), 
    _sfScale                  (source._sfScale                  ), 
    _sfFrame                  (source._sfFrame                  ), 
    _sfMinFilter              (source._sfMinFilter              ), 
    _sfMagFilter              (source._sfMagFilter              ), 
    _sfWrapS                  (source._sfWrapS                  ), 
    _sfWrapT                  (source._sfWrapT                  ), 
    _sfWrapR                  (source._sfWrapR                  ), 
    _sfEnvMode                (source._sfEnvMode                ), 
    _sfEnvColor               (source._sfEnvColor               ), 
    _sfGLId                   (source._sfGLId                   ), 
    Inherited                 (source)
{
}

/*-------------------------- destructors ----------------------------------*/

TextureChunkBase::~TextureChunkBase(void)
{
}

/*------------------------------ access -----------------------------------*/

UInt32 TextureChunkBase::getBinSize(const BitVector &whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        returnValue += _sfImage.getBinSize();
    }

    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }

    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }

    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }

    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        returnValue += _sfFrame.getBinSize();
    }

    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }

    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }

    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }

    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }

    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        returnValue += _sfEnvMode.getBinSize();
    }

    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        returnValue += _sfEnvColor.getBinSize();
    }

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }


    return returnValue;
}

void TextureChunkBase::copyToBin(      BinaryDataHandler &pMem,
                                  const BitVector         &whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyToBin(pMem);
    }

    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }

    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }

    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }

    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyToBin(pMem);
    }

    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }

    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }

    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }

    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }

    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyToBin(pMem);
    }

    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyToBin(pMem);
    }

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }


}

void TextureChunkBase::copyFromBin(      BinaryDataHandler &pMem,
                                    const BitVector    &whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyFromBin(pMem);
    }

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyFromBin(pMem);
    }


}

void TextureChunkBase::executeSyncImpl(      TextureChunkBase *pOther,
                                        const BitVector         &whichField)
{

    Inherited::executeSyncImpl(pOther, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
        _sfImage.syncWith(pOther->_sfImage);

    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
        _sfInternalFormat.syncWith(pOther->_sfInternalFormat);

    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
        _sfExternalFormat.syncWith(pOther->_sfExternalFormat);

    if(FieldBits::NoField != (ScaleFieldMask & whichField))
        _sfScale.syncWith(pOther->_sfScale);

    if(FieldBits::NoField != (FrameFieldMask & whichField))
        _sfFrame.syncWith(pOther->_sfFrame);

    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
        _sfMinFilter.syncWith(pOther->_sfMinFilter);

    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
        _sfMagFilter.syncWith(pOther->_sfMagFilter);

    if(FieldBits::NoField != (WrapSFieldMask & whichField))
        _sfWrapS.syncWith(pOther->_sfWrapS);

    if(FieldBits::NoField != (WrapTFieldMask & whichField))
        _sfWrapT.syncWith(pOther->_sfWrapT);

    if(FieldBits::NoField != (WrapRFieldMask & whichField))
        _sfWrapR.syncWith(pOther->_sfWrapR);

    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
        _sfEnvMode.syncWith(pOther->_sfEnvMode);

    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
        _sfEnvColor.syncWith(pOther->_sfEnvColor);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
        _sfGLId.syncWith(pOther->_sfGLId);


}



#include <OSGSFieldTypeDef.inl>
#include <OSGMFieldTypeDef.inl>

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldDataTraits<TextureChunkPtr>::_type("TextureChunkPtr", "StateChunkPtr");
#endif

OSG_DLLEXPORT_SFIELD_DEF1(TextureChunkPtr, OSG_SYSTEMLIB_DLLTMPLMAPPING);
OSG_DLLEXPORT_MFIELD_DEF1(TextureChunkPtr, OSG_SYSTEMLIB_DLLTMPLMAPPING);

OSG_END_NAMESPACE


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id: $";
    static Char8 cvsid_hpp       [] = OSGTEXTURECHUNKBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGTEXTURECHUNKBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGTEXTURECHUNKFIELDS_HEADER_CVSID;
}


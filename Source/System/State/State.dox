#include <OSGConfig.h>

using namespace OSG;

/*! \defgroup GrpSystemState OpenGL State Handling
    \ingroup GrpSystem
    
The OpenGL State Handling Group contains the wrapper classes for OpenGL
state.

See \ref PageSystemState for details.
*/

/*! \page PageSystemState State Handling

\latexonly Starter:NewChapter \endlatexonly

One of the main tasks of a scene graph system is efficiently managing the OpenGL
state. 

Every primitive is rendered using the currently active OpenGL state, which
includes things like material parameters, textures, transformation matrices
etc. Changing OpenGL state can be very expensive and should be minimized as
much as possible. Primitives using the same OpenGL state set should be grouped
together, so that changing the state is not needed.

But on top of that it is necessary to sort the different state sets so that the
changed when changing from one to the other are minimized, too. For example all
objects using the same texture should be rendered close together, as loading a
texture into the graphics board can take a long time.

Thus the different state sets used by the visible objects should be sorted
into a sequence that minimizes the state changes necessary. Unfortuneately
that problem is NP-complete (it's equivalent to the Traveling Salesman
Problem). \anchor StateChunk To simplify it the rather large OpenGL state is
divided into a small number of parts. Elements of the state that are usually
changed together are grouped into a osg::StateChunk. 

\anchor StateChunkClass Every type of osg::StateChunk has an associated
osg::StateChunkClass. The osg::StateChunkClass is used to
identify the osg::StateChunk and associate it with a name and a low integer
numeric Id. Some types of chunks can be used simulatenously in multiple
instances in OpenGL, e.g. light sources or textures (in a multi-texture
environment). The maximum number of concurrently active slots of the
osg::StateChunk type is also stored in the osg::StateChunkClass.

\anchor State The complete OpenGL state wrapper is the osg::State. It
primarily contains a vector of \ref PageSystemosg::StateChunk
"osg::StateChunks". For every type of chunk there are as many slots as
possibly concurrently active copies of the chunk. A chunk can be \ref
osg::StateChunk::activate "activated", which sets the OpenGL state
it covers to its settings, if the settings differ from an internally defined
default state. It is possible to \ref osg::StateChunk::changeFrom
"switch" from one instance of a state chunk to another instance of the same
type. This tries to optimize and minimize the changes, to speed up switching.
The cost of switching can be \ref osg::StateChunk::switchCost "estimated",
currently that estimation will always be 0, though. Finally a chunk can be
\ref osg::StateChunk::deactivate "deactivated", which resets the
OpenGL state it covers to the default value. All the chunks in a osg::State
can be managed at the same time by using the equivalent methods of the
osg::State.

\ext To add new chunks you need to derive it from osg::StateChunk. It needs to
keep  a static instance of osg::StateChunkClass and implement the public
osg::StateChunk::getClass() method to allow access to it. The
osg::StateChunkClass needs to define the name of the new chunk class and the
number of possible concurrently active chunks for the new class. To implement
the actual behaviour the osg::StateChunk::activate(),
osg::StateChunk::changeFrom() and osg::StateChunk::deactivate() methods are
needed. The osg::StateChunk::switchCost() method is in there already, but the
semantics are not defined yet, and it is not used. Implement it, but leave it
empty and always return 0. 

You will probably need to handle OpenGL extensions, see \ref PageSystemOGLExt
for details on how to do that. The convention for naming the static variables
for holding the extension and extension function handles is \c
_extExtensionName (e.g. \c _extBlendSubtract for the \c GL_EXT_blend_subtract,
extension) and \c _funcFunctionName (e.g. \c _funcBlendColor for \c
glBlendColor).

\endext

\dev The main motivation for osg::StateChunk::changeFrom() is to allow optimizations in terms of
state changes. When switching between chunks that have similar settings, only
the differences need to be passed to OpenGL. When and where it makes sense to
pass it to OpenGL anyway instead of checking is still an open topic. \enddev

Every chunk has a number of parameter which are pretty directly mapped to
OpenGL parameters. Thus in many cases OpenGL constants are used to define
different parameter values and enumerations. This allows usage of some OpenGL
extensions directly by supplying the correct constants. 

OpenGL uses explicit enabling in most situations. To get around having to keep
extra variables for enabling the value GL_NONE is used in many places to
indicate a disabled feature. The documentation of the chunk notes where this is
possible.

The different types of state chunks are:

<ul>

<li>\ref PageSystemBlendChunk</li>

<li>\ref PageSystemClipPlaneChunk</li>

<li>\ref PageSystemCubeTextureChunk</li>

<li>\ref PageSystemLineChunk</li>

<li>\ref PageSystemLightChunk</li>

<li>\ref PageSystemMaterialChunk</li>

<li>\ref PageSystemPolygonChunk</li>

<li>\ref PageSystemRegisterCombinersChunk</li>

<li>\ref PageSystemTexGenChunk</li>

<li>\ref PageSystemTextureChunk</li>

<li>\ref PageSystemTextureTransformChunk</li>

<li>\ref PageSystemTransformChunk</li>

</ul>

\section PageSystemBlendChunk BlendChunk

The osg::BlendChunk handles OpenGL blending, i.e. the definition how incoming
fragments are combined with the pixel already in the frame buffer, including
alpha culling. 

The wrapped OpenGL functions are glBlendFunc and glAlphaFunc,
see their documentation for details. It also handles the common
blending-related OpenGL extensions EXT_blend_color, ARB_imaging,
EXT_blend_subtract, EXT_blend_minmax and EXT_blend_logic_op, when they are
supported by the hardware.

\section PageSystemClipPlaneChunk ClipPlaneChunk

The osg::ClipPlaneChunk controls user-defined clipping. It uses a beacon
osg::Node reference to control the cordinate system where the clipping plane
is defined, this allows attaching the ClipPlane to another object to move it
around. The clipping plane itself is defined in the standard (a,b,c,d) form
used by OpenGL. 6 user defined clipping planes are possible.

\section PageSystemCubeTextureChunk CubeTextureChunk

The osg::CubeTextureChunk is similar to TextureChunk and uses the same
osg::StateChunkClass
(i.e. can be used instead of a osg::TextureChunk, but not both at the same
time), but has 5 more texture images. Note that all textures have to be square
and have to have the same resolution. The textures are accessed using 3D
texture coordinates, which are usually created using a osg::TexGenChunk. 

Cube textures are an extension that is only available in newer hardware. They
can not be emulated, thus they are ignored when they are not supported by the
active window.

\section PageSystemLightChunk LightChunk

The osg::LightChunk contains the parameter set for a single light source. It's
parameters are taken straight from the glLight() manpage. The maximum number
of concurrently active lights is currently set to 8.

Note that these chunks are created by the system internally from the osg::Light
sources and shouldn't be directly used by an application.

\section PageSystemLineChunk LineChunk

The osg::LineChunk contains the parameters that are specific set for lines. This
includes line width, stippling and antialiasing.

\section PageSystemMaterialChunk MaterialChunk

The osg::MaterialChunk controls the material parameters, i.e. the parameters for
phong lighting as used by glMaterial(). It also covers the commonly used
parameters to enable/disable lighting and switching the influence of geometry
colors on lighting (glColorMaterial).

\section PageSystemPolygonChunk PolygonChunk

The osg::PolygonChunk contains the parameters that are specific set for filled
surfaces, i.e. polygons. This includes face culling and front face definition
as well as front and back face rendering modes, polygon antialiasing, offset
and stippling. As there is only one set of offset parameters for all the
primitives, the offsetting for points and lines is also handled in this chunk,
which admittedly is a bit awkward.

\section PageSystemRegisterCombinersChunk RegisterCombinersChunk

The osg::RegisterCombinersChunk chunk is a direct mapping of the nVidia
RegisterCombiners extension. It is based on the GL_NV_register_combiners2
extension, i.e. it also supports per-stage constants.

\section PageSystemTexGenChunk TexGenChunk

The osg::TexGenChunk wraps texture coordinate generation functions. The
texture coordinate generation for all 4 coordinates is wrapped in a single
chunk, including the optional plane parameters.

\section PageSystemTextureChunk TextureChunk

The osg::TextureChunk contains a single texture image and it's related
parameters, which include the filters and texture environment mode and color.
1,2 and 3 dimensional textures are handled by this chunk uniformly and
textures  can also automatically be scaled to the next power of two (for 2D
textures). It can also handle a multi-frame osg::Image by selecting one of the
frames. If necessary (i.e. if mipmappibng filters are used) mipmaps will be
calculated automatically. \hint Don't use mipmaps for fast changing textures
(i.e. movies), as mipmap generation takes a lot of time. \endhint

Multiple texture chunks (right now 4) can be used simultaneously for
multi-texturing.

\section PageSystemTextureTransformChunk TextureTransformChunk

Chunk for texture coordinate transformations, uses a simple matrix to
transform texture coordinates. 

Multiple texture transform chunks (right now 4) can be used simultaneously for
multi-texturing.

\section PageSystemTransformChunk TransformChunk

Chunk for transformations, uses a simple matrix to transform coordinates. 

Note that these chunks are created by the system internally from the
osg::Transform and osg::ComponentTransform cores and shouldn't be directly
used by an application.


*/


/*! \file OSGCubeBack.tif

Test texture for back side of cube map texture.

*/

/*! \file OSGCubeFront.tif

Test texture for front side of cube map texture.

*/

/*! \file OSGCubeLeft.tif

Test texture for left side of cube map texture.

*/

/*! \file OSGCubeRight.tif

Test texture for right side of cube map texture.

*/

/*! \file OSGCubeDown.tif

Test texture for down side of cube map texture.

*/

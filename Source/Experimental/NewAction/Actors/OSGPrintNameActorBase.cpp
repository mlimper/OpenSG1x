/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *             Copyright (C) 2000-2002 by the OpenSG Forum                   *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class PrintNameActor
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

//----------------------------------------------------------------------------
//    Includes
//----------------------------------------------------------------------------

#include <OSGConfig.h>

#include "OSGPrintNameActorBase.h"

OSG_USING_NAMESPACE

//----------------------------------------------------------------------------
//    Static Member Init
//----------------------------------------------------------------------------

PrintNameActorBase::EnterStoreType *PrintNameActorBase::_pClassEnterStore = NULL;
PrintNameActorBase::LeaveStoreType *PrintNameActorBase::_pClassLeaveStore = NULL;

//----------------------------------------------------------------------------
//    Destructor
//----------------------------------------------------------------------------

/*! Destructor.
 */

PrintNameActorBase::~PrintNameActorBase(void)
{
}

//----------------------------------------------------------------------------
//    Start/Stop
//----------------------------------------------------------------------------

/*! Called before a traversal begins. This method can be overridden in derived
 *  classes, but the inherited version must be called.
 */

PrintNameActorBase::ResultE
PrintNameActorBase::start(void)
{
    return BasicActorBase::start();
}

/*! Called after a traversal ends. This method can be overridden in derived
 *  classes, but the inherited version must be called.
 */

PrintNameActorBase::ResultE
PrintNameActorBase::stop(void)
{
    return BasicActorBase::stop();
}

//----------------------------------------------------------------------------
//    Enter/Leave
//----------------------------------------------------------------------------

/*! This method is called when a node is entered. This method can be overridden
 *  in derived classes, but the inherited version should be called if there is
 *  nothing to do for the node.
 */

PrintNameActorBase::ResultE
PrintNameActorBase::enterNode(const NodePtr &pNode)
{
    ResultE  result = NewActionTypes::Continue;
    Functor *pFunc  = NULL;

    if((pFunc = _instanceEnterStore.getFunctor()) != NULL)
    {
        result = pFunc->call(pNode->getCore(), this);
    }
    else if((pFunc = _pClassEnterStore->getFunctor()) != NULL)
    {
        result = pFunc->call(pNode->getCore(), this);
    }
    else
    {
        result = BasicActorBase::enterNode(pNode);
    }

    return result;
}

/*! This method is called when a node is left. This method can be overridden
 *  in derived classes, but the inherited version should be called if there is
 *  nothing to do for the node.
 */

PrintNameActorBase::ResultE
PrintNameActorBase::leaveNode(const NodePtr &pNode)
{
    ResultE  result = NewActionTypes::Continue;
    Functor *pFunc  = NULL;

    if((pFunc = _instanceLeaveStore.getFunctor()) != NULL)
    {
        result = pFunc->call(pNode->getCore(), this);
    }
    else if((pFunc = _pClassLeaveStore->getFunctor()) != NULL)
    {
        result = pFunc->call(pNode->getCore(), this);
    }
    else
    {
        result = BasicActorBase::leaveNode(pNode);
    }

    return result;
}

//----------------------------------------------------------------------------
//    Enter Registration
//----------------------------------------------------------------------------

/*! Register a functor that is used by all instances of this class, when
 *  entering a node.
 */

void
PrintNameActorBase::regClassEnter(const Functor &refFunc)
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    _pClassEnterStore->regFunctor(refFunc);
}

/*! Register a functor that is used by the instance of this class, when
 *  entering a node. Instance functors take priority over class functors.
 */

void
PrintNameActorBase::regEnter(const Functor &refFunc)
{
    _instanceEnterStore.regFunctor(refFunc);
}

/*! Remove the functor registered with regClassEnter.
 */

void
PrintNameActorBase::unregClassEnter(void)
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    _pClassEnterStore->unregFunctor();
}

/*! Remove the functor registered with regEnter.
 */

void
PrintNameActorBase::unregEnter(void)
{
    _instanceEnterStore.unregFunctor();
}

//----------------------------------------------------------------------------
//    Leave Registration
//----------------------------------------------------------------------------

/*! Register a functor that is used by all instances of this class, when
 *  leaveing a node.
 */

void
PrintNameActorBase::regClassLeave(const Functor &refFunc)
{
    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    _pClassLeaveStore->regFunctor(refFunc);
}

/*! Register a functor that is used by the instance of this class, when
 *  leaveing a node. Instance functors take priority over class functors.
 */

void
PrintNameActorBase::regLeave(const Functor &refFunc)
{
    _instanceLeaveStore.regFunctor(refFunc);
}

/*! Remove the functor registered with regClassLeave.
 */

void
PrintNameActorBase::unregClassLeave(void)
{
    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    _pClassLeaveStore->unregFunctor();
}

/*! Remove the functor registered with regLeave.
 */

void
PrintNameActorBase::unregLeave(void)
{
    _instanceLeaveStore.unregFunctor();
}

//----------------------------------------------------------------------------
//    State Managment
//----------------------------------------------------------------------------

#ifdef OSG_NEWACTION_STATESLOTINTERFACE

UInt32
PrintNameActorBase::createStateClone(void)
{
    UInt32     stateSlot = getSlotMap                 (               ).size();
    StateType *pClone    = new PrintNameActorBaseState(*getCastState());

    getSlotMap().push_back(pClone);

    setState(pClone);

    return stateSlot;
}

#else /* OSG_NEWACTION_STATESLOTINTERFACE */

PrintNameActorBase::ActorBaseState *
PrintNameActorBase::createStateClone(void)
{
    StateType *pClone = new PrintNameActorBaseState(*getCastState());

    setState(pClone);

    return pClone;
}

#endif /* OSG_NEWACTION_STATESLOTINTERFACE */

#ifdef OSG_NEWACTION_STATESLOTINTERFACE

void
PrintNameActorBase::destroyStateClone(UInt32 slotId)
{
    delete getSlotMap()[slotId];
}

#else /* OSG_NEWACTION_STATESLOTINTERFACE */

void
PrintNameActorBase::destroyStateClone(ActorBaseState *pState)
{
    delete pState;
}

#endif /* OSG_NEWACTION_STATESLOTINTERFACE */

void
PrintNameActorBase::createInitialState(void)
{
    if(getState() != NULL)
    {
        SWARNING << "PrintNameActorBase::createInitialState: State is not NULL."
                 << endLog;
    }

    setState(new PrintNameActorBaseState());
}

void
PrintNameActorBase::deleteInitialState(void)
{
    if(getState() == NULL)
    {
        SWARNING << "PrintNameActorBase::deleteInitalState: State is NULL."
                 << endLog;
    }

    delete getState();

    setState(NULL);
}


//----------------------------------------------------------------------------
//    State Class
//----------------------------------------------------------------------------

/*! Destructor.
 */

PrintNameActorBase::PrintNameActorBaseState::~PrintNameActorBaseState(void)
{
}

//----------------------------------------------------------------------------
//    Constructors
//----------------------------------------------------------------------------

/*! Default Constructor.
 */

PrintNameActorBase::PrintNameActorBase(void)
    : Inherited(),
      _stateNumNodes(0),
      _instanceEnterStore(),
      _instanceLeaveStore()
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    setEnterNodeFlag(true);
    setLeaveNodeFlag(true);
}

//----------------------------------------------------------------------------
//    Event Notification
//----------------------------------------------------------------------------

/*! Called when the actor is attached to an action. This method can
 *  be overridden in derived classes, but the inherited version must be called.
 */

void
PrintNameActorBase::addEvent(NewActionBase *pAction, UInt32 uiActorId)
{
    Inherited::addEvent(pAction, uiActorId);
}

/*! Called when the actor is detached from an action. This method can
 *  be overridden in derived classes, but the inherited version must be called.
 */

void
PrintNameActorBase::subEvent(NewActionBase *pAction, UInt32 uiActorId)
{
    Inherited::subEvent(pAction, uiActorId);
}

/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning(disable : 177)
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id: OSGPrintNameActorBase.cpp,v 1.3 2004/09/10 15:00:48 neumannc Exp $";
    static Char8 cvsid_hpp       [] = OSGPRINTNAMEACTORBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGPRINTNAMEACTORBASE_INLINE_CVSID;
}

#ifdef OSG_LINUX_ICC
#pragma warning(enable : 177)
#endif

#ifdef OSG_SGI_CC
#pragma reset woff 1174
#endif

/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *             Copyright (C) 2000-2002 by the OpenSG Forum                   *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class IntersectActor
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <OSGConfig.h>

#include "OSGIntersectActorBase.h"

#include <OSGNodeCore.h>

OSG_USING_NAMESPACE

/*-------------------------------------------------------------------------*/
/*    Static Member Init                                                   */

IntersectActorBase::EnterStoreType *IntersectActorBase::_pClassEnterStore = NULL;
IntersectActorBase::LeaveStoreType *IntersectActorBase::_pClassLeaveStore = NULL;

/*-------------------------------------------------------------------------*/
/*    Destructor                                                           */

IntersectActorBase::~IntersectActorBase(void)
{
}

/*-------------------------------------------------------------------------*/
/*    Start/Stop                                                           */

/*! Called before a traversal begins. This method can be overridden in derived
 *  classes, but the inherited version must be called.
 */

IntersectActorBase::ResultE
IntersectActorBase::start(void)
{
    return ActorBase::start();
}

/*! Called after a traversal ends. This method can be overridden in derived
 *  classes, but the inherited version must be called.
 */

IntersectActorBase::ResultE
IntersectActorBase::stop(void)
{
    return ActorBase::stop();
}

/*-------------------------------------------------------------------------*/
/*    Apply                                                                */

/*! This method is called when a node is entered. This method can be overridden
 *  in derived classes, but the inherited version should be called if there is
 *  nothing to do for the node.
 */

IntersectActorBase::ResultE
IntersectActorBase::applyEnter(const NodePtr &pNode)
{
    ResultE      result    = NewActionTypes::Continue;
    NodeCorePtr  pNodeCore = pNode->getCore();
    Functor     *pFunc     = NULL;

    if((pFunc = _instanceEnterStore.getFunctor(pNodeCore->getType())) != NULL)
    {
        result = pFunc->call(pNodeCore, this);
    }
    else if((pFunc = _pClassEnterStore->getFunctor(pNodeCore->getType())) != NULL)
    {
        result = pFunc->call(pNodeCore, this);
    }
    else
    {
        result = ActorBase::applyEnter(pNode);
    }

    return result;
}

/*! This method is called when a node is left. This method can be overridden
 *  in derived classes, but the inherited version should be called if there is
 *  nothing to do for the node.
 */

IntersectActorBase::ResultE
IntersectActorBase::applyLeave(const NodePtr &pNode)
{
    ResultE      result    = NewActionTypes::Continue;
    NodeCorePtr  pNodeCore = pNode->getCore();
    Functor     *pFunc     = NULL;

    if((pFunc = _instanceLeaveStore.getFunctor(pNodeCore->getType())) != NULL)
    {
        result = pFunc->call(pNodeCore, this);
    }
    else if((pFunc = _pClassLeaveStore->getFunctor(pNodeCore->getType())) != NULL)
    {
        result = pFunc->call(pNodeCore, this);
    }
    else
    {
        result = ActorBase::applyLeave(pNode);
    }

    return result;
}

/*-------------------------------------------------------------------------*/
/*    Enter Registration                                                   */


/*! Register a functor that is used by all instances of this class, when
 *  entering a node with a core of the specified type.
 *  For every type of NodeCore a different functor can be registerd.
 */

void
IntersectActorBase::regClassEnter(const Functor            &refFunc,
                                 const FieldContainerType &refType )
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    _pClassEnterStore->regFunctor(refFunc, refType);
}

/*! Register a functor that is used by the instance of this class, when
 *  entering a node with a core of the specified type.
 *  For every type of NodeCore a different functor can be registerd.
 *  Instance functors take priority over class functors.
 */

void
IntersectActorBase::regEnter(const Functor            &refFunc,
                            const FieldContainerType &refType )
{
    _instanceEnterStore.regFunctor(refFunc, refType);
}

/*! Register a functor that is used by all instances of this class, when
 *  entering a node with a core for which no specific functor was registerd.
 */

void
IntersectActorBase::regDefaultClassEnter(const Functor &refFunc)
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    _pClassEnterStore->regDefaultFunctor(refFunc);
}

/*! Register a functor that is used by the instance of this class, when
 *  entering a node with a core for which no specific functor was registerd.
 *  Instance functors take priority over class functors.
 */

void
IntersectActorBase::regDefaultEnter(const Functor &refFunc)
{
    _instanceEnterStore.regDefaultFunctor(refFunc);
}

/*! Remove a functor registered with regClassEnter.
 */

void
IntersectActorBase::unregClassEnter(const FieldContainerType &refType)
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    _pClassEnterStore->unregFunctor(refType);
}

/*! Remove a functor registered with regEnter.
 */

void
IntersectActorBase::unregEnter(const FieldContainerType &refType)
{
    _instanceEnterStore.unregFunctor(refType);
}

/*! Remove the functor registered with regDefaultClassEnter.
 */

void
IntersectActorBase::unregDefaultClassEnter(void)
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    _pClassEnterStore->unregDefaultFunctor();
}

/*! Remove the functor registered with regDefaultEnter.
 */

void
IntersectActorBase::unregDefaultEnter(void)
{
    _instanceEnterStore.unregDefaultFunctor();
}

/*-------------------------------------------------------------------------*/
/*    Leave Registration                                                   */

/*! Register a functor that is used by all instances of this class, when
 *  leaveing a node with a core of the specified type.
 *  For every type of NodeCore a different functor can be registerd.
 */

void
IntersectActorBase::regClassLeave(const Functor            &refFunc,
                                 const FieldContainerType &refType )
{
    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    _pClassLeaveStore->regFunctor(refFunc, refType);
}

/*! Register a functor that is used by the instance of this class, when
 *  leaveing a node with a core of the specified type.
 *  For every type of NodeCore a different functor can be registerd.
 *  Instance functors take priority over class functors.
 */

void
IntersectActorBase::regLeave(const Functor            &refFunc,
                            const FieldContainerType &refType )
{
    _instanceLeaveStore.regFunctor(refFunc, refType);
}

/*! Register a functor that is used by all instances of this class, when
 *  leaveing a node with a core for which no specific functor was registerd.
 */

void
IntersectActorBase::regDefaultClassLeave(const Functor &refFunc)
{
    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    _pClassLeaveStore->regDefaultFunctor(refFunc);
}

/*! Register a functor that is used by the instance of this class, when
 *  leaveing a node with a core for which no specific functor was registerd.
 *  Instance functors take priority over class functors.
 */

void
IntersectActorBase::regDefaultLeave(const Functor &refFunc)
{
    _instanceLeaveStore.regDefaultFunctor(refFunc);
}

/*! Remove a functor registered with regClassLeave.
 */

void
IntersectActorBase::unregClassLeave(const FieldContainerType &refType)
{
    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    _pClassLeaveStore->unregFunctor(refType);
}

/*! Remove a functor registered with regLeave.
 */

void
IntersectActorBase::unregLeave(const FieldContainerType &refType)
{
    _instanceLeaveStore.unregFunctor(refType);
}

/*! Remove the functor registered with regDefaultClassLeave.
 */

void
IntersectActorBase::unregDefaultClassLeave(void)
{
    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();

    _pClassLeaveStore->unregDefaultFunctor();
}

/*! Remove the functor registered with regDefaultLeave.
 */

void
IntersectActorBase::unregDefaultLeave(void)
{
    _instanceLeaveStore.unregDefaultFunctor();
}

/*-------------------------------------------------------------------------*/
/*    State Class                                                          */

/*! Destructor.
 */

IntersectActorBase::IntersectActorBaseState::~IntersectActorBaseState(void)
{
}

/*! Return of new copy constructed instance of IntersectActorBaseState.
 */

ActorBase::ActorBaseState *
IntersectActorBase::IntersectActorBaseState::clone(MemoryHandle pMemHandle) const
{
    return new IntersectActorBaseState(*this);
}

/*! Return if there are any data members.
 */

bool
IntersectActorBase::IntersectActorBaseState::empty(void) const
{
    return false;
}

/*! Return sizeof(IntersectActorBaseState).
 */

UInt32
IntersectActorBase::IntersectActorBaseState::size(void) const
{
    return sizeof(IntersectActorBaseState);
}

/*-------------------------------------------------------------------------*/
/*    Constructors                                                         */

IntersectActorBase::IntersectActorBase(void) :
      _stateHit(false),
      _stateHitDistance(0.0),
      _stateHitObject(NullFC),
      _stateHitTriangleIndex(0),
      _stateHitNormal(),
      _stateMaxDistance(),
      Inherited()
{
    if(_pClassEnterStore == NULL)
        _pClassEnterStore = new EnterStoreType();

    if(_pClassLeaveStore == NULL)
        _pClassLeaveStore = new LeaveStoreType();
}

/*-------------------------------------------------------------------------*/
/*    Events                                                               */

/*! This is called when the actor is attached to an action. This method can
 *  be overridden in derived classes, but the inherited version must be called.
 */

void
IntersectActorBase::attachEvent(NewAction *pAction, UInt32 uiActorId)
{
    Inherited::attachEvent(pAction, uiActorId);
}

/*! This is called when the actor is detached from an action. This method can
 *  be overridden in derived classes, but the inherited version must be called.
 */

void
IntersectActorBase::detachEvent(NewAction *pAction, UInt32 uiActorId)
{
    Inherited::detachEvent(pAction, uiActorId);
}

/*-------------------------------------------------------------------------*/
/*    State Access                                                         */

/*! Create an instance of this actor's state class.
 *  This method is called from ActorBase::attachEvent, there is no need to
 *  call it manually.
 */

void
IntersectActorBase::createState(void)
{
    if(getStatePtr() != NULL)
    {
        SWARNING << "IntersectActorBase::createState: StatePtr is not NULL. "
                 << endLog;
    }

    setStatePtr(new IntersectActorBaseState());
}

/*! Delete the instance of this actor's state.
 *  This method is called from ActorBase::detachEvent, there is no need to
 *  call it manually.
 */

void
IntersectActorBase::deleteState(void)
{
    if(getStatePtr() == NULL)
    {
        SWARNING << "IntersectActorBase::deleteState: StatePtr is NULL."
                 << endLog;
    }

    delete getStatePtr();
    setStatePtr(NULL);
}

/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning(disable : 177)
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id: OSGIntersectActorBase.cpp,v 1.4 2004/04/21 12:15:21 neumannc Exp $";
    static Char8 cvsid_hpp       [] = OSGINTERSECTACTORBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGINTERSECTACTORBASE_INLINE_CVSID;
}

#ifdef OSG_LINUX_ICC
#pragma warning(enable : 177)
#endif

#ifdef OSG_SGI_CC
#pragma reset woff 1174
#endif

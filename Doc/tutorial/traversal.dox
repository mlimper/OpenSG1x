#include <OpenSG/OSGConfig.h>
#include <OpenSG/OSGNavigator.h>
#include <OpenSG/OSGPerspectiveCamera.h>

OSG_USING_NAMESPACE;

/*! 
\page Traversal Traversal of the Graph
\latexonly Starter:NewChapter \endlatexonly

Chapter Overview
<HR>
	\ref TutorialTraversalActions <BR>
	\ref TutorialTraversalActionsRender <BR>
	\ref TutorialTraversalActionsIntersect <BR>
    \ref TutorialTraversalActionsTraverse <BR>
<HR>

What have we learned so far? We know how to create a scenegraph and we can use the simple scene manager to have a fully functional application. In the last
chapter we even learned how to setup the whole stuff without the simple scene manager. You might remember that we created a render action (osg::RenderAction)
which was passed to the window. The instance of this render action was called passed during the display function

\code
void display(void)
{
	window->render(renderAction);
}
\endcode

Building a scenegraph is only usefull if you do something with it. OpenSG actions are designed to do something with it. In most cases the graph is traversed
and on entering every node some function is called. There are some predefined actions, like the render action, but you can also create your own of course.

\section TutorialTraversalActions Actions

osg::Action objects are created like nodes and cores via ::create() but as these are not derived from osg::FieldContainer simple pointers will do. A render
action is therefor simply created by 

\code
	RenderAction *ra = RenderAction::create();
\endcode

Any action can be executed by calling a single command

\code
	myAction->apply(someNode)
\endcode

Actions can be applied to any node or to a vector of nodes. In any case the action will be applied to all children as it is recursively called to every 
children. However, depending on the action that is beeing executed not every child may be visited. For example you could define an action that traverses the
graph until it encounters a specific node and then ends immediately. The following image illustrates how nodes are visited when applying an action

\image html traversal.png "Sample graph"
\image latex traversal.eps "Sample graph" width=6cm

Assumed that the traversal will not be interrupted by some reason, a traverse starting by node C would visiit the nodes C, F and G in that 
order. If you would start the action at the root node, all will be visited in that order: A, B, C, F, G, D, E, H. Finally you could provide
an vector of nodes, let's say G and E then the visited nodes would be G, E and H.

Another example: If you start with root node A and node C will return Action::Skip then the processed nodes are A, B, C, D, E, H. Node C
itself is processed but not it's children.

\section TutorialTraversalActionsRender Render Action

This action was used by the simple scene manager right on from the beginning. Needless to say that it's primary task is to transform the scene graph into 
an two dimensional image that can be displayed on the screen. If you do not use the simple scene manager you need to tell the window of your application what
render action to use. If you have not something really fancy in mind, the osg::RenderAction is all you need to do the job. 

The render action actually does a lot of important work for you. In the background a draw tree is generated (which will minimize OpenGL state changes), geometry
is culled against the view frustum and transparent objects are sorted from back to front to ensure correced rendering of multiple transparencies. 

You can turn off view frustum culling via setFrustumCulling() and for debugging purposes you can turn on the rendering of bounding volumes with setVolumeDraw()
as well as deactivate the update of the view frustum with setAutoFrustum().

\section TutorialTraversalActionsIntersect Intersect Action

osg::IntersectAction might be very useful for some problems, but it may also cause some new performance problems, because this is not very optimized right now.
This action enables you to send a ray from a position into a direction of your choice. Afterwards you can gain detailed information about the first object that
was hit. Here is a little example on how you would typically use the intersect action.

\code
	Line ray = Line(Pnt3f(5,0,-10), Vec3f(0,-1,0));
	IntersectAction *iAct = IntersectAction::create();
	
	iAct->setLine(ray);
	iAct->apply(someNode);
	
	if (iAct->didHit()){
		std::cout << "Hit Point : "<< act->getHitPoint();
	}
\endcode

<I>
	We would sent a ray from (5,0,-10) in the opposite direction of the y axis. If we hit something the intersection point will be printed on screen.
</I>

Please notice that intersection test are really expensive. It will be sufficient for object picking and similar things, but collision dectection for example
would require collision models to be fast enough. I myself participated in an project where we used OpenSG for driving a stereo application. We fist used
the intersect action every frame and tested against the geometry to determine if the user ran into some obstacle. Well, that was not a very good idea, our
framerate dropped from more than 30 down to three frames per second. We later had collision wall models with very few polygons. With that we were able to use
the intersect action again.

\section TutorialTraversalActionsTraverse Traverse Action

Traversal of a graph is very important and used by many important features like both actions I presented above. We also were in need of something similar:
Please remember the \ref TutorialNodeCoresTutorial from Chapter \ref NodeCores, where we tried to find a specific node with a specific name in the graph. We
implemented a little helper function that will start at the root node check if the name matches the search string (which was hard coded at that point) and if
not recursivly calling that fucntion with all children. Here is the code of that function again

\code
NodePtr checkName(NodePtr n){
    UInt32 children = n->getNChildren();
    
    //make sure a name existes
    if (getName(n))
        //check if it is the name we are looking for
        if (getName(n)== std::string("FACESET_Woman"))
            // We got the node!
            return n;
    
    //check all children
    for (int i = 0; i < children; i++){
        NodePtr r = checkName(n->getChild(i));
        if (r != NullFC)
            // if it is not NullFC it is the node we are looking for
            // so just pass it through
            return r;
    }
    // no children's name matches or there are no more childs
    // so return NullFC, indicating that the node was not found yet
    return NullFC;
}

\endcode

It would be no big deal to replace the hard coded string with some search string variable, but still this function would not be very flexible or efficent. 
OpenSG offers some help if you need to traverse the graph for some reason.

OpenSG is constantly traversing the tree when rendering for example. You can use the same powerful functionality by using the traverse() function. This function
needs a root where to start from and one or two functions which will be called when entering or leaving a node. The following simple example will show a
traversal of some graph by printing either "enter" or "leaving" when entering or leaving a node.

First we need a function that will be called when we enter a node

\code
Action::ResultE enter(NodePtr& node){
	std::cout << "Enter node : " << node << std::endl;
	
	return Action::Continue;
}
\endcode

The first line should be obvious, the second line returns Action::Continue, which simply means that the traversal of the graph should be continued. By returning
Action::Skip you tell OpenSG to not continue with the current node and thus skipping it and all children, but continuing with all other nodes still left. 
Action::Quit finally stops the traversal, no new node is entered.

Here is the function that will be called when leaving a node

\code
Action::ResultE leave(NodePtr& node, Action::ResultE result){
	std::cout << "Leaving node: " << node << "with code: " << result << std::endl;
	
	return result;
}
\endcode

Well, we now have both functions we need, but we actually still need to call the traverse fucntion. This may look a bit weird...

\code
	traverse(scene, 
		osgTypedFunctionFunctor1CPtrRef<Action::ResultE, NodePtr>(enter), 
		osgTypedFunctionFunctor2CPtrRef<Action::ResultE, NodePtr, Action::ResultE>(leave));
\endcode

This command would have started the graph traversal. Let's have a closer look at these commands. As mentioned earlier, the traverse function needs a node
where to start from, which is the "scene" node in this example. Alternativly you can also provide a std::vector of nodes instead of a single node. Next we have
two long parameters. The traverse function needs so called OpenSG functors, which can be created with osgTypedFunctionFunctorXCPtrRef where X is the number
of arguments. So creation rules for the functor creation is like that

<PRE>
	osgTypedFunctionFunctorXCPtrRef<returnType, Argument1, Argument2, ..., ArgumentX>(functionName)
</PRE>

It is also possible to reference a method of some object instead of a function. I will demonstarte that in the tutorial at the end of this chapter.

Anyway, what is the use of all this? Well you might need to traverse the graph more often than you think. If you want to print the number of all triangles for
every geometry node for example you could create an "enter" function which checks if that node core is derived from osg::Geometry and if that is the case, calls
a function that will count the polygons.

\section TutorialTraversalGraphOps Graph Operators

[TODO: complete this section]

\section TutorialTraversalTutorial Tutorial - Graph Traversal

In this tutorial we are going to load a VRML file from disk (you already know that from \ref TutorialBasicTutorial4) containing a simple scene with just three
objects - a torus, a sphere and a cone. This file was created using a 3D modelling package. All three objects are named after what they are. No additional 
features, like textures or geometry modifieres from the modelling package were used. I will use some different approaches on how to use traverse() and
osg::GraphOps

Again we take 00framework.cpp as a starting point. First we need to add some include files we already know from other tutorials

\code
	#include <OpenSG/OSGSceneFileHandler.h>
	#include <OpenSG/OSGSimpleAttachments.h>
\endcode

You also should activate the standard namespace.

\code
	using namespace std;
\endcode

At the beginning we are going to load the VRML file mentioned above. This, too, should look a bit familiar to you by now. Paste this block of code into the
createScenegraph() function.

\code
	NodePtr n = SceneFileHandler::the().read("data/torus_sphere_cone.wrl");
    
    //we check the result
    if (n != NullFC)
		return n;
    else{
        cout << "Loading the specified file was not possible!" << endl;
        return NullFC;
    }
	
	return n;
\endcode

Let us start with something simple: When the 'p' button is pressed our application should print a list of the names of every node found in the scenegraph. We
first need a functor function which will print the nodes name on entering during traversal of the graph.

\code
//This is the function that will be called when a node
//is entered during traversal.
Action::ResultE enter(NodePtr& node){   
    if (getName(node)){
		cout << getName(node) << endl;
	}else
		cout << "No name was set!" << endl;

    return Action::Continue; 
}
\endcode

Now add a keyboard callback function like in some of the other tutorials. The following code should be executed when the 'p' key is pressed

\code
			cout << endl << endl;
			cout << "Printing all node names";
			cout << "---------------------------------------";
			cout << endl << endl;
			
			// now we invoke the traversal
			traverse(scene, 
					osgTypedFunctionFunctor1CPtrRef
					<Action::ResultE, NodePtr>(enter));
\endcode

Now compile and execute the application. After the window appears push 'p' and watch for output in the terminal. If nothing happens, make sure that the window
and not the terminal is active. The result should look like this

\image html terminal_results.png "Terminal results"
\image latex terminal_results.png "Terminal results" width=6cm

As you can see there are three nodes whose name contain the prefix FACESET_ which we encountered before when we were implementing a search for the geometry core
of the woman modell in section \ref TutorialNodeCoresTutorial. Some nodes have no name set at all but three other have exactly the same name as it was provided
in the modelling package (torus, sphere and cone).

It seems that the FACESET_* nodes were created automatically when exporting a scene to VRML. During the tutorial I just mentioned that FACSET_woman node 
stored the geometry core, maybe nodes named FACESET_* always contain the geometry cores? We can proof the assumtion by implementing another traversal action.
Instead of the most simple enter() function we used above we now will have a functor that checks if the current node's core is derived from osg::Geometry and
if that is true it will priint the name of that node. If our assumtion is correct we will have only node names beginning with FACESET_ . Of course this will
only be correct if you have not created your own geometry or loaded some other files.

\code
//This function will test if the core is of type
//geometry and if it is, it will print the node's
//name
Action::ResultE isGeometry(NodePtr& node){
	// this tests if the core is derived from geometry
	if (node->getCore()->getType().isDerivedFrom(Geometry::getClassType()))
		if (getName(node))
			cout << "Found a geometry core stored in " << getName(node) << endl;
		else
			cout << "Found a geometry core but node has no name" << endl;
	
	return Action::Continue;
}
\endcode

Extend the keyboard() function in that way, it will react to the 'g' key and start a traversal using the isGeometry() functor. The code is nearly identical to
the other case. After you have finished that compile and execute the application. 

After you have pushed the 'g' key you will know that our assumtion was correct! If you have problems compiling it you can have a look at the complete program 
here : <a href = "progs/12traversal.cpp">progs/12traversal.cpp</a>
*/
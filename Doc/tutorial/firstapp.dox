#include <OpenSG/OSGConfig.h>
#include <OpenSG/OSGNavigator.h>
#include <OpenSG/OSGPerspectiveCamera.h>

OSG_USING_NAMESPACE;

/*! 
\page FirstApp First Application

\section FirstAppTutorial First Tutorial

Now it is time to develop our first application. The following code will create a wonderful torus and... well, that is all. Every
palace is build upon a first stone, and this torus will be ours! You can copy and paste this code or you can use the provided file. You will
find all files related to this online tutorial in <PRE>../your_opensg_folder/Doc/tutorial/progs</PRE> of your copy of OpenSG. The filenames are
given at the beginning of the appropiate tuotorials. 

\code

// File : 01firstapp.cpp

//what follows here is the smallest OpenSG programm possible
//most things used here are explained now or on the next few pages, so don't 
//worry if not everything is clear right at the beginning...

//Some needed inlcude files - these will become more, believe me ;)
#include <OpenSG/OSGGLUT.h>
#include <OpenSG/OSGConfig.h>
#include <OpenSG/OSGSimpleGeometry.h>
#include <OpenSG/OSGGLUTWindow.h>
#include <OpenSG/OSGSimpleSceneManager.h>

//In most cases it is useful to add this line, else every OpenSG command
//must be proceeded by an extra OSG::
OSG_USING_NAMESPACE

//The SimpleSceneManager is a little usefull class which helps us to 
//manage little scenes. It will be discussed in detail later on
SimpleSceneManager *mgr;

//we have a forward declarion here, just to sort the code 
int setupGLUT( int *argc, char *argv[] );

int main(int argc, char **argv)
{
	// Init the OpenSG subsystem
	osgInit(argc,argv);
	
	// We create a GLUT Window (that is almost the same for most applications)
	int winid = setupGLUT(&argc, argv);
	GLUTWindowPtr gwin= GLUTWindow::create();
	gwin->setId(winid);
	gwin->init();

	// That will be our whole scene for now : an incredible Torus
	NodePtr scene = makeTorus(.5, 2, 16, 16);

	// Create and setup our little friend - the SSM
	mgr = new SimpleSceneManager;
	mgr->setWindow(gwin);
	mgr->setRoot(scene);
	mgr->showAll();
    
	// Give Control to the GLUT Main Loop
	glutMainLoop();

	return 0;
}

// react to size changes
void reshape(int w, int h)
{
    mgr->resize(w, h);
    glutPostRedisplay();
}

// just redraw our scene if this GLUT callback is invoked
void display(void)
{
	mgr->redraw();
}

//The GLUT subsystem is set up here. This is very similar to other GLUT applications
//If you have worked with GLUT before, you may have the feeling of meeting old friends again,
//if you have not used GLUT before that is no problem. GLUT will be introduced shortly on the
//next section

int setupGLUT(int *argc, char *argv[])
{
	glutInit(argc, argv);
	glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);
    
	int winid = glutCreateWindow("OpenSG First Application");
    
	// register the GLUT callback functions
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);

	return winid;
}

\endcode

That is all to get a little nice window, displaying a torus. I admit that there are OpenGL programs out there, that are shorter
and do the same - but that will soon change, as our tutorials will get more advanced.

The first thing that is boring, is the fact the we can not interact with our newly created virtual world. It would be wonderfull
to have some mouse input, that we can navigate with. So that will be our first task - open (if you have closed it) the file you
just created and go to the setupGLUT function. Just below the other two callback functions add these two lines

\code
glutMotionFunc(motion);
glutMouseFunc(mouse);
\endcode

and add this whole method anywhere before the declaration of the setupGLUT function

\code
// react to mouse motions with pressed buttons
void motion(int x, int y)
{
	mgr->mouseMove(x, y);
	glutPostRedisplay();
}

// react to mouse button presses
void mouse(int button, int state, int x, int y)
{
    if (state)
        mgr->mouseButtonRelease(button, x, y);
    else
        mgr->mouseButtonPress(button, x, y);
        
    glutPostRedisplay();
}
	
\endcode

The complete file of our first little programm can also be found in the progs folder as 
<a href="../../progs/01firstapp2.cpp">01firstapp2.cpp</a>

\subsection FirstAppTutorialMakefile A Makefile 

As far as well - but still we need to compile that file we just created. Windows users should paste the
code simply in one of the existing tutorial files where as Unix users should create a little makefile. 
Because the last part is a bit tricky a present a makefile which is ready to use and which can easily be 
taken as a starting point for own better suited makefiles

\code
# File : Makefile

# Very general use makefile for compiling OpenSG Programs
# This makefile will compile every programm in this folder 
# with a filename like this 01******.cpp

# "opt" if you use the optimized library otherwise it is "dbg"
LIBTYPE ?= dbg

# set the path to the installed osg-config executable here
# e.g. if you installed in /usr/local it is
OSGCONFIG := /usr/local/bin/osg-config

CC = "$(shell $(OSGCONFIG) --compiler)"
CCFLAGS = $(shell $(OSGCONFIG) --cflags --$(LIBTYPE) Base System GLUT)
LDFLAGS = $(shell $(OSGCONFIG) --libs --$(LIBTYPE) Base System GLUT)

# all tutorials in this directory

TUTS :=  $(wildcard [0-9][0-9]*.cpp) 
PROGS := $(TUTS:.cpp=) 

# program dependencies

default:	$(PROGS)

# make rules

# by the way, do not let it bother you, if you do not understand that
# "makefile-magic". You can write great programs without this knowledge,
# I know that ;)

.PHONY: clean Clean

clean:
	rm -f  *.o 

Clean: clean
	rm -f $(PROGS) 

%.o: %.cpp
	$(CC) -c $(CCFLAGS) $<

%: %.o
	$(CC) -o $@ $< $(LDFLAGS)

%: %.cpp
	$(CC) $(CCFLAGS) $< $(LDFLAGS) -o $@ 
	
\endcode

\section FirstAppTutorialGLUT GLUT

If you are familiar with GLUT, you can skip to the next Section right away, 
otherwise you may find it usefull, even tough GLUT is not a must as OpenSG 
applications can also be driven by other windowing systems like QT or MFC.

So what is GLUT? GLUT stands for GL Utility Library - with GLUT you can easily
create a window in which OpenGL renders. Furthermore you can access the keyboard
and mouse with just a few lines of code. That is what OpenSG uses GLUT for. Of course 
it is not as Powerfull as QT, but is much more simpler to handle. 

GLUT is alwasy initialized at the beginning by telling the library the size of the
window, the color depth and similar things. Afterwards the callbacks are registered.
Let us have a closer look at that

\code
int setupGLUT(int *argc, char *argv[])
{
	glutInit(argc, argv);
	glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);
	int winid = glutCreateWindow("OpenSG First Application");    
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);

	return winid;
}
\endcode

glutInit does some magic initialization stuff which should not concern us right here.
The paramters given to glutInitDisplayMode are telling GLUT to use the RGB Color Mode and
that it shuld activate the depth buffer of OpenGL whereas GLUT_DOUBLE tells the library to
use a double buffered window mode which rewards us with smoother graphics. If you do not specify
the GLUT_DEPTH constant you will have no depth testing in your OpenSG application what is most
likely not what you want.

And what about those callbacks? If you have a look at the main method of our first application you
will notice that the last command (before the return) is the glutMainLoop(). Calling this will give control
of your application to GLUT. That is if you have registered not a single callback you will never get control
back... even worse you won't be able to see anything on the sceen exept a black window. So what does this 
main loop actually do. Without going in too much of unecessary detail it simply checks if any event occurs 
that a callback is registered for and if that is the case this method will be invoked. There is at least 
one callback you should always register (and of course implemet) and that is the display function. This function
will always be called if the window needs to be redrawn. That is either the case if the operating system says
that this window needs redrawing or you explicitly tell the system (via glutPostRedisplay() for example).

Well, we registered the display callback like that

\code
glutDisplayFunc(display);
\endcode

so we need a method called display that actually implements what needs to be done when it comes to drawing the
window. Let's have a look what we have done

\code

void display(void){
    mgr->redraw();
}
\endcode

That is not really much, is it not? Normally a lot of stuff is done here, because that is what we will see on screen
in the end. If you  would write an usual OpenGL application with GLUT but without OpenSG you would place all your
drawing related OpenGL commands here and that is quite a lot! 

Fortunately we do use OpenSG, so in most cases we do not need to hack OpenGL commands directly. OpenSG does
the dirty work for us ;). Maybe you wonder what is behind that magical line? That is what the next section is about...

A last word about the other callbacks: The procedure is always the same, you register the disired callback somwhere at the 
beginning and you implement the method you provided as the argument. This method will called if the corresponding event occurs,
that is the keyboard callback is invoked when pressing a key and the mouse callback when the mouse button is pressed ans so on.

\section FirstAppTutorialSSM Simple Scene Manager

The Simple Scene Manager is a little useful helper class for quickly creating simple scenes. If you do not want to use the 
Simple Scene Manager (SSM) you would have quite a lot of work to to. You have to create a window, add a viewport to that window,
create one or more lights and a camera and you have to bind that all together. Sometimes that has to be done as the manager
is useable for simple scenes only (as the name already says), but that will be discussed in detail later. For now we are happy
with the SSM as it does all of the tasks described above for us. 

Sometimes using the SSM is not a good idea. If you are devolping a stereo application for example you would have to change so
much that it is an better idea to write your own code from bottom up. As a rule of thumb you can and should use the SSM if and
only if you want to have a window with one viewport and a perspective camera. If you want to change the navigation mode or
the light sources you can easily do that.

\subsection FirstAppTutorialSSMUsage How to use the Simple Scene Manager

In neraly every case you use the SSM you need it global. So like in the \ref FirstAppTutorial we define a global variable mgr as
pointer. Of course we need to include the header file for the SSM

\code
#include <OpenSG/OSGSimpleSceneManager.h>

// ....

SimpleSceneManager *mgr;
\endcode

The next thing we need to to is to create a instance of the SSM and tell it the two most important thing: the window which will
be used for the rendering output and the root node of the scenegraph

\code
//call the constructor with no arguments
mgr = new SimpleSceneManager;
// set the rendering window (look at 01firstapp.cpp on how to create the window)
mgr->setWindow(gwin);
// set the root of the scenegraph
mgr->setRoot(scene);
// makes the hole scene visible
mgr->showAll();
\endcode

The last command ensures the correct position of the camera, so that the whole scene will be visible. And as we have seen above,
if we now want to display our scene we only need to call the showAll command - that is all. Of course the node refrenced by the 
varibale scene need to contain something, but that will be discussed soon. For now we are happy that we can create a torus by  typing

\code
NodePtr scene = makeTorus(.5, 2, 16, 16);
\endcode

You can play a bit with the paramters and see what is happening. Be careful with the last two parameters... you will now if you figure
out what they are for.

Maybe you have already some knowledge of OpenSG and want to know what the SimpleSceneManager actually creates for you. 
So here it is: A simple single fullscreen Viewport (Viewport), a perspective Camera (PerspectiveCamera) and a simple 
pointlight (Pointlight) attached to the camera are created for you. In addition to that a simple Navigator (Navigator) 
is created which allows you do rotate with the left, to pan with the right and to zoom with the middle mouse
button, except for me (Mac user with an one button mouse...).

\section FirstAppTutorialScenegraph The Scenegraph

I guess the probability that you already know about scenegraphs is very high, because you are reading these lines right now. So
it would be worth a whole book to discuss scenegraphs in every aspect and detail. That cannot be achieved here and it also won't 
be necessary, so I make it short. 

To get a feeling for the power that lies within scenegraph systems we should look at recent computer games. If the 300+ first person
shooters found at a time in stores is good for kids is a question we will not discuss here, but one thing is for sure: the high
demand for these games have pushed the development of high performance graphic cards and other technologies. They show us in a very
illustrative way what is possible in computer graphics. And they all rely on a scenegraph one way or another. 

A Scenegraph holds a scene efficient in memory and tries to sort the big polygon soup so it can be passed to the hardware in a most 
efficient way. If you have some basic knowledge of OpenGL you will know that the glBegin(...) and glEnd command is very expensive. 
Imagine you have one hunderd red and one hundret blue triangles and you draw them all in a loop, first a red one, then a blue, and a red
and so on. If programmed in a very bad manner this can result in 200 glBegin/End blocks and 200 color state changes. If programmed 
well it only requires on begin/end block and two color state changes. A good scenegraph will sort the triangles in the last way no matter
what the input was. Of course this is a very synthetic example, but real life will show you that big scenes coded by hand are never 
optimal and with models exported from another software it gets even worse.

Another very important aspect of scenegraphs is, that they have knowledge of the entire world. So you can check if parts of your scene
are not visible. There is no need to render things that are behind the camera. The scenegraph detects parts that are not inside the
viewing frustum and do not render them. In this way a lot of processing time is saved.

\subsection FirstAppTutorialScenegraphCompared OpenSG Scenegraph compared to oher systems

Most scenegraphs have a similar data structure. Nodes are used to build a graph and these contain information about the functionality
at this point. Nodes may contain information about transformations, materials, geometry and a lot of other stuff. On of the biggest 
differences is, if the scenegraph is a muti- or single parent one. 
Imagine the simplified model of a car consisting of a body and four wheels. 
The geometry of every wheel is identical, so you do not need four wheels in memory. If you have a single parent scenegraph, there is no
way, you need to have four copies of the wheel. A multi parent system only needs four transformations relative 
to the body of the car and one wheel which is applied to every four transformations and thus a complete car will be rendered. 
All modern scenegraph systems are using multi parents only the way it is implemented and used differs. 
A very common way is to use nodes only which are storing all relevant information. 

\image html car_graph_general.png "This graph shows the concept how scenegraphs work"
\image latex car_graph_general.eps "This graph shows the concept how scenegraphs work" width=8cm

In OpenSG nodes are only used to define the hierarchy of the graph. They store their children (if any) and a core. The core is
the place where all the important information is stored, i.e. geometry, transformations etc. Import to know is, that every node
can only have one parent, but of course as many childs as necessary. If for some reason a new parent is assigned to a node, the 
former parent will be replaced by the new one (Actually not the node itslef, but the link to it). The cores themselfs can be referenced
by as many nodes as desired. 

\image html car_graph.png "A simple graph demonstrating how node and cores a used in OpenSG"
\image latex car_graph.eps "A simple graph demonstrating how node and cores a used in OpenSG" width=8cm

<I>The yellow circles are standing for the nodes where the ornage rectangles are cores. As you can see every node has one parent, but
the wheel geometry core has four. There are four different transform cores and every one of them stores a unique transform matrix.</I>

If you compare the two last pictures it seems that the concept of how OpenSG works is much more difficult. You will see soon, that 
actually the separtion of core and node is very easy to handle. It may produce some additional lines of code, but later on you will 
also see what the big picture of this concept is.

*/
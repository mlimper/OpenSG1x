#include <OpenSG/OSGConfig.h>

using namespace OSG;

/*! 

\page TutorialBasics Basics
\latexonly Starter:NewChapter \endlatexonly

If you have read this online tutorial right from the beginning, you are able to install OpenSG, you know a few things about GLUT, the 
Simple Scene Manager und you have compiled and executed your first program. Well that is good, but you need to know a bit more
before you write your first real application for yourself. In this chapter I will show you the basic things of OpenSG, that is: 
<UL>
    <LI>math using OpenSG classes</LI>
    <LI>creating new nodes and cores</LI>
    <LI>Fieldcontainer</LI>
    <LI>Images</LI>
    <LI>Loading and saving</LI>
</UL>

\section Datatypes Datatypes

OpenSG has it's own base types for integers and floats. In many cases you can get along by using int, float etc. as you normally
would, but if you want to develop a cross platform application it might be safer to use the OpenSG wrapper base types. 

These types can be easily identified by their names
<TABLE>
  <TR>
    <TD>[U]Int<I>N</I></TD><TD><I>N</I> defines how many bits to use.8, 16, 32 or 64 is allowed. The optinal U stands for unsigned </TD>
  </TR>
  <TR>  
    <TD>Real32, Real64, Real128</TD><TD>Floating point with either 32, 64 or 128 bytes</TD>
  </TR>
</TABLE>

An unsigned 32 bit integer is therefor <I>UInt32</I>. The reason for using these wrapper is, that the usual "int" variable is 32 bits
long for most systems... but not for every system. By using Int32 you do not have to care, you can be sure that this type is always
that long.

\section BasicMath The Math Stuff

OpenSG comes together with it's own classes for calculating with Vectores, Matrices etc. We all know that there are approximately a 
thousand other math libraries which are more or less equal powerful. If you are in need of lots of mathematical computations and high
performance is very critical to you have not to use the internal classes of OpenSG, but for every other purpose you should do so as 
all methods of OpenSG are working with their own types of course.

As you might expect we have types for all you need related to computer graphics: Vectors with different precision and with two up
to four components, as well as the same for matrices.

There are 21 different vector type which I will not list individually, but the construction rules are similar to the base types.

<PRE>Vec<I>N</I>{b, ub, s, us, f, d, ld}</PRE>

<I>N</I> again is the dimension which must be chosen between two and four. From the list of letters you also must choose one, which 
defines the type used for storing the values.

<UL>
<LI>
    b is Int8
</LI>
<LI>
    ub is UInt8
</LI>
<LI>
    s is Int16
</LI>
<LI>
    us is UInt16
</LI>
<LI>
    f is Real32
</LI>
<LI>
    d is Real64
</LI>
<LI>
    ld is Real128
</LI>
</UL>

The one you need in most circumstances is most likely to be Vec3f, a three dimensional vector with float values.

\subsection BasicMathWorkinfWithVectors Working with vectors

The OpenSG vector classes can do verything you expect from them and probably even more ;-). Here is an overview of the most important
operations. Have a look at osg::Vec3f (or any other vector) for a full list of their methods

\code
// two nice 3d vectors
Vec3f v = Vec3f(1,2,3);
Vec3f w = Vec3f(0.5,2.5,5);

// get the length of a vector 
Real32 l = v.length();
// float or double is possible, too
float l = v.length();

// if you only want to figure out which vector is longer you do not
// need the exact euclidian length. (You can spare the square root)
Real32 lq = v.squareLength();

// normalize a vector (length will become 1)
v.normalize();

// the cross product of two vectors
Vec3f e = v.cross(w);
// ATTENTION: cross product is only implemented for 3 dimensional vectors

// dot product
Real32 d = v.dot(w);

// access to individual components
Real32 c1 = v[0];
Real32 c2 = v[1];
Real32 c3 = v[2];

// you can use mathematical operations the same way as with integers and floats

Vec3f s = v+w;

if (v==w)
    cout << "these vectors are equal" << endl;

 
\endcode

\subsection Basicpoints Points

Points are quite similar to vectors. They come in all the same variants like them, only replace "Vec"
by "Pnt" and you have it. The difference compared to vectors is that Points mark a definite location
within the spacial domain, where vectors are not bound to a specific point as they represent a 
direction or power (you remember ;-)...)

Let us say points are vectors with some fewer possibilities. Of course points cannot be normalized and
there is no dor product between to points. Please notice that two Points can be added neither! If you
need to convert between vectors and points, there are two useful methods to do that

\code

// conversion point to vector (let p be some point and v some vector)
v = p.subZero

//or vice versa
p = v.addToZero();

\endcode

\subsection BasicColor Colors

Colors, too, are similar to vectors. They are available in three or four dimensions, where the fouth
dimension represents the alpha channel, whereas the first the are RGB color channels. The color
classes support also the HSV color modell. They have named access methods (red, green and blue)
with which you can access the values in a more reasonable way than with color[1]. Furthermore
scalar multiplication is possible but most other operations known from vectors are missing as they
are not needed.

Detailed information about the methods for colors can be found at osg::Color3f

\subsection BasicMathWorkWithMarices Working with matrices

Matrices behave quite similar to vectors. As there is no default type for vectors, there is one
for matrices: Like in OpenGL it is 4x4 with Real32 components. The multiplication convention is 
just the same as in OpenGL:
<PRE>v'=M*v</PRE>

In OpenSG matrices are stored column major like shown in the next picture

\image html matrix_storage.png "Storage of a matrix in memory"
\image latex matrix_storage.eps "Storage of a matrix in memory" width=8cm

The first column vector can be retrieved with a simple matrix[0]. Storing the values in this manner 
has a little advantage compared to row major storage as you can easy access the matrix coordiante
space, especially matrix[3] deliver you automatically the translation from the origin.

There are several ways to construct a matrix that matches your needs. It is possible to create a 
matrix by providing all components one by one or by passing the base vectors or you can use
some methods of the matrix class to create a matrix with certain properties.

\code

// we want to create a matrix that scales the world at the y axis by factor 2 and also translates
// by (2,2,3). As we all know from old days in school the corresponding matrix is 

// | 1 0 0 2 |
// | 0 2 0 2 |
// | 0 0 1 3 |
// | 0 0 0 1 |

// first we create the matrix by passing all values directly

Matrix m;

m = Matrix(1,0,0,2,0,2,0,2,0,0,1,3,0,0,0,1);
// ATTENTION : noticed something? The arguments are passed row major! This applies to
// this specific constructor only!

// if we had base vectors like this...
Vec4f v1 = (1,0,0,0);
Vec4f v2 = (0,2,0,0);
Vec4f v3 = (0,0,1,0);
Vec4f v4 = (2,2,3,1);

// ... we can also make our matrix by ...

m = Matrix (v1,v2,v3,v4);
// of course column major, as expected

// But really practical are these variants

// this one resets the matrix to identity
m.setIdentity();

// we set the scale factor
m.setScale(1,2,1);
// and the translation
m.setTranslation(2,2,3);

// ... and here we go

// now we want to multiply a matrix and a vector

Vec3f a = Vec3f(1,2,3);
Vec3f result;

m.mult(a, result);

// ATTENTION: remember matrix multiplication when you did it manually? We are 
// multiplying a 4x4 matrix with a 3x1 vector. Actually that should not work... 
// but in OpenSG it does, not because of a false implementationm, but with 
// respect to the fact that the fourth row is rarely used as it is (0,0,0,1)
// in most cases. This is why OpenSG assumes that you actually multiply a 4x3 
// matrix with a 3x1 vector... and that is ok!

// as you might have guessed the result of the mutiplication is assigned to the 
// vector "result"

// multiplication of two matrices work in exactly the same way

\endcode

Please notice the following, when using the setter methods for matrices. These methods overwrite
only the components they need to, leaving all others untouched, i.e if you have a matrix and want
to change the translation you have to be sure that the other values are correct, too. The method
setIdentity overwrite all values of course!

Have a look at osg::Matrix for a complete list of all setter methods available.

\subsection BasicQuaternion Quaternions

The last topic for this OpenSG-math-quick-tour are quaternions. The background of quaternions is quite
not simple to understand, but do not worry, you can use them without knowing how they work - I can
stand proof for that ;)

So what are quaternions about? You might know that interpolating between rotation matrices does not
work that well. That is if you have a matrix describing a 30 degree rotation around the y axis and 
another matrix doing the same with 60 degree you just cannot interpolate between these to for an 
animation. 

Quaternions are an execellent solution to this problem. They are described by an angle and a vector.
The angle is the amount that you want to rotate around the vector you provided. As you might expect 
know it is possible to interpolate between two quaternions and as these can be easily transformed 
into a matrix we now can realize custom rotations around any axis. The following example solves 
the situation described above

\code

// well this is a bit theroetical... we will have more real-world examples 
// within the next tutorial

// we need a quaternion and a matrix
Quaternion q;
Matrix m;

// reset our matrix
m.setIdentity();

for (int t = 0; t < 30; t++){
    // the given angle is in radians per default
    q = Quaternion(Vec3f(0,1,0), (30+t/180)*PI );
    m.setRotation(q);
    
    // draw the scene here ... 
}

\endcode

If you do not like radians you can also use degree by invoking 
<PRE>q.setValueAsAxisDeg(Vec3f(...), 90)</PRE>

Furthermore standard operations like length(), normalize(), inverse(), multiplication, slerp and
others are possible. Detailed information are here : osg::Quaternion

\section BasicNode Nodes

Nodes are in some way the most important object in a scenegraph. In OpenSG the nodes descibe the 
hierarchy of the graph only! Here is a simple graph we want to build:

\image html simple_graph.png "The family scenegraph"
\image latex simple_graph.eps "The familiy scenegraph" width=4cm

\code

//First, we create all the nodes we need
osg::NodePtr grandpa = osg::Node::create();
osg::NodePtr aunt = osg::Node::create();
osg::NodePtr mother = osg::Node::create();
osg::NodePtr me = osg::Node::create();

// uh, what is happening here???
// I guess you expected somthing like
// Node n = Node();
// do not worry, explanation will follow hereafter...

// now we create the hierarchy
beginEditCP(grandpa);
    grandpa->addChild(aunt);
    grandpa->addChild(mother);
endEditCP(root);

beginEditCP(mother);
    mother->addChild(me);
endEditCP(mother);

// beginEditCP()??? That, too, will be discussed in Detail later

\endcode

This little piece of code would generate a graph that would look like in the picture above. 
Would you be able to render that graph? You can try out what will happen: Have a look at the 
code from our \ref FirstAppTutorial and replace the following line

\code
    NodePtr scene = makeTorus(.5, 2, 16, 16);
\endcode

with the example code from above. But be carful, with grandpa it will not work, you have to rename him
to "scene", because the Simple Scene Manager is told to use scene as root.

And? Did it work? We will come back later to this little example.

\subsection BasicNodeCreate Creating new nodes and other objects with ::create()

You might wonder why objects are instantiated this unsual way. Actually the "normal" way will not work
for most OpenSG objects.
In fact calling
<PRE> Node n = Node() </PRE>
will get you an error during compiling like this one
<PRE> osg::Node::Node() is protected within this context </PRE>
Well, that is looking bad. What to do, if the constructor is obviously not public thus it cannot be called.
I remember still when I faced this probem, looking like a cow at the screen... 

Actually every class that is derived from FieldContainer has protected constructors whereas other classes, 
like the math classes we just saw, have their constructors declared public as usual. So if you are unsure 
wether you can use the constructor as usual, just have a look at the inheritance diagramm and if none of
the parents is of type FieldContainer then it will work.

If that is not the case, you must invoke the static create() method as you saw above. This static method
wrapps the constructor. It is done this way to ensure multithread safty, but we will discuss that in
an own chapter.

\subsection BasicNodePtr Smart Pointer

Alright, we now understand when we have to use create, but another strange things is the fact, that the
variable which represents a node is not of type "Node", but "NodePtr". take it as a rule of thumb:
For every <I>object</I> created with ::create() the returning type is a corresponding <I>objectPtr</I>.

Here are some examples
\code
NodePtr n = Node::create();
TransformPtr t = Transform::create();
GeometryPtr geo = Geometry::create()
ShearedStereoCameraDecoratorPtr sscd = ShearedStereoCameraDecorator::create();
\endcode

I think you get the picture. These Ptr classes are smart pointer. That means if you pass them around to
other methods you copy only a pointer (i.e a pointerclass) and not the actual object. This is very 
important to know. Let us imagine you have a GeometryPtr which points to model of a tree which is as large
as 5 MB. It actually does make a big difference if you pass the whole 5 MB or just the tiny pointer 
to another method. As I assume that you are familiar with the concept of pointers you might say, that this
is not very special as that is what a pointer does. The smart thing with these pointers from OpenSG is, 
that they are multithread safe and that you don not need to manually delete them in most cases as these
are reference counted. If you create an object it has an reference count of zero. Some operations like adding
it as a child to another node increses the reference count by one, whereas others decrease it by one 
(this is for example deleting a child). Whenever the reference count goes down to zero the object is deleted
auomatically. This is very nice to work with, but there are also some aspects to look after.

This little example demonstrates what can go wrong with smart pointers

\code
    Node a = Node::create();
    Node b = Node::create();
    Node c = Node::create();
    
    // we add "a" as a child to "b"
    beginEditCP(b);
        b->addChild(a);
    endEditCP(b);
    
    //no, we want "a" to be a child of "c"
    beginEditCP(b);
        // this removes "a" as a child of "b"
        b->subChild(a);
    endEditCP(b);
    
    //and now add it to "c"
    beginEditCP(c);
        c->addChild(a);
    endeditCP(c);
\endcode

Well, looks good, does it not? Actually your compiler will take it as it is correct in it's syntax, but if
you run an application with this piece of code it will crash! If you do not not why you should think 
about it before reading ahead...

Okay, no big deal? The explanation stands right above the code... when we call subChild on a the reference
count is reduced from one to zero and is then immediatly deleted from memory. When we want add a to c we 
are operating on a non existent object - and that is never good.

So if you want to change parents of a node you need to make sure that it's reference count stays above zero.
You can manually increase or decrease the reference count of any object by calling
<PRE>addRefCP(objectPtr)</PRE>
<PRE>subRefCP(objectPtr)</PRE>
You have to increase the reference count via addRefCP first, before you delete the child of any node. Here is
the correct code 

\code
    NodePtr a = Node::create();
    NodePtr b = Node::create();
    NodePtr c = Node::create();
    // all reference counts of a,b and c are 0
    
    // we add "a" as a child to "b"
    beginEditCP(b);
        b->addChild(a);
        // "a" now has a reference count of 1,
        // because adding it as a child increases
        // the count by one
    endEditCP(b);
    
    //no, we want "a" to be a child of "c"
    beginEditCP(b);
        // first we increase the reference count
        addRefCP(a);
        // reference count of "a" is now 2
        // this removes "a" as a child of "b"
        b->subChild(a);
        // reference count is now 1 again
    endEditCP(b);
    
    //and now add it to "c"
    beginEditCP(c);
        c->addChild(a);
        // and the reference count is now 2
        
        // to avoid problems we decrease the count by hand
        subRefCP(a);
        // and now the count is 1 as it should be
    endeditCP(c);
\endcode

The usage of add- and subRefCP might seem a bit confusing at the beginning, but it really does make sense. By the way,
the operating system of macintosh systems, Mac OS X, is also using the smart pointer concept!

\section basicNodeNames Naming your nodes

When working with big scenes it can be very useful to name your nodes. For instance you could name your node which holds
the geometry for a car "car_geo". You will see that it will be much easier to search your graph for a node with a known
name. In Chapter [XXX] we will learn how to use modelling software like Studio Max in conjunction with OpenSG. At this point
I only want to mention that if you have named parts of your modell, you can search for these nodes by using exactly the same
names.

It is very easy to assign a name to you nodes. Here is an example

\code

// you will need this include file in order to work with named nodes
#include <OpenSG/OSGSimpleAttachments.h>

NodePtr n = Node::create();

// now we assign a name of our choice
setName(n, "Karl-Eberhard");

// if we want to extract the name later on...
if (getName(n))
    cout << "This node is called " << getName(n);
\endcode

It is very important to check if the result of getName is true. If you skip the if clause and use the result directly, your
program will crash if no name was set!

Later I will introduce a litlle helper class which searches a whole graph and returns the node matching a given name.

\subsection BasicNodeVolumes Volumes

Every node has an axis aligned bounding volume. That is the smallest possible box, which axis are parallel to the axis of the 
coordinate system, that contains all polygons. As you might know or guess theses bounding volumes are used to speed up several 
processes like casting a ray or checking if an object is within the frustum of the camera. If you want to know wether a ray hits 
an object with 20.000 polygons or not, you can fist test against it's bounding box  and if that box is not hit the object can not be
hit, saving you a lot of intersection tests. 

\image html bounding_box.png "The red object is enclosed by the bounding box"
\image latex bounding_box.eps "The red object is enclosed by the bounding box" width=6cm

Normally these bounding boxes are managed by OpenSG automatically. If you modify
geometry during runtime, the bounding box of the corressponding node will be marked as invalid. If and only if this node is used
for the next time it's bounding box will be updated automatically. If you need to mark a volume as invalid for some reason, you can 
do so by invoking the following on any node
<PRE>n->invalidateVolume()</PRE>
Note that these updates will walk the graph back up. If a bounding box of any node is recalculated so is the bounding box of the node's 
parent. That will be repeated until the root node is reached.

\section BasicCores Cores

Cores in OpenSG are one of the most important datatypes. I hope you got a feeling how to create and use nodes throughout the last sections,
but all we did so far was not really visible on screen except for the firsst complete tutorial. Anyway, rembember that we used
<PRE>NodePtr scene = makeTorus(.5, 2, 16, 16);</PRE>
to create the scenegraph. The makeTorus is a high level command which creates a node already connected with a geometry core containing the
data for the torus. If you want to fill your scene with live you will need to assign cores to every of your nodes.

IMPORTANT:\n
A node without a core should not be attached to your graph. If your scene is beeing rendered and an "empty" node is encountered, the rendering 
routine will break at this point. The next figure will show what I mean.

\image html empty_core_example.png "A graph with an empty node"
\image latex empty_core_example.eps "A graph with an empty node" width = 8cm

<I>
    The nodes in green color are geometry, whereas the red one indicates a node with a missing core. The numbers to the right are showing
    the order of traversal. The rendering traversal of the graph is depth-first, left-first (see Chapter[xxx]). The result in this situation 
    here is that the house will be correctly rendered, but the house, car and trees will be skipped. In this case you will get an error 
    message on your terminal like that: Recurse core is null, don't know what to do!
</I>

I will introduce all important cores in Chapter (xxx), but for now I want to present only two of them. 

\subsection BasicCoresGroup Group core

The first one is the simplest of all 
of them: the group core. A group core does nothing in special it just makes it possible to have a node and attach several children to it. You 
see, this is the solution to our empty node problem from above. Like every other class derived from Field Container, cores too, need to be
created via the static ::create() method of it's pointer class. This example demonstrate how you can create a node containing a group core

\code
NodePtr n = Node::create();
// the group core is created just like the nodes were
GroupPtr g = Group::create();

beginEditCP(n);
    n->setCore(g);
endEditCP(n);

\endcode

That's all! The "setCore()" method is used to assign a core to the node. As explained in \ref FirstAppTutorialScenegraphCompared these cores
can be referenced by as many nodes as you want to - and this is way it is called a scenegrah and not a scenetree ;)

The group core has no interesting methods as it does really nothing

\subsection basicCoresTransform Transform core

The other one is the transform core, which is most likely one of the most important. As you might expect this one is needed to move your geometry
around. Creation, of course, is just the same as ever, but you have some more methods to play with compared to the group core. Here is an example
how you can create a node containing a transformation, which will translate all its children by five units along the z-axis

\code
    NodePtr n = Node::create();
    TransformPtr t = Transform::create();
    
    Matrix m;
    m->setTranslation(Vec3f(0,0,5));
    
    // we want to modify our fresh transform object 
    // so we need to call begin-/ and endEditCP on it
    beginEditCP(t);
        t->setMatrix(m);
    endEditCP(t);
    
    beginEditCP(n);
        n->setCore(t);
    endEditCP(n);
\endcode

If you now add children to this node they all will be translated by this core. 

IMPORTANT:\n
I suppose that you expected it that way, but just to make sure you know: In OpenSG, like in most other scenegraph systems, all states are 
derived to all children only, but never are they passed to neighbours. 

\image html inheritance_example.png "A graph demonstratning the kind of inheritance"
\image latex inheritance_example.eps "A graph demonstarting the kind of inheritance" width = 6cm

<I>
    Here we have two different transformation nodes A and B. All states are inherited by children only, so the terrain has 
    transformation A assigned to it, where the house is transformed by B. The car and trees are not transformed at all, because
    there is no parent which has a transformation assigned to it.
</I>

Because we really need that kind of core to do anything other than boring, I have introduced the transform core here. A detailed discussed about
this and most other cores can be found at Chapter (xxx).

\section TutorialBasicTutorial Tutorial - it's moving!

Well, let's have a look what we can do know. In theory we know, how we can execute code on a frame by frame basis (via the display callback) and
we now can use transformation. That is wonderful, because by now we can realize our first animation! We already have a torus from the last 
tutorial (\ref FirstAppTutorial), so let us extend this one: The torus should turn around its own axis. Please use this tutorial as a starting
point. I you have not completed it yourself you can find it here: <A HREF="progs/01firstapp2.ccp">progs/01firstapp2.cpp</A>.

The first thing you have to do,is to add a global variable we will need for the animation

\code
// add this line below the declaration of the SimpleSceneManager
// or anywhere else where it will be global
TrannsformPtr transCore;
\endcode

This node will contain our transformation matrix, which will be altered every frame. Of course we do not need to make it global, but it is
the easiest way for now... and the most efficent too. There is another way down to the transform core: as we have an instance of the simple
scene manager, we have access to the root, from there we have access to all the root's children, in this case to the transform node. From the
node we can retrieve the core. If you are interested in "graph acrobatics" have a look at Chapter (xxx), otherwise we are fine with the global
variable ;)

Let us continue:\n
Now please, in the "main" function locate the lines that say
<PRE>
     // That will be our whole scene for now : an incredible Torus
    NodePtr scene = makeTorus(.5, 2, 16, 16);
</PRE> 

and replace them with the following code
\code
NodePtr scene;
        
// create all that stuff we will need:
//one geometry and one transform node
        
NodePtr torus = makeTorus(.5, 2, 16, 16);
NodePtr transNode = Node::create();
        
transCore = Transform::create();
Matrix m;
        
// now provide some data...
        
// no rotation at the beginning
m.setIdentity();
        
// set the core to the matrix we created
beginEditCP(transCore);
    transCore->setMatrix(m);
endEditCP(transCore);
        
// now "insert" the core into the node
beginEditCP(transNode);
    transNode->setCore(transCore);
    // add the torus as a child to
    // the transformation node
    transNode->addChild(torus);
endEditCP(transNode);
        
// "declare" the transformation as root
scene = transNode;  

\endcode

This piece of code will create a little scenegraph with a transformation as the root node and one child which is the torus geometry. If we now
modify the matrix of the transformation node we will actually modify the position and/or rotation as well as scalation of the torus. Just to 
make sure it works, I recommend to compile and execute the program. You should see the torus just like in the last tutorial. You also should
be able to move the camera by pressing and holding the left mouse button while moving the mouse around. Fine, we have more code but no more
features than in the old tutorial - so let's change this now!

Locate your display method - it should look like this

<PRE>
void display(void)
{
    mgr->redraw();
}
</PRE>

Insert the following code before the redraw method of the SSM is called

\code
Matrix m;
        
// get the time since the apllication startet
Real32 time = glutGet(GLUT_ELAPSED_TIME );
        
// set the rotation
m.setRotate(Quaternion(Vec3f(0,1,0), time/1000.f));
        
//apply the new matrix to our transform core
beginEditCP(transCore);
    transCore->setMatrix(m);
endEditCP(transCore);
\endcode

Now again, compile and run!

No difference? Nothing is moving? Try to move another window over your GLUT window and your torus will move. So what happend? The display callback
is only called if the window needs to be redrawn - that is the case, if it is overlapped by some other window. well, but that is not what we
actuall want, isn't it? We need the display method to be called as often as possible. That is very another callback comes into play: the idle 
callback.

Jump to the setupGLUT function where all the other callbacks are registered an add this one :

\code
glutIdleFunc(display);
\endcode

This tells GLUT, whenever there is nothing to do, the display function is called. Now compile and run again and watch your torus turning around. 
By the way, the order in which the callbacks are registered does not matter.

You can find the full code here : <A HREF = "progs/02movingTorus.cpp">progs/02movingTorus.cpp</A>

\section BasicFieldContainer Field Container

Now that we have seen how the very basic concepts of OpenSG works, it is time for some more background knowledge. In this section I will explain
the field container concept to you. Even if you do not care about how things are realized and how the actually work, you should read this section
as it is very essential to the way how OpenSG works. As I mentioned before, OpenSG was designed to handle multithreaded data in an easy way and
therefore makes also clustering very easy. The developers decided to create containers which are protected against simultaneous access from more
than one thread. With these field containers, the smart pointer were introduced as it was necessary to avoid working with standard pointer. Nearly
every OpenSG specific class related to data storage is derived from FieldContainer. If you want to convince yourself how often this class is 
derived, then have a look at osg::FieldContainer. As I mentioned before: <B>Every class that is derived from FieldContainer, needs to be 
created via the static ::create method! The return type is always <I>classname</I>Ptr</B>

There are some more interesting aspects about the field containers. All containers are reflective, that is they provide information about
themselfs like the classname or an unique id. Furthermore generic access methods exist which can be used with every field container. To be honest
there is indeed another method to create instances of field containers than create() : the "factory". 

\subsection BasicFieldContainer Fied Container Factory

The factory can be very useful in some special cases. With the factory at your hand it is possible to create objectes by using strings instead
of the static class method ::create(). Here are some examples

\code

//You know this
NodePtr n_usual = Node::create();

//This does the same thing in another way
FieldContainer n_factory = ContainerFactory::the().createContainer("Node");

//it works with every type derived from Field Container
FieldContainer g = Container::the().createContainer("Group");

\endcode

This comes in very usueful when writing a loader for example. If you would not have this possibility you had no choice but to write a huge
if-then-else cascade, where you catch every posible type. but unless you are doing exactly that you should stick to the "usual way".

Well, this is only to show you what is possible with the introduced concepts of field containers and smart pointer. I remember when I started
learninig OpenSG - I found these things not very comfortable and I did not understood what they are for. I would like you to see that all these
"unhandy" concepts were implemented for a good reason and they make life easier if you start using them!

\subsection BasicFieldContainerSingleMulti Single and Mutlifields

In OpenSG we have to different kinds of fields: single- and multifields. As the names are already telling, the singlefield stores a single value
whereas the mulifield is compareable to the STL vector (i.e. an array). 

Often ojects in OpenSG can return both, "usual" datatypes and the same in a single field container. Let us have a closer look at the window class.
In every tutorial we used a GLUTWindow to display our results. Of course this window has a defined height and width. This information can be
retrieved during runtime in two different ways:

\code
//our window as it was created in the tutorials
GLUTWindowPtr gwin = GLUTWindow::create();

// one way to get the width (height is analog to this)
UInt16 width_noFC = gwin->getWidth();

// or in a single field container
SFUInt16 width_sFC = gwin->getSFWidth();
\endcode

Maybe you still ask yourself what that is good for. Well, if you just want to print the screen size information on the screen, you will be
fine with the first one, but if you have a multithreaded application where this information is used by another thread, you have to make sure
that the data is handeled correctly - or you let OpenSG take care of it by using the second variant! 

Single field containers can be accessed easily with getValue() and setValue()

\code
//we print out the screen width
cout << "Screenwidth: " << width_sFC.getvalue();

//and we set it to another value
width_sFC.setValue(640);
\endcode

If you want to create an instance of a single field container you have to use the usual ::create() method. For every <I>Type</I> there is a 
corresponding single field type called SF<I>Type</I>. Here are some examples.
\code
SFInt16
SFReal64
SFNodePtr
\endcode

Multifield are 1D arrays and are very similar to standard STL vectors. The usual operations like begin(), end() and push_back() all work, as well
as the access via the bracket operator []. Iterators work just like you are used to it.  Multifields are used to store the vertices of geometry 
or the viewports attached to a window and for many other things. Here is an example when multifields can be used (Viewports are explained in
Chapter (xxx))

\code
//lets imagine we have a window "gwin" with four viewports

//you can get one specific viewport by using the [] operator
ViewportPtr vport = gwin->getPorts()[0];

// or you get all of them at once
MFViewportPtr vports = gwin->getports();

//now you can get the first viewport this way
vport = vports[0];
\endcode

Like with the single field containers the multi field containers have the same naming convention MF<I>type</I>. Here is another example showing
how you can work with multifields

\code
// we are going to create some vectors 
// and print them afterwards 
        
v = MFVec3f();
        
for (int i = 0; i < 10; i++)
    v.push_back(Vec3f(i,i*2,i*3));
         
MFVec3f::iterator it;
for (it = v.begin(); it < v.end();){
    cout << (*it)[0] <<" "<< (*it)[1]<<" "<<(*it)[2]<<endl;
    it++;
}
\endcode
*/
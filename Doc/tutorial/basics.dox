#include <OpenSG/OSGConfig.h>

using namespace OSG;

/*! 

\page TutorialBasics Basics
\latexonly Starter:NewChapter \endlatexonly

Chapter Overview
<HR>
    \ref Datatypes<br>
    \ref BasicMath<br>
    \ref BasicColor<br>
    \ref BasicNode<br>
    \ref basicNodeNames<br>
    \ref BasicCores<br>
    \ref TutorialBasicTutorial<br>
    \ref BasicFieldContainer<br>
    \ref TutorialBasicEditingFieldContainers<br>
    \ref TutorialBasicTutorial2<br>
    \ref TutorialBasicImages<br>
    \ref TutorialBasicTutorial3<br>
    \ref TutorialBasicLoadingSaving<br>
    \ref TutorialBasicTutorial4<br>
    \ref TutorialBasicExercises<br>
<HR>

If you have read this online tutorial right from the beginning, you are able to install OpenSG, you know a few things about GLUT as well as the 
Simple Scene Manager and you have compiled and executed your first program. Well that is good, but you need to know a bit more
before you write your first real application. In this chapter I will show you the basic things of OpenSG, that is: 
<UL>
    <LI>math using OpenSG classes</LI>
    <LI>creating new nodes and cores</LI>
    <LI>Fieldcontainer</LI>
    <LI>Images</LI>
    <LI>Loading and saving</LI>
</UL>

\section Datatypes Datatypes

OpenSG has it's own base types for integers and floats. In many cases you can get along by using int, float etc. as you normally
would, but if you want to develop a cross platform application it might be safer to use the OpenSG wrapper base types. 

These types can be easily identified by their names
<TABLE>
  <TR>
    <TD>[U]Int<I>N</I></TD><TD><I>N</I> defines how many bits to use.8, 16, 32 or 64 is allowed. The optinal U stands for unsigned </TD>
  </TR>
  <TR>  
    <TD>Real32, Real64, Real128</TD><TD>Floating point with either 32, 64 or 128 bytes</TD>
  </TR>
</TABLE>

An unsigned 32 bit integer is therefore <I>UInt32</I>. The reason for using these wrapper is, that the usual "int" variable is 32 bits
long for most systems... but not for every system. By using Int32 you do not have to care, you can be sure that this type is always
that long.

\section BasicMath The Math Stuff

OpenSG comes together with it's own classes for calculating with Vectores, Matrices etc. We all know that there are approximately a 
thousand other math libraries which are more or less equal powerful. If you are in need of lots of mathematical computations and high
performance is very critical to you have not to use the internal classes of OpenSG, but for every other purpose you should do so as 
all methods of OpenSG are working with their own types of course.

As you might expect we have types for all you need related to computer graphics: Vectors with different precision and with two up
to four components, as well as the same for matrices.

There are 21 different vector type which I will not list individually, but the construction rules are similar to the base types.

<PRE>Vec<I>N</I>{b, ub, s, us, f, d, ld}</PRE>

<I>N</I> again is the dimension which must be chosen between two and four. From the list of letters you also must choose one, which 
defines the type used for storing the values.

<UL>
<LI>
    b is Int8
</LI>
<LI>
    ub is UInt8
</LI>
<LI>
    s is Int16
</LI>
<LI>
    us is UInt16
</LI>
<LI>
    f is Real32
</LI>
<LI>
    d is Real64
</LI>
<LI>
    ld is Real128
</LI>
</UL>

The one you need in most circumstances is most likely to be Vec3f, a three dimensional vector with float values.

\subsection BasicMathWorkinfWithVectors Working with vectors

The OpenSG vector classes can do verything you expect from them and probably even more ;-). Here is an overview of the most important
operations. Have a look at osg::Vec3f (or any other vector) for a full list of their methods

\code
// two nice 3d vectors
Vec3f v = Vec3f(1,2,3);
Vec3f w = Vec3f(0.5,2.5,5);

// get the length of a vector 
Real32 l = v.length();
// float or double is possible, too
float l = v.length();

// if you only want to figure out which vector is longer you do not
// need the exact euclidian length. (You can spare the square root)
Real32 lq = v.squareLength();

// normalize a vector (length will become 1)
v.normalize();

// the cross product of two vectors
Vec3f e = v.cross(w);
// ATTENTION: cross product is only implemented for 3 dimensional vectors

// dot product
Real32 d = v.dot(w);

// access to individual components
Real32 c1 = v[0];
Real32 c2 = v[1];
Real32 c3 = v[2];

// you can use mathematical operations the same way as with integers and floats

Vec3f s = v+w;

if (v==w)
    cout << "these vectors are equal" << endl;

 
\endcode

\subsection Basicpoints Points

Points are quite similar to vectors. They come in all the same variants like them, only replace "Vec"
by "Pnt" and you have it. The difference compared to vectors is that Points mark a definite location
within the spacial domain, where vectors are not bound to a specific point as they represent a 
direction or power (you remember ;-)...)

Let us say points are vectors with some fewer possibilities. Of course points cannot be normalized and
there is no dor product between to points. Please notice that two Points can be added neither! If you
need to convert between vectors and points, there are two useful methods to do that

\code

// conversion point to vector (let p be some point and v some vector)
v = p.subZero

//or vice versa
p = v.addToZero();

\endcode

\subsection BasicColor Colors

Colors, too, are similar to vectors. They are available in three or four dimensions, where the fouth
dimension represents the alpha channel, whereas the first the are RGB color channels. The color
classes support also the HSV color modell. They have named access methods (red, green and blue)
with which you can access the values in a more reasonable way than with color[1]. Furthermore
scalar multiplication is possible but most other operations known from vectors are missing as they
are not needed.

Detailed information about the methods for colors can be found at osg::Color3f

\subsection BasicMathWorkWithMarices Working with matrices

Matrices behave quite similar to vectors. As there is no default type for vectors, there is one
for matrices: Like in OpenGL it is 4x4 with Real32 components. The multiplication convention is 
just the same as in OpenGL:
<PRE>v'=M*v</PRE>

In OpenSG matrices are stored column major like shown in the next picture

\image html matrix_storage.png "Storage of a matrix in memory"
\image latex matrix_storage.eps "Storage of a matrix in memory" width=8cm

The first column vector can be retrieved with a simple matrix[0]. Storing the values in this manner 
has a little advantage compared to row major storage as you can easy access the matrix coordiante
space, especially matrix[3] deliver you automatically the translation from the origin.

There are several ways to construct a matrix that matches your needs. It is possible to create a 
matrix by providing all components one by one or by passing the base vectors or you can use
some methods of the matrix class to create a matrix with certain properties.

\code

// we want to create a matrix that scales the world at the y axis by factor 2 and also translates
// by (2,2,3). As we all know from old days in school the corresponding matrix is 

// | 1 0 0 2 |
// | 0 2 0 2 |
// | 0 0 1 3 |
// | 0 0 0 1 |

// first we create the matrix by passing all values directly

Matrix m;

m = Matrix(1,0,0,2,0,2,0,2,0,0,1,3,0,0,0,1);
// ATTENTION : noticed something? The arguments are passed row major! This applies to
// this specific constructor only!

// if we had base vectors like this...
Vec4f v1 = (1,0,0,0);
Vec4f v2 = (0,2,0,0);
Vec4f v3 = (0,0,1,0);
Vec4f v4 = (2,2,3,1);

// ... we can also make our matrix by ...

m = Matrix (v1,v2,v3,v4);
// of course column major, as expected

// But really practical are these variants

// this one resets the matrix to identity
m.setIdentity();

// we set the scale factor
m.setScale(1,2,1);
// and the translation
m.setTranslate(2,2,3);

// ... and here we go

// now we want to multiply a matrix and a vector

Vec3f a = Vec3f(1,2,3);
Vec3f result;

m.mult(a, result);

// ATTENTION: remember matrix multiplication when you did it manually? We are 
// multiplying a 4x4 matrix with a 3x1 vector. Actually that should not work... 
// but in OpenSG it does, not because of a false implementation, but with 
// respect to the fact that the fourth row is rarely used as it is (0,0,0,1)
// in most cases. This is why OpenSG assumes that you actually multiply a 4x3 
// matrix with a 3x1 vector... and that is ok!

// as you might have guessed the result of the mutiplication is assigned to the 
// vector "result"

// multiplication of two matrices work in exactly the same way

\endcode

Please notice the following, when using the setter methods for matrices. These methods overwrite
only the components they need to, leaving all others untouched, i.e if you have a matrix and want
to change the translation you have to be sure that the other values are correct, too. The method
setIdentity overwrite all values of course!

Have a look at osg::Matrix for a complete list of all setter methods available.

\subsection BasicQuaternion Quaternions

The last topic for this OpenSG-math-quick-tour are quaternions. The background of quaternions is quite
not simple to understand, but do not worry, you can use them without knowing how they work - I can
stand proof for that ;)

So what are quaternions about? You might know that interpolating between rotation matrices does not
work that well. That is if you have a matrix describing a 30 degree rotation around the y axis and 
another matrix doing the same with 60 degree you just cannot interpolate between these to for an 
animation. 

Quaternions are an execellent solution to this problem. They are described by an angle and a vector.
The angle is the amount that you want to rotate around the vector you provided. As you might expect 
know it is possible to interpolate between two quaternions and as these can be easily transformed 
into a matrix we now can realize custom rotations around any axis. The following example solves 
the situation described above

\code

// well this is a bit theroetical... we will have more real-world examples 
// within the next tutorial

// we need a quaternion and a matrix
Quaternion q;
Matrix m;

// reset our matrix
m.setIdentity();

for (int t = 0; t < 30; t++){
    // the given angle is in radians per default
    q = Quaternion(Vec3f(0,1,0), (30+t/180)*PI );
    m.setRotation(q);
    
    // draw the scene here ... 
}

\endcode

If you do not like radians you can also use degree by invoking 
<PRE>q.setValueAsAxisDeg(Vec3f(...), 90)</PRE>

Furthermore standard operations like length(), normalize(), inverse(), multiplication, slerp and
others are possible. Detailed information are here : osg::Quaternion

\section BasicNode Nodes

Nodes are in some way the most important object in a scenegraph. In OpenSG the nodes descibe the 
hierarchy of the graph only! Here is a simple graph we want to build:

\image html simple_graph.png "The family scenegraph"
\image latex simple_graph.eps "The familiy scenegraph" width=4cm

\code

//First, we create all the nodes we need
osg::NodePtr grandpa = osg::Node::create();
osg::NodePtr aunt = osg::Node::create();
osg::NodePtr mother = osg::Node::create();
osg::NodePtr me = osg::Node::create();

// uh, what is happening here???
// I guess you expected somthing like
// Node n = Node();
// do not worry, explanation will follow hereafter...

// now we create the hierarchy
beginEditCP(grandpa);
    grandpa->addChild(aunt);
    grandpa->addChild(mother);
endEditCP(root);

beginEditCP(mother);
    mother->addChild(me);
endEditCP(mother);

// beginEditCP()??? That, too, will be discussed in Detail later

\endcode

Please do not wonder about that strange begin- and endEditCP thing. Let us say for now, that we need
these whenever we want to modify an OpenSG object. We will learn more about it in section \ref TutorialBasicEditingFieldContainers.
But for now we will be fine with the way it is.

This little piece of code would generate a graph that would look like in the picture above. 
Would you be able to render that graph? You can try out what will happen: Have a look at the 
code from our \ref FirstAppTutorial and replace the following line

\code
    NodePtr scene = makeTorus(.5, 2, 16, 16);
\endcode

with the example code from above. But be carful, with grandpa it will not work, you have to rename him
to "scene", because the Simple Scene Manager is told to use scene as root.

And? Did it work? We will come back later to this little example.

\subsection BasicNodeCreate Creating new nodes and other objects with ::create()

You might wonder why objects are instantiated this unsual way. Actually the "normal" way will not work
for most OpenSG objects.
In fact calling
<PRE> Node n = Node() </PRE>
will get you an error during compiling like this one
<PRE> osg::Node::Node() is protected within this context </PRE>
Well, that is looking bad. What to do, if the constructor is obviously not public thus it cannot be called.
I remember still when I faced this probem, looking like a cow at the screen... 

Actually every class that is derived from FieldContainer has protected constructors whereas other classes, 
like the math classes we just saw, have their constructors declared public as usual. So if you are unsure 
wether you can use the constructor as usual, just have a look at the inheritance diagramm and if none of
the parents is of type FieldContainer then it will work.

If that is not the case, you must invoke the static create() method as you saw above. This static method
wrapps the constructor. It is done this way to ensure multithread safty, but we will discuss that in
an own chapter.

\subsection BasicNodePtr Smart Pointer

Alright, we now understand when we have to use create, but another strange things is the fact, that the
variable which represents a node is not of type "Node", but "NodePtr". take it as a rule of thumb:
For every <I>object</I> created with ::create() the returning type is a corresponding <I>objectPtr</I>.

Here are some examples
\code
NodePtr n = Node::create();
TransformPtr t = Transform::create();
GeometryPtr geo = Geometry::create()
ShearedStereoCameraDecoratorPtr sscd = ShearedStereoCameraDecorator::create();
\endcode

I think you get the picture. These Ptr classes are smart pointer. That means if you pass them around to
other methods you copy only a pointer (i.e a pointerclass) and not the actual object. This is very 
important to know. Let us imagine you have a GeometryPtr which points to model of a tree which is as large
as 5 MB. It actually does make a big difference if you pass the whole 5 MB or just the tiny pointer 
to another method. As I assume that you are familiar with the concept of pointers you might say, that this
is not very special as that is what a pointer does. The smart thing with these pointers from OpenSG is, 
that they are multithread safe and that you don not need to manually delete them in most cases as these
are reference counted. If you create an object it has an reference count of zero. Some operations like adding
it as a child to another node increses the reference count by one, whereas others decrease it by one 
(this is for example deleting a child). Whenever the reference count goes down to zero the object is deleted
auomatically. This is very nice to work with, but there are also some aspects to look after.

This little example demonstrates what can go wrong with smart pointers

\code
    Node a = Node::create();
    Node b = Node::create();
    Node c = Node::create();
    
    // we add "a" as a child to "b"
    beginEditCP(b);
        b->addChild(a);
    endEditCP(b);
    
    //no, we want "a" to be a child of "c"
    beginEditCP(b);
        // this removes "a" as a child of "b"
        b->subChild(a);
    endEditCP(b);
    
    //and now add it to "c"
    beginEditCP(c);
        c->addChild(a);
    endeditCP(c);
\endcode

Well, looks good, does it not? Actually your compiler will take it as it is correct in it's syntax, but if
you run an application with this piece of code it will crash! If you do not not why you should think 
about it before reading ahead...

Okay, no big deal? The explanation stands right above the code... when we call subChild on a the reference
count is reduced from one to zero and is then immediatly deleted from memory. When we want add a to c we 
are operating on a non existent object - and that is never good.

So if you want to change parents of a node you need to make sure that it's reference count stays above zero.
You can manually increase or decrease the reference count of any object by calling
<PRE>addRefCP(objectPtr)</PRE>
<PRE>subRefCP(objectPtr)</PRE>
You have to increase the reference count via addRefCP first, before you delete the child of any node. Here is
the correct code 

\code
    NodePtr a = Node::create();
    NodePtr b = Node::create();
    NodePtr c = Node::create();
    // all reference counts of a,b and c are 0
    
    // we add "a" as a child to "b"
    beginEditCP(b);
        b->addChild(a);
        // "a" now has a reference count of 1,
        // because adding it as a child increases
        // the count by one
    endEditCP(b);
    
    //no, we want "a" to be a child of "c"
    beginEditCP(b);
        // first we increase the reference count
        addRefCP(a);
        // reference count of "a" is now 2
        // this removes "a" as a child of "b"
        b->subChild(a);
        // reference count is now 1 again
    endEditCP(b);
    
    //and now add it to "c"
    beginEditCP(c);
        c->addChild(a);
        // and the reference count is now 2
        
        // to avoid problems we decrease the count by hand
        subRefCP(a);
        // and now the count is 1 as it should be
    endeditCP(c);
\endcode

The usage of add- and subRefCP might seem a bit confusing at the beginning, but it really does make sense. By the way,
the operating system of macintosh systems, Mac OS X, is also using the smart pointer concept!

\section basicNodeNames Naming your nodes

When working with big scenes it can be very useful to name your nodes. For instance you could name your node which holds
the geometry for a car "car_geo". You will see that it will be much easier to search your graph for a node with a known
name. In Chapter [XXX] we will learn how to use modelling software like Studio Max in conjunction with OpenSG. At this point
I only want to mention that if you have named parts of your modell, you can search for these nodes by using exactly the same
names.

It is very easy to assign a name to you nodes. Here is an example

\code

// you will need this include file in order to work with named nodes
#include <OpenSG/OSGSimpleAttachments.h>

NodePtr n = Node::create();

// now we assign a name of our choice
setName(n, "Karl-Eberhard");

// if we want to extract the name later on...
if (getName(n))
    cout << "This node is called " << getName(n);
\endcode

It is very important to check if the result of getName is true. If you skip the if clause and use the result directly, your
program will crash if no name was set!

Later I will introduce a litlle helper class which searches a whole graph and returns the node matching a given name.

\subsection BasicNodeVolumes Volumes

Every node has an axis aligned bounding volume. That is the smallest possible box, which axis are parallel to the axis of the 
coordinate system, that contains all polygons. As you might know or guess theses bounding volumes are used to speed up several 
processes like casting a ray or checking if an object is within the frustum of the camera. If you want to know wether a ray hits 
an object with 20.000 polygons or not, you can fist test against it's bounding box  and if that box is not hit the object can not be
hit, saving you a lot of intersection tests. 

\image html bounding_box.png "The red object is enclosed by the bounding box"
\image latex bounding_box.eps "The red object is enclosed by the bounding box" width=6cm

Normally these bounding boxes are managed by OpenSG automatically. If you modify
geometry during runtime, the bounding box of the corressponding node will be marked as invalid. If and only if this node is used
for the next time it's bounding box will be updated automatically. If you need to mark a volume as invalid for some reason, you can 
do so by invoking the following on any node
<PRE>n->invalidateVolume()</PRE>
Note that these updates will walk the graph back up. If a bounding box of any node is recalculated so is the bounding box of the node's 
parent. That will be repeated until the root node is reached.

\section BasicCores Cores

Cores in OpenSG are one of the most important datatypes. I hope you got a feeling how to create and use nodes throughout the last sections,
but all we did so far was not really visible on screen except for the firsst complete tutorial. Anyway, rembember that we used
<PRE>NodePtr scene = makeTorus(.5, 2, 16, 16);</PRE>
to create the scenegraph. The makeTorus is a high level command which creates a node already connected with a geometry core containing the
data for the torus. If you want to fill your scene with live you will need to assign cores to every of your nodes.

IMPORTANT:\n
A node without a core should not be attached to your graph. If your scene is beeing rendered and an "empty" node is encountered, the rendering 
routine will break at this point. The next figure will show what I mean.

\image html empty_core_example.png "A graph with an empty node"
\image latex empty_core_example.eps "A graph with an empty node" width = 8cm

<I>
    The nodes in green color are geometry, whereas the red one indicates a node with a missing core. The numbers to the right are showing
    the order of traversal. The rendering traversal of the graph is depth-first, left-first (see Chapter[xxx]). The result in this situation 
    here is that the house will be correctly rendered, but the house, car and trees will be skipped. In this case you will get an error 
    message on your terminal like that: Recurse core is null, don't know what to do!
</I>

All important cores will be introduced in the next chapter (\ref NodeCores). However as real time graphics without any movement are quite 
boring, I will introduce the transformation and group core briefly already here.

\subsection TutorialBasicCoresGroup Group core

The first one is the simplest of all 
of them: the group core. A group core does nothing in special it just makes it possible to have a node and attach several children to it. You 
see, this is the solution to our empty node problem from above. Like every other class derived from Field Container, cores too, need to be
created via the static ::create() method of it's pointer class. This example demonstrate how you can create a node containing a group core

\code
NodePtr n = Node::create();
// the group core is created just like the nodes were
GroupPtr g = Group::create();

beginEditCP(n);
    n->setCore(g);
endEditCP(n);

\endcode

That's all! The "setCore()" method is used to assign a core to the node. As explained in \ref FirstAppTutorialScenegraphCompared these cores
can be referenced by as many nodes as you want to - and this is way it is called a scenegrah and not a scenetree ;)

The group core has no interesting methods as it does really nothing

\subsection TutorialBasicCoresTransform Transform core

The other one is the transform core, which is most likely one of the most important. As you might expect this one is needed to move your geometry
around. Creation, of course, is just the same as ever, but you have some more methods to play with compared to the group core. Here is an example
how you can create a node containing a transformation, which will translate all its children by five units along the z-axis

\code
    NodePtr n = Node::create();
    TransformPtr t = Transform::create();
    
    Matrix m;
    m->setTranslate(Vec3f(0,0,5));
    
    // we want to modify our fresh transform object 
    // so we need to call begin-/ and endEditCP on it
    beginEditCP(t);
        t->setMatrix(m);
    endEditCP(t);
    
    beginEditCP(n);
        n->setCore(t);
    endEditCP(n);
\endcode

If you now add children to this node they all will be translated by this core. 

IMPORTANT:\n
I suppose that you expected it that way, but just to make sure you know: In OpenSG, like in most other scenegraph systems, all states are 
derived to all children only, but never are they passed to neighbours. 

\image html inheritance_example.png "A graph demonstratning the kind of inheritance"
\image latex inheritance_example.eps "A graph demonstarting the kind of inheritance" width = 6cm

<I>
    Here we have two different transformation nodes A and B. All states are inherited by children only, so the terrain has 
    transformation A assigned to it, where the house is transformed by B. The car and trees are not transformed at all, because
    there is no parent which has a transformation assigned to it.
</I>

Because we really need that kind of core to do anything other than boring, I have introduced the transform core here. A detailed discussed about
this and most other cores can be found in the next Chapter (\ref NodeCores).

\section TutorialBasicTutorial Tutorial - it's moving!

Well, let's have a look what we can do know. In theory we know, how we can execute code on a frame by frame basis (via the display callback) and
we now can use transformation. That is wonderful, because by now we can realize our first animation! We already have a torus from the last 
tutorial (\ref FirstAppTutorial), so let us extend this one: The torus should turn around its own axis. Please use this tutorial as a starting
point. I you have not completed it yourself you can find it here: <A HREF="progs/01firstapp2.ccp">progs/01firstapp2.cpp</A>.

The first thing you have to do,is to add a global variable we will need for the animation

\code
// add this line below the declaration of the SimpleSceneManager
// or anywhere else where it will be global
TransformPtr transCore;
\endcode

This node will contain our transformation matrix, which will be altered every frame. Of course we do not need to make it global, but it is
the easiest way for now... and the most efficent too. There is another way down to the transform core: as we have an instance of the simple
scene manager, we have access to the root, from there we have access to all the root's children, in this case to the transform node. From the
node we can retrieve the core. If you are interested in "graph acrobatics" have a look at Chapter (xxx), otherwise we are fine with the global
variable ;)

Let us continue:\n
Now please, in the "main" function locate the lines that say
<PRE>
     // That will be our whole scene for now : an incredible Torus
    NodePtr scene = makeTorus(.5, 2, 16, 16);
</PRE> 

and replace them with the following code
\code
NodePtr scene;
        
// create all that stuff we will need:
//one geometry and one transform node
        
NodePtr torus = makeTorus(.5, 2, 16, 16);
NodePtr transNode = Node::create();
        
transCore = Transform::create();
Matrix m;
        
// now provide some data...
        
// no rotation at the beginning
m.setIdentity();
        
// set the core to the matrix we created
beginEditCP(transCore);
    transCore->setMatrix(m);
endEditCP(transCore);
        
// now "insert" the core into the node
beginEditCP(transNode);
    transNode->setCore(transCore);
    // add the torus as a child to
    // the transformation node
    transNode->addChild(torus);
endEditCP(transNode);
        
// "declare" the transformation as root
scene = transNode;  

\endcode

This piece of code will create a little scenegraph with a transformation as the root node and one child which is the torus geometry. If we now
modify the matrix of the transformation node we will actually modify the position and/or rotation as well as scalation of the torus. Just to 
make sure it works, I recommend to compile and execute the program. You should see the torus just like in the last tutorial. You also should
be able to move the camera by pressing and holding the left mouse button while moving the mouse around. Fine, we have more code but no more
features than in the old tutorial - so let's change this now!

Locate your display method - it should look like this

<PRE>
void display(void)
{
    mgr->redraw();
}
</PRE>

Insert the following code before the redraw method of the SSM is called

\code
Matrix m;
        
// get the time since the apllication startet
Real32 time = glutGet(GLUT_ELAPSED_TIME );
        
// set the rotation
m.setRotate(Quaternion(Vec3f(0,1,0), time/1000.f));
        
//apply the new matrix to our transform core
beginEditCP(transCore);
    transCore->setMatrix(m);
endEditCP(transCore);
\endcode

Now again, compile and run!

No difference? Nothing is moving? Try to move another window over your GLUT window and your torus will move. So what happend? The display callback
is only called if the window needs to be redrawn - that is the case, if it is overlapped by some other window. well, but that is not what we
actuall want, isn't it? We need the display method to be called as often as possible. That is very another callback comes into play: the idle 
callback.

Jump to the setupGLUT function where all the other callbacks are registered an add this one :

\code
glutIdleFunc(display);
\endcode

This tells GLUT, whenever there is nothing to do, the display function is called. Now compile and run again and watch your torus turning around. 
By the way, the order in which the callbacks are registered does not matter.

You can find the full code here : <A HREF = "progs/02movingTorus.cpp">progs/02movingTorus.cpp</A>

\section BasicFieldContainer Field Container

Now that we have seen how the very basic concepts of OpenSG works, it is time for some more background knowledge. In this section I will explain
the field container concept to you. Even if you do not care about how things are realized and how the actually work, you should read this section
as it is very essential to the way how OpenSG works. As I mentioned before, OpenSG was designed to handle multithreaded data in an easy way and
thereforee makes also clustering very easy. The developers decided to create containers which are protected against simultaneous access from more
than one thread. With these field containers, the smart pointer were introduced as it was necessary to avoid working with standard pointer. Nearly
every OpenSG specific class related to data storage is derived from FieldContainer. If you want to convince yourself how often this class is 
derived, then have a look at osg::FieldContainer. As I mentioned before: <B>Every class that is derived from FieldContainer, needs to be 
created via the static ::create method! The return type is always <I>classname</I>Ptr</B>

There are some more interesting aspects about the field containers. All containers are reflective, that is they provide information about
themselfs like the classname or an unique id. Furthermore generic access methods exist which can be used with every field container. To be honest
there is indeed another method to create instances of field containers than create() : the "factory". 

\subsection BasicFieldContainer Fied Container Factory

The factory can be very useful in some special cases. With the factory at your hand it is possible to create objectes by using strings instead
of the static class method ::create(). Here are some examples

\code

//You know this
NodePtr n_usual = Node::create();

//This does the same thing in another way
FieldContainer n_factory = ContainerFactory::the().createContainer("Node");

//it works with every type derived from Field Container
FieldContainer g = Container::the().createContainer("Group");

\endcode

This comes in very usueful when writing a loader for example. If you would not have this possibility you had no choice but to write a huge
if-then-else cascade, where you catch every posible type. but unless you are doing exactly that you should stick to the "usual way".

Well, this is only to show you what is possible with the introduced concepts of field containers and smart pointer. I remember when I started
learninig OpenSG - I found these things not very comfortable and I did not understood what they are for. I would like you to see that all these
"unhandy" concepts were implemented for a good reason and they make life easier if you start using them!

\subsection BasicFieldContainerSingleMulti Single and Mutlifields

In OpenSG we have to different kinds of fields: single- and multifields. As the names are already telling, the singlefield stores a single value
whereas the mulifield is compareable to the STL vector (i.e. an array). 

Often ojects in OpenSG can return both, "usual" datatypes and the same in a single field container. Let us have a closer look at the window class.
In every tutorial we used a GLUTWindow to display our results. Of course this window has a defined height and width. This information can be
retrieved during runtime in two different ways:

\code
//our window as it was created in the tutorials
GLUTWindowPtr gwin = GLUTWindow::create();

// one way to get the width (height is analog to this)
UInt16 width_noFC = gwin->getWidth();

// or in a single field container
SFUInt16 width_sFC = gwin->getSFWidth();
\endcode

Maybe you still ask yourself what that is good for. Well, if you just want to print the screen size information on the screen, you will be
fine with the first one, but if you have a multithreaded application where this information is used by another thread, you have to make sure
that the data is handeled correctly - or you let OpenSG take care of it by using the second variant! 

Single field containers can be accessed easily with getValue() and setValue()

\code
//we print out the screen width
cout << "Screenwidth: " << width_sFC.getvalue();

//and we set it to another value
width_sFC.setValue(640);
\endcode

If you want to create an instance of a single field container you have to use the usual ::create() method. For every <I>Type</I> there is a 
corresponding single field type called SF<I>Type</I>. Here are some examples.
\code
SFInt16
SFReal64
SFNodePtr
\endcode

Multifield are 1D arrays and are very similar to standard STL vectors. The usual operations like begin(), end() and push_back() all work, as well
as the access via the bracket operator []. Iterators work just like you are used to it.  Multifields are used to store the vertices of geometry 
or the viewports attached to a window and for many other things. Here is an example when multifields can be used (Viewports are explained in
Chapter (xxx))

\code
//lets imagine we have a window "gwin" with four viewports

//you can get one specific viewport by using the [] operator
ViewportPtr vport = gwin->getPorts()[0];

// or you get all of them at once
MFViewportPtr vports = gwin->getports();

//now you can get the first viewport this way
vport = vports[0];
\endcode

Like with the single field containers the multi field containers have the same naming convention MF<I>type</I>. Here is another example showing
how you can work with multifields

\code
// we are going to create some vectors 
// and print them afterwards 
        
v = MFVec3f();
        
for (int i = 0; i < 10; i++)
    v.push_back(Vec3f(i,i*2,i*3));
         
MFVec3f::iterator it;
for (it = v.begin(); it < v.end();){
    cout << (*it)[0] <<" "<< (*it)[1]<<" "<<(*it)[2]<<endl;
    it++;
}
\endcode

The standard access methods setValue and getValue are also available with multifields, you need only to supply an additional index.
<PRE>myfield->setValue(Vec3f(0,1,0),3)</PRE>
The line above would set the given Vector at the 4th position of the field (of course we are starting to count at zero)

\section TutorialBasicEditingFieldContainers Editing Field Containers

Now it is time to solve another mystery you have encountered until now: the "begin- /endEditCP() Mystery". As I mentioned before at the 
beginning of this chapter, we need these begin- endEditCP brackets every time we want to modify an OpenSG specific object. That is a from
FieldContainer derived object, to be exact - that is what the CP stands for: ContainerPointer (at least the author thinks so).

Alright, so as we saw before we need to start with a beginEditCP(<I>object</I>), where object is the one we want to edit, of course. Then
one or more modifications should follow and finally we are ending up with beginEditCP(<I>object</I>). Here is another example how to do it right:

\code
NodePtr n = Node::create();

beginEditCP(n);
{
    GroupPtr g = Group::create();
    NodePtr c1 = Node::create();
    NodePtr c2 = Node::create();
    
    GeometryPtr g1 = generateSomeGeometry();
    GeometyrPtr g2 = generateSomeOtherGeometry();
    
    beginEditCP(c1);
    beginEditCP(c2);
        c1->setCore(g1);
        c2->setCore(g2);
    endEditCP(c2);
    endEditCP(c1);
    
    n->setCore(g);
    n->addChild(c1);
    n->addChild(c2);
}
endEditCP(n);
\endcode

Noticed something? I did some things different than before. Your begin/end block can span more lines of code than these that actually modify
the object and these blocks must not be seperate. As you can see I have two blocks (editing c1 & c2) "overlapping" while these are inside the
block which modifies n. The additional {}-brackets are used for optical orientation only, they are not neccessary, but they can be extremly
useful if you have more complex graphs.

Maybe you wonder, what they are for anyway. Well and again it is multithread safety... by using begin- and endEditCP you tell the system
when something is going to be changed. Normally every thread would need a full copy of the data, but that would result in very high memory
consumption, so in OpenSG much of the data is shared. The multifields I just introduced are shared for example. Only when data is changed
it will be copied to the current thread. The changes are recorded in a change list which will be used to syncronize the threads again at a
given time. Have a look at Chapter (xxx) for more details about multithreading. This is roughly why the system needs to be informed when
something is going to be changed.

So what happens, if you forget a begin- endEditCP block? If you are running a single threaded application on a single machine it will work in
most cases, but you should not treat this as an excuse to leave them all out. I said in most cases, but you have no garantee that it will
work at all as this is not the way OpenSg is meant to be used! I know that it is sometimes a bit annonying to write half a mile of code, but
please make the editCPs your friends ;-) You will be rewarded whenever you want to drive your application with multiple threads and/or in stero.

But even more important: what happens if you skip the editCP blocks if you are using mutiple threads or are running a cluster? Depending on
how violently you skipped the editCP blocks, your modifications will occur in one thread only and that is most likely not what you want. No matter
what actually happens to your data, you have a good chance crashing your application. So if you are using multiple threads you have to pay
special attaention to your editCP blocks! If you applications are crashing for some strange reason you should first check if you have missed such
a block. 

\subsection TutorialBasicEditFieldContainersParameters Extended begin- endEditCP

By invoking beginEditCP(object) you tell the system that you want to change everything. You can specify explicitly which attributes you want
to modify. This will save some computing power, altough it is often not necessary when initializing the graph. In performance critical sections
this will be much more important. For example, lets say we have a geometry node representing water, which we need to update every frame. I need
to update the positions and maybe the nomals too, but color, texture coordinates and other geometry attributes stay untouched. Now wether to
define the changing attributes or not can make a speed difference of up to 10% in this case!

Here is the same example from above, but this time with correct specification of the changing attributes

\code
NodePtr n = Node::create();

beginEditCP(n, Node::ChildrenFieldMask | Node::CoreFieldMask);
{
    GroupPtr g = Group::create();
    NodePtr c1 = Node::create();
    NodePtr c2 = Node::create();
    
    GeometryPtr g1 = generateSomeGeometry();
    GeometyrPtr g2 = generateSomeOtherGeometry();
    
    beginEditCP(c1, Node::CoreFieldMask);
    beginEditCP(c2, Node::CoreFieldMask);
        c1->setCore(g1);
        c2->setCore(g2);
    endEditCP(c2, Node::CoreFieldMask);
    endEditCP(c1, Node::CoreFieldMask);
    
    n->setCore(g);
    n->addChild(c1);
    n->addChild(c2);
}
endEditCP(n, Node::ChildrenFieldMask | Node::CoreFieldMask);
\endcode

NOTICE:\n
If you want to modify more then one field at once you can use the binary or operator ( "|" ) to join the field masks.

With that the code becomes even a bit longer, but that should not scare you to use it in performance critical parts of your application!

If you want to specify the fields to be changed you need to know the appropriate field mask. That is not as hard as it sounds, because the
names are very easy to "guess", here are a few examples

<TABLE>
    <TR>
        <TD>
            Set the core of a node
        </TD>
        <TD>
            Node::CoreFieldMask
        </TD>
    </TR>
    <TR>
        <TD>
            Add or sub a child
        </TD>
        <TD>
            Node::ChildrenFieldMask
        </TD>
    </TR>
    <TR>
        <TD>
            Set the matrix of a transform core
        </TD>
        <TD>
            Transform::MatrixFieldMask
        </TD>
    </TR>
    <TR>
        <TD>
            Set the choice field of a switch
        </TD>
        <TD>
            Switch::ChoiceFieldMask
        </TD>
    </TR>
</TABLE>

You see it is very easy in most cases. In gerneral it is 
<PRE>
    <I>ClassToBeEdited</I>::<I>FieldToBeEdited</I>FieldMask
</PRE>
If you are unsure about a certain field mask then have a look at the tutorials if that what you want to do was used before. If not you have to
look it up in the doxygen class documentation. You can find the available masks at the "Static Public Attributes" section.

\subsection TutorialBasicStandardGeometry Standard Geometry

OpenSG comes along with some build-in functionality to generate standard geometries. On of these was already used in the first tutorial: a torus.
As these geometires are very easy to generate and use for testing purposes I will list them here for reference

\code
makePlane(xsize, ysize, resHor, resVer);
makeBox(xsize,ysize,zsize, resHor, resVer, resDepth);
makeCone(height, bottomRadius, resSides, doSide, doBottom);
makeCylinder(height, radius, resSides, doSide, doTop, doBottom);
makeTorus(innerRadius, outerRadius, resSides, resRings);
makeSphere(resDepth, radius);
makeLatLongSphere(resLat, resLong, radius);
makeConicalFrustum(height, topRadius, bottomRadius, doSide, doTop, doBottom);
\endcode

The methods themself should be selfexplaining - they do that what they are supposed to do. All sizes and radii are of type Real32, where as all
resolution parameters (beginning with <I>res</I>) are Int16. Paramters beginning with <I>do</I> are of type bool, they enable or disable the
rendering of the appropriate parts. The following example would generate a 10 unit height cone with 32 edges but without a bottom
<PRE>
    NodePtr n = makeCone(10, 5, 32, true, false);
</PRE>
Always be careful with the resulution paramters. Big values can lead to really huge geometry data. Especially the sphere resolution depth should be
used moderatly, because this one is recursive, meaning a value of four is already a smooth sphere and a value of 64 may kill your machine!\n 
<I>(A word from the author: I just tried what I said, just to make sure... and yes, 64 definitely kills your machine unless you are equipped with 
a G5 full of memory (8 GB)... and i am not)</I>

All of these geometry generating methods return a NodePtr. Often you have already existing nodes and are only in need of the geometry. In this case
you do not need to throw you node away as there are the same functions that return a GeometryPtr. You only need to append a "geo" to the above 
functions.

\code
//Another way to generate the cone
NodePtr n = Node::create();

GeometryPtr g = makeConeGeo(10, 5, 32, true, false);
beginEditCP(n, Node::CoreFieldMask);
endEditCP(n, Node)

\endcode

Please notice that in this special case it is not very useful to use the makeConeGeo Version, as this does the same as the example before and
is much longer in code, but in other circumstances it can be just the other way round.

\section TutorialBasicTutorial2 Tutorial - More than a torus

This time we are capable of doing some more intersting stuff than displaying and rotating a torus. In this tutorial we will build a complete house
with roof and chimney. And maybe you can build even more things into it ;-). Okay so let us think about it, before we begin to write code...

\image html house_wire.png "'Wireframe' of our house"
\image latex house_wire.eps "'Wireframe' of our house" width=4cm

<I>
This is a frontal wireframe view of the house we want to build. Because we are lazy we are cheating a bit when it comes to building the roof. We
have no appropriate standard geometry so we use a box with the correct length and rotate it by 45 degrees. So the diagonal length of the box must
be as long as the top side of our house is: The diagonal length must therefore be twenty and our old friend Pythagoras tells us that the edge length
have to be approximately 14.14. The chimney will be a cylinder with height 10 and radius 1 just stuck into the roof. Please notice that I am not
claiming to do excellent modelling work here.
</I>

We will use a very similar framework than we did before, but this time we write a method which will create a scenegraph and return a NodePtr. Of
course that is not really necessary, but it is easer to read. In bigger procjets it could even be useful to put this method into an own file.

Like we did in the last tutorial, exchange the line that says
<PRE>
    NodePtr scene = makeTorus(.5, 2, 16, 16);
</PRE>
with
<PRE>
    NodePtr scene = createScenegraph();
</PRE>

Now add this function at the beginning of your file (It has to be defined before the main function where it is used!)

\code
//File : 03MoreThanATorus.cpp

//This function will create our scenegraph
NodePtr createScenegraph(){
    // First we will create all needed geometry
    // the body of the house
    NodePtr houseMain = makeBox(20,20,20,1,1,1);
    
    // now the roof
    NodePtr roof = makeBox(14.14, 14.14, 20, 1, 1, 1);
    
    // and the chimney - we have the top and sides generated
    // but we have no need for the bottom (it is inside the house)
    NodePtr chimney = makeCylinder(10,1,8,true,true,false);

    // Now we create the root node and attach the geometry nodes to it
    NodePtr n = Node::create();
    beginEditCP(n, Node::CoreFieldMask | Node::ChildrenFieldMask);
        n->setCore(Group::create());
        n->addChild(houseMain);
        n->addChild(roof);
        n->addChild(chimney);
    endEditCP(n, Node::CoreFieldMask | Node::ChildrenFieldMask);
    return n;
}

\endcode

Compile and execute the application - and while doing so, think about what we will see!

If you zoom out a bit (pressing the right mouse button while moving) the only thing you will see is one and only one box. That is because the 
smaller box as well as the cylinder are inside of the big box. So next thing is, we need to translate these to the correct positions.

\code

//File : 03MoreThanATorus2.cpp

//This function will create our scenegraph
NodePtr createScenegraph(){
    // we will use the variable to set our trandform matrices
    Matrix m;
    
    // First we will create all needed geometry
    // the body of the house
    NodePtr houseMain = makeBox(20,20,20,1,1,1);
    
    // now the roof
    NodePtr roof = makeBox(14.14, 14.14, 20, 1, 1, 1);
    
    // we translate the roof to the correct position
    TransformPtr tRoof = Transform::create();
    beginEditCP(tRoof, Transform::MatrixFieldMask);
        m.setIdentity();
        m.setTranslate(0,10,0);
        m.setRotate(Quaternion(Vec3f(0,0,1), 3.14159/4));
        
        tRoof->setMatrix(m);
    endEditCP(tRoof, Transform::MatrixFieldMask);
    
    NodePtr roofTrans = Node::create();
    beginEditCP(roofTrans, Node::CoreFieldMask | Node::ChildrenFieldMask);
        roofTrans->setCore(tRoof);
        roofTrans->addChild(roof);
    endEditCP(roofTrans, Node::CoreFieldMask | Node::ChildrenFieldMask);
    
    // and the chimney - we have the top and sides generated
    // but we have no need for the bottom (it is inside the house)
    NodePtr chimney = makeCylinder(10,1,8,true,true,false);
    
    //now we translate the chimney
    
    //create the transform core
    TransformPtr tChimney = Transform::create();
    beginEditCP(tChimney, Transform::MatrixFieldMask);
        m.setIdentity();
        // -5 along the x-axis and 2.5 along the z axis
        // translates the chimney away from the center
        // 15 along the y-axis translates the chimney to fit on top
        // of the big box (have a look at the figure above2,5
        m.setTranslate(-5,15,2.5);
        
        tChimney->setMatrix(m);
    endEditCP(tChimney, Transform::MatrixFieldMask);
    
    //insert the transform core into the node
    NodePtr chimneyTrans  = Node::create();
    beginEditCP(chimneyTrans, Node::CoreFieldMask | Node::ChildrenFieldMask);
        chimneyTrans->setCore(tChimney);
        chimneyTrans->addChild(chimney);
    endEditCP(chimneyTrans, Node::CoreFieldMask | Node::ChildrenFieldMask);

    // Now we create the root node and attach the geometry nodes to it
    NodePtr n = Node::create();
    beginEditCP(n, Node::CoreFieldMask | Node::ChildrenFieldMask);
        n->setCore(Group::create());
        n->addChild(houseMain);
        n->addChild(roofTrans);
        n->addChild(chimneyTrans);
    endEditCP(n, Node::CoreFieldMask | Node::ChildrenFieldMask);
    return n;
}

\endcode

Have a close look at the transformation matrices. Maybe you wonder how to figure out the correct translatation values. Well, you need to know 
where the pivot is. When using OpenSG standard geometry the pivot is at the center. The next figure shows the intial situation, when the geometry 
is created, but yet not translatet.

\image html house_wire_init.png "Initial situation before translating"
\image latex house_wire_init.eps "Initial situation before translating" width = 4cm

<I>
The red cross marks the pivot for all three objects. If we want to set the correct y (=height) value for the chimney we need to translate it
by half the height of the big box (which is 10) and the half height of the chimney itself (which is 5) and you see, we need to translate it
by 15 units along the y-axis.
</I>

The next one shows how we need to translate the roof. Notice that I left out the chimney here for didactival purposes ;)

\image html house_wire_roof.png "Translation and rotation of the roof"
\image latex house_wire_roof.eps "Translation and rotation of the roof" width = 4cm

<I>First we need to translate the roof 10 units along the y axis, so that the pivot of the roof lies exactly on top of the houses body. Next we 
rotate the roof by 45 degrees</I>

\section TutorialBasicImages Images

Every realtime rendering system can of course load images and use these as a texture for your models. OpenSG would be not a real scenegraph
system if it were not able to load several image formats. Please notice that you need to enable support for the image formats you want to use 
during configure (Compilation is dicussed here : \ref TutorialInstallationLinux). If you are using a precompiled package, all available image
formats are enabled.

The supported image formats are png, jpeg, tiff, gif, ppm, rgb and sgi. Others may follow in future versions, but actually you can do all you need with
the provided formats. Images in OpenSG are stored in a field container class called "Image". But this class is not used directly to texture
your models. In most cases you will create an instance of "SimpleTexturedMaterial" to which an image can be assign to texture your models.

First we have a look at how images can be loaded. This is very easy, as you can see here:

\code
//create a new image object
ImagePtr img = Image::create();

// and now we load the image from disk
img->read("myVeryNiceImageFile.jpg");
\endcode

The good thing is, that the image loader is very smart, as he automatically detects the filetype by the file extension and thus one method
can load all formats which are supported - there is no need for loadPNG, loadJPG etc.

Of course you can generate your own image by hacking code. 

\code
ImagePtr img = Image::create();
UChar8 data[] = {0,0,0, 50,50,50, 100,100,100, 255,255,255};

beginEditCP(img);
    img->set( Image::OSG_RGB_PF, 2, 2, 1, 1, 1, 0, data);
endEditCP(img);
\endcode

These are the paramters of the set method
<PRE>
    set (
        UInt32 pixelFormat,
        Int32 width,
        Int32 height = 1,
        Int32 depth = 1,
        Int32 mipmapCount = 1,
        Int32 frameCount = 1,
        Time frameDelay = 0.0,
        const UInt8 *data = 0,
        Int32 type = OSG_UINT8_IMAGEDATA
    )
</PRE>

As you see most of the paramters have default values assigned to them. If you want to create a simple two dimensional
image you actually only need to set the pixel format, width, height and the data, all other default values are good for that.

<I>pixelFormat</I>\n
The first paramter of the set method defines the pixel format. The two most important are OSG_RGB_PF and OSG_RGBA_PF. If you are using RGB 
pixel format, you need to provide three bytes for each pixel, so in our example we have four pixels from black to white each consisting of
three values for the color channels <I>R</I>ED, <I>G</I>reen and <I>B</I>lue. RGBA adds a fouth component "alpha" which defines the opacity 
of the pixel. A value of zero is a fully transparent (i.e. invisible) pixel where as 255 is not transparent at all. 

<I>width, height, depth</I>\n
These parameters define the size of the image. The image class is capable to store 1D, 2D as well as 3D images. The dimensions you do not
need should be set to one (not zero!). That is, a 1D image should have the width of your choice and height and depth set to one.

<I>mipmapCount</I>\n
If you do not know what mipmapping actually is, then leave this paramter as it is! ;) If you want to know more about
mipmapping, have a look at <A HREF="http://www.sgi.com/software/opengl/advanced98/notes/node35.html">http://www.sgi.com/software/opengl/advanced98/notes/node35.html</A>.

<I>frameCount, frameDelay</I>\n
These parameters are used for animated textures. The frameCount defines how much images will be used and the delay says where to start. A setting of 0.0 here
means of course to start from the beginning.

<I>data</I>\n
This one is carrying the actual data. Please notice that you have to pay special attention to this: The number of arguments you pass here must be exact.
You will need 
<PRE>
    width*height*depth*frameCount*{3,4}
</PRE>
values. The last digit have to be three in RGB and four in RGBA mode. If this number is not exact your application will crash or at least it will do 
something different as you want.

The data is stored row after row beginning at the top left corner! The following figure illustrates that

\image html image_storage.png "The direction in which the pixels are stored in memory"
\image latex image_storage.eps "The direction in which the pixels are stored in memory" width=4cm

You need to remember this, whenever you provide the image data "by hand", if you do not you image will be mirrored

\section TutorialBasicTutorial3 Tutorial - Using textures

Now we will learn how we can assign textures to geometry tomake our scenes even more beatiful ;) Please use the framwork
<A HREF="progs/00framework.cpp">progs/00framework.cpp</A> as a starting point. 

You need to add two new include files in order to load and display images used as a texture
<PRE>
#include <OpenSG/OSGSimpleTexturedMaterial.h>
#include <OpenSG/OSGImage.h>
</PRE>

The following code describes the createScenegraph() function, which will create a simple textured box. 

\code
    //File : 04Textures.cpp
    
    //create the geometry which we will assign a texture to
    GeometryPtr boxGeo= makeBoxGeo(10,10,10,1,1,1);
    
    //Load the image we want to use as a texture
    ImagePtr image = Image::create();
    image->read("images/bricks.jpg");
    
    //now we create the texture that will hold the image
    SimpleTexturedMaterialPtr tex = SimpleTexturedMaterial::create();
    beginEditCP(tex);
        tex->setImage(image);
    endEditCP(tex);
    
    //now assign the fresh texture to the geometry
    beginEditCP(boxGeo, Geometry::MaterialFieldMask);
        boxGeo->setMaterial(tex);
    endEditCP(boxGeo, Geometry::MaterialFieldMask);
    
    // Create the node that will hold our geometry
    NodePtr n = Node::create();
    beginEditCP(n, Node::CoreFieldMask);
        n->setCore(boxGeo);
    endEditCP(n, Node::CoreFieldMask);
    
    return n;    
\endcode

Just zoom out a bit and turn the camera around and you will see a wonderfull textured cube!  Of course there are a lot more properties that can
be set in the SimpleTexturedMaterial object, but we will have a closer look at that in Chapter(xxx). 

Notice:\n
If you create you own geometry (not the OpenSG standard geometry) then you have to supply all texture coordinates - these are generated 
automatically when using standard geometry, but not if you are creating your own!

\section TutorialBasicLoadingSaving Loading and saving of scenes

The next interesting and important topic is loading and saving of models and whole scenes. OpenSG can load some more or less common formats:
<UL>
<LI>VRML97</LI>
<LI>OFF</LI>
<LI>OBJ</LI>
<LI>RAW</LI>
<LI>OSG</LI>
<LI>BIN</LI>
</UL>

As far as I know VRML97 and OBJ are the most important formats as nearly every 3D modelling package can at least export one of them. BIN is
the OpenSG native binary format and can be very useful if you are storing scenes on disk. 

Loading scenes and models from disk is quite easy, at least if it works ;) Normally a simple
<PRE>
    NodePtr n = SceneFileHandler::the().read(<I>filename</I>)
</PRE>
will do. If you have, let's say a VRML-file, the generic loader will automatically select the appropiate loader. Like loading images you can
use one and the same command for loading all supported filetypes.

As you can see, the return type is a NodePtr - if the loading process was not successfull for some reason "NullFC" is returned. It might be a
good idea to check against the success of loading, else you might crash you application.

Saving a scene is as nearly as simple. You need a filestream and an instance of a writer class, like the BINWriter. Have a look at the next tutorial
there I will use the BINWriter to save the loaded scene to disk.

\section TutorialBasicTutorial4 Tutorial - loading and saving

Again, takt the 00framework.cpp file as a starting point. And again you have to add a new include file:
<PRE>
    #include <OpenSG/OSGSceneFileHandler.h>
</PRE>

Insert the following code into the createScenegraph() method

\code
    NodePtr n = SceneFileHandler::the().read("data/terrain.wrl");
    return n;
\endcode

Easy, isn't it? The bad news is, that sometimes it just won't work. I personally made experience, that the VRML exporter of 
3D Studio Max is not very good. It often procdues otput which was not readable by OpenSG, often resulting in a crash of the application. If I
exported the same model with Cinema4D it just worked fine. 

Well, know we implement the possibility to save the scene by pressing a key. Three changes are necessary

1.\n
At first we need to register a new callback function which will listen to keyboard input. Add
<PRE>
    glutKeyboardFunc(keyboard);
</PRE>
to the setupGLUT function 

2.\n
Add the following function somewhere before setupGLUT.

\code
void keyboard(unsigned char k, int , int ){
    switch(k){
        case 's':
        
            // there were some changes in the interface since version 1.2.0
#if OSG_MINOR_VERSION > 2
            // this is the cvs version or version 1.3+
        
            // create an output stream (this is STL code, and
            // is not OpenSG specific!)
            ofstream out("data/output.bin");
            if(!out){
                cout << "Output stream could not be created!" << endl;
                return;
            }
            //create the writer object
            BINWriter writer(out);
#else
            // this code applies to version 1.2
            FILE* outFile = fopen("data/output.bin", "wb");
            if(outFile == NULL){
                cout << "File could not be created!" << endl;
                return; 
            }
            //create the writer object
            BINWriter writer(outFile);
#endif
            
            //write the file now
            writer.write(scene);
            
            cout << "File written!" << endl;
            break;
    }
}
\endcode
<I>
Notice: There were some changes in the interface of the BINWriter class since version 1.2.0. This is why I had to use these #define blocks!
</I>

3.\n
Additionally you have to add "<OpenSG/OSGBINWriter.h>"  to your list of files to include












\section TutorialBasicExercises Exercises

\subsection TutorialBasicExercises1 Ex. Transformations

Please recall the second tutorial (\ref TutorialBasicTutorial2). We translated the roof with the following transformation Matrix

\code
beginEditCP(tRoof, Transform::MatrixFieldMask);
    m.setIdentity();
    m.setTranslate(0,10,0);
    m.setRotate(Quaternion(Vec3f(0,0,1), 3.14159/4));
        
    tRoof->setMatrix(m);
endEditCP(tRoof, Transform::MatrixFieldMask);
\endcode

What would happen if we swap the "setTranslate" and the "setRotate" commands? After you found out: why did it happen that way?

\subsection TutorialBasicExercises2 Ex. Loading

Modify the loading/saving tutorial (\ref TutorialBasicLoadingSaving) in that way, files can be loaded from the command line. If you type
<PRE>
    ./05loading file1.wrl file2.wrl file3.wrl
</PRE>
the application should load the three specified files. Also check if the file was successfully loaded and if not throw an appropiate error 
(the application should continue to run!).

Next Chapter: \ref NodeCores
*/

#include <OpenSG/OSGConfig.h>

OSG_USING_NAMESPACE;

/*! 
\page Windows Windows and Viewports
\latexonly Starter:NewChapter \endlatexonly

Chapter Overview
<HR>
    \ref TutorialWindowsWindows <BR>
    \ref TutorialWindowsViewports <BR>
	\ref TutorialWindowsCameras <BR>
	\ref TutorialWindowsBackground <BR>
	\ref TutorialWindowsForegrounds <BR>
	\ref TutorialWindowsExercises
<HR>

This chapter is all about windows and viewports. A window is self explaining, as of course, OpenSG needs a window which it will render in. Viewports are
rectangular areas within the window. Every application has exactly one window and one or more viewports. All applications you have seen so far had one
window with one viewport which were provided by the simple scene manager. I will also introduce foregrounds and backgrounds as these are closly related to
windows and viewports. Foregrounds can be used to display some sort of logo or even to capture a screenshot where as backgrounds do exactly what you expect
them to do.

\section TutorialWindowsWindows Windows

As I mentioned above every application needs a window. We alway have created a simple GLUTWindow right at the very beginning of the main method. 

\code
int main(int argc, char **argv)
{
    osgInit(argc,argv);
        
    int winid = setupGLUT(&argc, argv);
    GLUTWindowPtr gwin= GLUTWindow::create();
    gwin->setId(winid);
    gwin->init();

    scene =createScenegraph();

    // ....
\endcode

Of course the GLUT Window is not the only one. Here is a list of all available windows

<UL>
<LI>GLUTWindow</LI>
<LI>QTWindow</LI>
<LI>XWindow</LI>
<LI>Win32Window</LI>
<LI>PassiveWindow</LI>
<LI>ClusterWindow</LI>
<LI>MultiDisplayWindow</LI>
<LI>SortFirstWindow</LI>
</UL>

The first four windows are providing a connection between OpenSG and the windowing system you are using. GLUT and QT windows
actually do have some advantages compared to the others, because both work on many different platforms where as X Windows are restricted to UNIX boxes and
Win32 windows are really restricted to the Microsoft platform. Additionally GLUT and QT windows might be a bit easier to use as there are wrapper classes 
that may help you out. We have used GLUT windows all the way, so you should be familiar with that. For QT you can have a look at [TODO: QT example]

So what does a window actally do? First of all it is responsible for output and output only. So is no handling of input events or similar things. A window
keeps it's instances of viewports and manages OpenGL context creation and activation/deactivation. It also handles detection of OpenGL extensions. 

The passive window is a bit different from the others. A passive window does not handle OpenGL context. It's purpose is to fit seamlessly into other OpenGL
programs. Passive windows can be used with any window system and GUI.

The last three windows, cluster, multi display and sort fist windows are used for clustering. These will be discussed in more detail in Chapter(xxx).

At the end of this chapter there will be a tutorial where we will set up an application from scratch, without the simple scene manager. This tutorial
may explain the usage of windows and viewports better that thousands words could say...

\section TutorialWindowsViewports Viewports

A Window must at least have one viewport, but can have more. A viewport represents a part of the scene that is being rendered into. One or more viewports
can, but have not to, cover the whole window. Every viewport can only be attached to one window. A typical use of multiple viewports is the 
perspective/front/left/right view you might know from a modelling package or other applications

\image html 4ports.png "Typical use of four viewports"
\image latex 4ports.eps "Typical use of four viewports" width = 8cm

The size of a viewport is definied by providing values for left, right, top and bottom paramters. These can either be bewtween 0 and 1 or greater than 1. The
first variant means the size of the viewport is relative to the window whereas values above 1 specify the size in pixels. You should decide which variant to
use depending on wether the viewports shall scale together with the window if it is resized or not. Here is an example showing a window with two viewports,
one defined relativly and the other absolute.

\image html viewports_new.png "Resizing window with two different viewports"
\image latex viewports_new.eps "Resizing window with two different viewports" width = 8cm

<I>
    The yellow viewport is defined relativly to the window whereas the red vieport's values are given absolutly in pixels. When the window is resized the 
    yellow viewports changes it's size to, but the red one doesn't change shape and position at all.
</I>

You can also pass a -1 to one or more parameters which means that the most possible space is taken by the viewport. An exception to these sizing rules is the
passiveViewport which simply ingnores all given values as it takes it size from the current active OpenGL context. 

In order to use a viewport correctly you need not only to define it's size but some things more are needed: A root node of the scenegraph (or only part of it)
which should be rendered, a camera and a background are needed. Optional you can provide a foreground. 

As you might guess there are also differnt types of viewports. The one that came along with the simple scene manager was a standard viewport. Here is a list
of all available viewports

<UL>
<LI>Viewport</LI>
<LI>PassiveViewport</LI>
<LI>ColorBufferViewport</LI>
<LI>StereoBufferViewport</LI>
</UL>

Well, the default Vieport is what you want in most cases. Passive viewports are needed to integrate OpenSG into existing OpenGL programs. The color buffer
viewport allows rendering of specific color channels and finally the stero buffer viewport is used mostly for active stereo applications. Stero with
shutter glasses for example need four buffers which are provided by osg::StereoBufferViewport. Passive stero can be achived with default viewports. 
More on that in Chapter(xxx)

\section TutorialWindowsCameras Cameras

A camera is of course needed for every application. The camera defines what is actually being rendered. The same way as you can have multiple viewports, you
can also have multiple cameras. However, one camera can be attachted to more than one viewport. The most important parameters of a camera are it's position
and orientation. Cameras in OpenSG behave in a similar way like light sources - their position is definied by the transformation of a beacon they are assigned
to. In most cases you will have a transformation node right below the root node and use it as a beacon for the camera. However, if you want the user to
drive a car it would make sense to attach the camera to the car geometry node thus using the same transformations.

Good news is that we only need one matrix to describe the position and orientation of the camera, but bad news is that often you are given two points in
space, one where the camera is located and on where it is looking at and another vector telling you where "up" is from the camera's point of view. 
Whenever you want to use these values you would have to calculate the matrix in order to use them with OpenSG. Well, luckily that has been done for you
already: the osg::MatrixLookAt function from OSGMatrixUtility.h does that job!

OpenSG cameras are using the same coordinate system conventions like OpenGL: the camera is looking along the negative z-axis, y points up and x points right.

In addition to position and orientation there are some internal camera parameters which may differ from camera to camera. However, the near- and far clipping 
planes are needed by every camera. 

In OpenGL you have two matrices that are responsible for transforming the world onto the rectangluar area which is you screen: GL_MODELVIEW and
GL_PROJECTION matrix. OpenSG stores internally three matrices, because the projection matrix is split up into two: one for the real projection and another
for a projection transformation. The last one is needed for non-coplanar multi-screen projections like a CAVE. However, we don't need to pay special attention
to that for now.

Here is a short overview of the different cameras you can use with OpenSG

\subsection TutorialWindowsCameraPerspective Perspective Camera

This is the most common camera. The osg::PerspectiveCamera is the same kind of camera OpenGL uses for rendering. Unless you are doing something special you 
will be fine with this camera. There is only one additional attribute, the vertical field of view defines the opening angle of the camera. The horizontal 
field of view is automatically adjusted to create a square aspect ratio. The value is given in radians not in degrees!

Here is an example on how to setup a camera

\code
    PerspectiveCameraPtr camera = PerspectiveCamera::create();
    beginEditCP(camera);
        camera->setBeacon( some_node );
        camera->setFov( deg2rad( 60 ) );
        camera->setNear( 0.5 );
        camera->setFar( 8000 );
    endEditCP(camera);
\endcode
<I>
Let us assume that one centimeter equals one unit, then we would have created a camera with an opening angle of 60 degrees, a far clipping plane half a
centimeter in front of the camera and the far clipping plane 80 meters away
</I>

\image html camera.png "Clipping Planes and Vertical Field of View"
\image latex camera.eps "Clipping Planes and Vertical Field of View" width = 4cm

\subsection TutorialWindowsCameraMatrix Matrix Camera

Sorry, the matrix camera is not related to the movie trilogy and hence cannot procduce that matrix camera effect called bullet time. However if you want
to help the development of OpenSG... ;-) 

The matrix camera is a very simple one as it keeps the modelview and perspective matrices directly and ignores all other attributes it may have. Under
certain cicumstances this may be very usefull, especially if you are integrating OpenSG into an existing OpenGL program by using a passive window as well
as passive viewports. With the camera you are very close to standard OpenGL behaviour.

\subsection TutorialWindowsCameraDecorators Camera Decorators

A decorator can be used insted of the original object where as the decorator enhances the original in some way. Here is an example: For an stero application
you need two cameras and if you are moving the camera around you normally would have to do things twice. With camera decorators you can use two
osg::ShearedSteroCameraDecorator which will point both to the same camera. The decorators will be assigned to the viewports instead of the camera. If
you now move the camera both virtual cameras represtened by the decorators will move simultanously. And again, more on stereo in Chapter(xxx)

A big advantage of decorators in general is, that you can easily change the object which is decorated by some another and maintain the enhancements the
decorators provide. In our example you could exchange a perspective camera with a matrix camera and the stero setup won't be destroyed!

Here is an overview of the decorators currently available

\subsubsection TutorialWindowsCameraDecoratorsStero Stereo Decorators

There are actually to different decorators for stero solutions. Both have some attributes in common. The eye seperation defines the distance between the
two eyes and is provided in modell units. You should be very careful with this value as too small or big values will destroy the stereo effect (and may
make people sick...). Finally you need to tell the decorator if it is the left or the right one. This is handed by a simple boolean variable where true
indicates the left eye.

OSG::ShearedSteroCameraDecorators are used for typical passive stereo applications where two beamer are projecting the image and the audience is wearing
polarising glasses. They add one additional attribute, the distance to the zero parallax plane. The zero parallax plane is a plane where the left and 
right image perectly overlap, i.e. the parallax is zero. This value should reflect the distance from the user's point of view to the image plane.

The following code creates a decorator for the right eye and a corresponding vieport

\code
    cameraDecorator = ShearedStereoCameraDecorator::create();
    beginEditCP(cameraDecorator);
        cameraDecorator->setLeftEye(false);
        cameraDecorator->setEyeSeparation(6);
        cameraDecorator->setDecoratee(some_camera);
        cameraDecorator->setZeroParallaxDistance(200);
        rightViewport = OSG::Viewport::create();
        beginEditCP(rightViewport);
            rightViewport->setCamera    ( cameraDecorator );
            rightViewport->setBackground( some_background );
            rightViewport->setRoot      ( root );
            rightViewport->setSize      ( .5,0,1,1 );
        endEditCP(rightViewport);
    endEditCP(cameraDecorator);
\endcode 

<I>
    I choose 6 for the eye separation and 200 for the distance to the image plane. The would make only sense if one unit is equal to one centimeter. You
    might have to adjust these values according to your units. 
</I>

OSG::ProjectionSteroCameraDecorators are mainly used for tracked stereo applicaions like a CAVE. I will not discuss this decorator here unless there
is a public demand for it ;-)

\subsubsection TutorialWindowsCameraDecoratorsTile Tile Camera Decorator

This kind of decorator is used to scale some rectangular area up to full viewport size. It's mainly use is to divide a large rendering area into some small
areas which are displayed on a dfifferent sceen each. The parameters of the camera can be set up as if you were using one large viewport. This is much easier
than placing several cameras side by side to achieve the same effect. 

In Darmstadt, Germany there is a wall of screens, called HEye Wall, with 6 * 4 screens which is capable of stereo rendering. An 48 + 1 cluster running 
OpenSG is driving the HEye Wall. Instead of using 48 cameras it is sufficient to use only one single camera and let the decorators do the rest!

\section TutorialWindowsBackground Backgrounds

Well the background does simply what a background is suppposed to do. Any region that was not covered by some object that was just rendered is filled with
a backgound. Every viewport must have exactly one background, it can not have more. However, it is of course possible to swap backgrounds during runtime. 
There are several different backgrounds at your disposal.

\subsection TutorialWindowsBackgroundSolid Solid Background

osg::SolidBackground is the most simple and common of all backgrounds, it simply fills the screen with one color. Setting up such a background is very easy. 
The following example will generate a red background.

\code
SolidBackgroundPtr bg = SolidBackground::create();
beginEditCP(bg, SolidBackground::ColorFieldID);
	bg->setColor(Color3f(1,0,0));
endEditCP(bg, SolidBackground::ColorFieldID);
\endocde

\subsection TutorialWindowsBackgroundGradient Gradient Background

osg::GradientBackground enables you to fill the background with a color gradient. To specify the gradient you can use any number of color keys. Gradients in
OpenSG are always vertical. Every color key needs a value between 0 (bottom) and 1 (top). If no color key is givin the background will be black, if only one
key is given the background will be identical to a solid background with the same color. Regions which are not filled will be drawn in black, too.

\code
	[TODO: Gradient Example]
\endcode

TutorialWindowsBackgroundImage Image Background

You also can uses images as a background by using osg::ImageBackground. The image can be scaled to fill the whole viewport, else it will be drawn from the
lower left corner, leaving unoccupied regions in a user defined color. Please notice that the image is not used like a texture thus image backgrounds are
not as fast to draw than the others. Setting up an image background is also very simple. The following example will create a background with some image,
which will not be scaled to fit the viewport and left areas will be drawn black.

\code
	ImageBackgroundPtr imBkg = ImageBackground::create();
	beginEditCP(imBkg,  ImageBackground::ColorFieldMask |
						ImageBackground::ImageFieldMask |
						ImageBackground::ScaleFieldMask
			   ); 
		imBkg->setColor(Color3f(0,0,0));
		imBkg->setImage(some_image);
		imBkg->setScale(false);
	endEditCP(imBkg,  ImageBackground::ColorFieldMask |
						ImageBackground::ImageFieldMask |
						ImageBackground::ScaleFieldMask
			   );
\endcode

<I>
	Please notice that the image that need to be passed to setImage() is not just some jpg file or similar. You need to pass an osg::Image object. The tutorial
	at the end of this chapter will show you how to use an image background.
</I>

\subsection TutorialWindowsBackgroundPassive Passive Background

Well like the other passive components encountered so far, the osg::PassiveBackground does nothing at all thus there are no fields to set. It's main purpose is
to make it possible to have two or more overlapping viewports to generate combined images.

\subsection TutorialWindowsBackgroundSky Sky Background

The most exciting background for virtual reality environments is most likely to be the osg::SkyBackground. Inspired by the VRML background node the OpenSG
sky background is a sky box. With some parameters you can create quickly a ground-sky environment, but more interesting is to use six specially designed
textures which then can simulate an infine environment that will move if the user looks around.

\image html skybox.png "All six images of a skybox stichted together"
\image latex skybox.eps "All six images of a skybox stichted together" width = 4cm

\section TutorialWindowsForegrounds Foregrounds

Foregrounds are painted on top of the rendered image. They can be used to add a logo or a watermark for example, but a foreground can also be used to grab
an rendered image into an osg::Image or file. There can be more than one foreground assigned to a viewport. If that is the case they are evaluted in the same
order as they were added.

\subsection TutorialWindowsForegroundsImage Image Foreground

The most common foreground is the osg::ImageForeground which is often used to add a logo to a rendered scene. That image can be either RGB or RGBA. The
image foreground supports correct alpha blending.

\subsection TutorialWindowsForegroundsPolygon Polygon Foreground

The osg::PolygonForeground draws a single polygon with an optional texture on top of the rendered image. It's main purpose is to archieve the same results
as with the default image foreground, but by using a texture rather than an image. The usage might be a bit strange (at least it seems to me ;-) ) - you
need a set of 2D points and an equal number of 3D points to define the polygon and it's position on screen. If values for the 2D points are greater than one, 
the starting point is the lower left corner and for values smaller then -1 are using the upper right corner as origin. 

\subsection TutorialWindowsForegroundGrab Grab Foreground

The osg::GrabForeground can be used to grab a rendered image into an osg::Image. The size and position of the image define the area that will be grabbed. If
you only create the image and leave it's size to default values (i.e 1D image with 1 pixel) the whole viewport will be grabbed. It might be a bit confusing
that there is no such method like grab() or anything else that will actually invoke the grabbing process, but the grab is executed every time the frame is 
rendered. So if you are implementing something like a screenshoot function you should remove the foreground after fetching the image to avoid grabbing one
each frame!

The following example shows how you could set up a grab foreground. We are creating an image in RGBA color mode with size 1 to grab the whole viewport.

\code
	GrabForegroundPtr grab = GrabForeground::create();
	beginEditCP(grab);
		grabImage = Image::create();
		beginEditCP(grabImage);
			grabImage->set(GL_RGBA, 1);
		endEditCP(grabImage);
		grab->setImage(grabImage);
	endEditCP(grab);
	
	//mgr should be an instance of the SimpleSceneManager
	//We get a pointer to the foreground multifield from the viewport
	MFForegroundPtr *foregrounds = mgr->getWindow()->getPort(0)->getMFForegrounds();
	
	//now we simple add it to the foreground multifield
	foregrounds->push_back(grab);
\endcode

Whenever a frame is rendered the osg::Image grabImage will store the rendered frame overwriting a possibily previously stored frame. 

\subsection TutorialWindowsForegroundFileGrab File Grab Foreground

osg::FileGrabForeground works pretty much the same way grab foreground does. However as the name implies the result is stored in a file rather than in an
OpenSG image object. There is a boolean flag to tell the system wether this foreground is avtive or not. Furthermore you do not need to create an image 
instance as this is done automatically for you, but you have to provide a filename for the image to be stored. You can not only stores single files,
but image secuquences. The filename is given in a printf style thus naming an image "image%d" will lead to an image sequence as an internal frame counter
will replace the variable in the filename with the counter value. If you use %04d instead you will have leading zeros in your filename which might be very
usefull for some other applications.

\subsection TutorialWindowsForegroundSimpleStatistics

This foreground is subject to change, so hang on...

\subsection TutorialWindowsForegroundsGraphicStatistics

same as simple statistics foreground

\section TutorialWindowsTutorial Tutorial - Without Simple Scene Manager

As promised, we are going to build an application which will show a torus only. Again? Well, this time we are doing it from bottom up, without 
the comfortable support of the simple scene manager! Additionally we are going to use nice backgrounds and a logo in the foreground and add a screenshot feature
which will grab the rendered image and saves it in a file! To make the whole thing complete we are going to use two viewports thus we are having two different
viewing angles on our sceen! So here we go:

Here is an overview of what we are going to do.

\image html scene_setup.png "Application overview"
\image latex scene_setup.eps "Application overview" width = 8cm

\section TutorialWindowsExercises Exercises

\subsection TutorialWindwsExercises1 Ex. Sky Background

Try to use a sky background with textures. You can find the needed textures in the progs/data folder. The files are calles right.jpg, top.jpg,... and so on.


*/
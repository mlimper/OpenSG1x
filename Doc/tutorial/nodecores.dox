#include <OpenSG/OSGConfig.h>
#include <OpenSG/OSGNavigator.h>
#include <OpenSG/OSGPerspectiveCamera.h>

OSG_USING_NAMESPACE;

/*! 
\page NodeCores Node Cores
\latexonly Starter:NewChapter \endlatexonly

Chapter Overview
<HR>
    \ref TutorialNodeCoresTransform<br>
    \ref TutorialNodeCoresTransformComponentTransform<br>
    \ref TutorialNodeCoresMaterial<br>
    \ref TutorialNodeCoresSwitch<br>
    \ref TutorialNodeCoresLOD<br>
    \ref TutorialNodeCoresTutorial<br>
	\ref TutorialNodeCoresExercises<br>
<HR>

In this chapter you will learn how to use the most important cores. The transform and material core are discussed in more detail and additionally
I will introduce the Switch, LOD and component transform cores as well. At the end of the chapter there will be our first bigger tutorial, where
we will use all the cores introduced here.

The geometry core is for sure the most important one, but due to its complexity ad importance the whole next Chapter (\ref Geometry) is
dedicated to this core alone!

\section TutorialNodeCoresTransform Transform Core

The transform core was already briefly introduced in the last Chapter (\ref TutorialBasicCoresTransform), but now we will have a more deeper
look at it. However, about the transform class itself is not much left to say, as the most important method is the "setMatrix()" method, which let us
use any matrix as a transformation matrix. In order to create the transformation that you want, you need only to create the appropiate matrix. 

Let us imagine a more complex scene using more than just one transformation like we did before. A very common example is the model of a solor 
system. To make it a bit easier, we only want a sun and one planet with a single moon. The sun should be stationary and the planet is orbiting in a 
circle around the sun whereas the moon is doing the same around the planet. We also don't want to pay any attention to real sizes and distances. 
There is not only one way to solve this problem. We will have a closer look at two variants: One possibility is to have a deep graph, where the 
planet is attached to the sun whereas the moon is attached to the planet with each having a transformation describing the rotation around their 
parent object. That is the moon is moving in a circle around the planet which also is moving in a circile around the sun. Figure (xxx) is 
illustrating what I mean. 

\image html solarsystem_deep.png "The easy way to solve our problem..."
\image latex solarsystem_deep.eps "The easy way to solve our problem..." width = 3cm

<I>
As you can see, the rotation of the moon is dependant on the rotation of the earth, thus describing the rotation of these both objects in an
intuitive manner, but this may become unefficient if used extensevly
</I>

The other way is to have a transformation describing the complete movement, so all geometry nodes are located directly 
below the root node. This approach is not as intuitive than the other is, but it might be faster to compute. Figure (xxx) is illustrating this 
variant. 

\image html solarsystem_flat.png "The more efficient way..."
\image latex solarsystem_flat.eps "The more efficient way..." width = 8cm

<I>
On one hand this graph looks quite a bit friendlier, on the other hand the transformation for the moon will be a bit more difficult 
</I>

\subsection TutorialNodeCoresTransformFirstVariant Deep Graph

Well, let us give both variants a try. Like ever here is our createScenegraph method to begin with:

\code
NodePtr createScenegraph(){

    //create sun, planet & moon geometry
    GeometryPtr sun = makeSphereGeo(3, 6);
    NodePtr planet = makeSphere(3, 3);
    NodePtr moon = makeSphere(2,1);
	
    //the root node will be the sun
    NodePtr root = Node::create();
    beginEditCP(root, Node::CoreFieldMask);
	root->setCore(sun);
    endEditCP(root, Node::CoreFieldMask);
	
    NodePtr planetTransformNode = Node::create();
    NodePtr moonTransformNode = Node::create();

    // these were declared globally
    planetTransform = Transform::create();
    moonTransform = Transform::create();
	
    // Now we need to fill it with live
    // We want to have the planet some distance away from the sun, 
    // but initial with no rotation. The same aplies to the moon
    Matrix m,n;
	
    m.setIdentity();
    n.setIdentity();
	
    m.setTranslate(20,0,0);
    n.setTranslate(8,0,0);
	
    beginEditCP(planetTransform, Transform::MatrixFieldMask);
	planetTransform->setMatrix(m);
    endEditCP(planetTransform, Transform::MatrixFieldMask);
	
    beginEditCP(moonTransform, Transform::MatrixFieldMask);
        moonTransform->setMatrix(n);
    endEditCP(moonTransform, Transform::MatrixFieldMask);
	
    //Insert the cores into the apropiate nodes and add the geometry
    beginEditCP(planetTransformNode, Node::CoreFieldMask | Node::ChildrenFieldMask);
	planetTransformNode->setCore(planetTransform);
	planetTransformNode->addChild(planet);
    endEditCP(planetTransformNode, Node::CoreFieldMask | Node::ChildrenFieldMask);
	
    beginEditCP(moonTransformNode, Node::CoreFieldMask | Node::ChildrenFieldMask);
        moonTransformNode->setCore(moonTransform);
	moonTransformNode->addChild(moon);
    endEditCP(moonTransformNode, Node::CoreFieldMask | Node::ChildrenFieldMask);
	
    //add the planet to the sun
    beginEditCP(root, Node::ChildrenFieldMask);
	root->addChild(planetTransformNode);
    endEditCP(root, Node::ChildrenFieldMask);
	
    //add the moon to the planet
    beginEditCP(planet, Node::ChildrenFieldMask);
	planet->addChild(moonTransformNode);
    endEditCP(planet, Node::ChildrenFieldMask);
	
    //now we are done
    return root;
}
\endcode

We need to declare both TransformPtr, which will rotate the planet and moon, globally as this will make it much easier to manipulate the
transform matrices during rendering. 

\code
TransformPtr planetTransform;
TransformPtr moonTransform;
\endcode

If you compile this code now and zoom out a bit, you will see three different balls in one row. Well, it is not quite a realistic simulation
of our solar system... Anyway, the first thing we add now are the rotations I am talking all the time about. Replace the display() method with
the following code

\code
void display(void)
{
    Real32 time = glutGet(GLUT_ELAPSED_TIME );
    
    //create the Quaternion the describes the rotation of
    //the planet around the sun
    Quaternion planetRot = Quaternion(Vec3f(0,1,0), time/float(1000));
    
    //now the rotation of the moon around the planet
    //the factor 12 slows down the rotation by 12 compared to the
    //planet rotation
    Quaternion moonRot = Quaternion(Vec3f(0,1,0), time/float(12*1000));
    
    //generate the Matrices
    Matrix p,m;
    
    p.setIdentity();
    m.setIdentity();
    
    p.setRotate(planetRot);
    m.setRotate(moonRot);
    
    beginEditCP(planetTransform, Transform::MatrixFieldMask);
        planetTransform->setMatrix(p);
    endEditCP(planetTransform, Transform::MatrixFieldMask);
    
    beginEditCP(moonTransform, Transform::MatrixFieldMask);
        moonTransform->setMatrix(m);
    endEditCP(moonTransform, Transform::MatrixFieldMask);
    
    mgr->redraw();
}
\endcode

Allright, compile and execute... and what do you see? Only one planet, right? But why? Think about it, before reading any further!

Got it? Yes, we have overwritten the translation we set up in the first place. That is not so good, isn't it? We could try to extract the old
matrix out of our graph and then apply the rotation our we could create a completly new matrix and assigning the translation again. That is what
we will do for now, but in the next section we will learn about another possibility that solves our problem easy and efficient. Add the following
code right after we set the rotation

\code
// old code ------
    p.setRotate(planetRot);
    m.setRotate(moonRot);
// insert new code here:

p.setTranslate(20,0,0);
m.setTranslate(8,0,0);

\endcode

The terrible thing is that it still does not work! Do you have an idea what went wrong this time? Try to put a texture onto the spheres, or replace
these with cubes for example and you will see what actually is happening.

Something with the order of the transformations seem not to be correct: The rotation is applied locally to the pivot of the sphere itself, which
is of course not what we desire. The best solution for now is to do it simply by hand. If we multiply the seperate parts together we should
get what we want. So let's remember some math from college: The matrix multiplied last is executed first, thus
<PRE>
    M = Rotation * Translation
</PRE>
yields the correct transformation matrix. So again replace some code in the display function

\code

/*
locate the following lines in the display() function
and comment them out or delete them

p.setIdentity();
m.setIdentity();
    
p.setRotate(planetRot);
m.setRotate(moonRot);
    
p.setTranslate(20,0,0);
m.setTranslate(8,0,0);
*/

// add the following lines, replace these from above


//temporary matrices for translation and rotation    
Matrix t,r;
    
t.setTransform(Vec3f(20,0,0));
r.setTransform(planetRot);

//multiplying them together 
r.mult(t);
//the usage of matrix p is just cosmetic as it is
//and will be identical to r 
p.setValue(r);
    
t.setTransform(Vec3f(8,0,0));
r.setTransform(moonRot);
r.mult(t);
m.setValue(r);
    
\endcode

<I>
matrixA.mult(matrixB) multiplies matrix B from the right to matrix A, overwriting matrix A with the result (i.e. A=A*B).
</I>

Finally it works! The moon should now rotate quickly around the planet which rotates around the sun! The source file can be found here : 
<A HREF="progs/06solarsystem2.cpp">progs/06solarsystem2.cpp</A>


\subsection TutorialNodeCoresTransformSecondVariant Flat Graph

Please take the results from above (06solarsystem2.cpp) as a starting point for modifying the code. First we need to rearrange the graph. I will
not present the full code here again, because the cahnges are not so spectaular, but you can find the full code named 06solarsystem3.cpp. Here
are the necessary changes:

1. Locate the pice of code where the moonTransformation is added to the planet node - remove these lines, because the moon will no longer be
a child of the planet

2. Attach the moonTransformation you just removed to the root node

If you execute the application you will see that both the moon and planet are rotating around the sun, which makes sense, of course as the are both
children of the sun. Next we need to alter the transformation of the moon. The planets transformation may stay untouched as this is still correct.

The new transformation matrix for the moon can be calculated by
<PRE>
    M = PlanetRotation * PlanetTranslate * MoonRotation * MoonTranslate
</PRE>

\subsection TutorialNodeCoresTransformMatrix Matrix-Magic

Here you will find many possibilities how to create and manipulate matrices. Some basic examples can also be found here: \ref
BasicMathWorkWithMarices. These will not be repeated here! 

There are a lot of different possibilities to set up a matrix depending on what you desire. There are seperate methods to set a translation,
scalation, rotation or even the whole transformation. These methods often take real values, vectors or quaternions. I will show examples for all 
methods provided. Have a look at the matrix class documentation for additional reference.

\code
Matrix m;

m.setTranslate(1,2,3);
m.setTranslate(Vec3f(1,2,3));
m.setTranslate(Pntef(1,2,3));

m.setRotate(Quaternion(Vec3f(1,2,3),90));

//this is a uniform scale in all dimensions
m.setScale(2);
m.setScale(1,2,3);
m.setScale(Vec3f(1,2,3));
\endcode

Additionally there are some methods to set up the whole transformation at once. If you would like to set up a matrix which scales everything by
factor two, rotates 30 degrees around the y-axis and translates by some vector you would need at least 4 commands (including setIdentity()). 
This can also accomplished by just one command

\code

//just to shorten the code...
//used for rotations
Quaternion r = Quaternion(Vec(1,2,3), 90);
//used for translations
Vec3f t = Vec3f(1,2,3);
//used for scalation
Vec3f s = Vec3f(1,2,3);

// the first two commands are equal to setTranslate or setRotate
m.setTransform(t);
m.setTransform(r);

// but you can set rotation and translation at once
m.setTransform(t,r);
// the first vector specifies the translation whereas 
// the second defines the rotation

// like above with an additional scalation
m.setTransform(t,r,s);

// this adds an additional scaling orientation
m.setTransform(t,r,s,Vec3f(1,1,0));

// and and additional center point for scalation (or rotation???) [TODO: test it]
m.setTransform(t,r,s,Vec3f(1,1,0),Vec3f(10,0,0));
\endcode

You also can do it the other way round: it is possible to retrive the rotation etc. from a matrix by using getTransform. Here is an example:

\code
// lets assume m is any sound matrix

Quaternion rotation;
Vec3f translation;
Vec3f scaleOrientation;
Vec3f scalation;

m.getTransform(translation, rotation, scalation, scaleOrientation);

// there is another variant which provides the possibility to extract 
// the center point
Vec3f center;

m.getTransform(translation, rotation, scalation, scaleOrientation, center);

// the result will be written into the variables you passed to the method
// translation would be (1,2,3) if we take m from the example above
[TODO: Test it]
\endcode

In addition to these methods there are of course other expected functions for inverting a matrix and other operations.

\code
m.invert();        //calculates the inverse matrix;
m.transpose();      //as you expect it...
Real32 d = m.det(); //calculates the determinant
\endcode

In the above example the results will overwrite the original matrix. You must not create a copies by hand, as these methods are intended for

\code
Matrix result;

result.invertFrom(m);
m.transposed(result);
\endcode

As always you should have a look at the matrix documentation class for full reference.

[TODO: check examples]

\section TutorialNodeCoresTransformComponentTransform Component Transform

Remember the problems we had setting up the correct transformation matrices for our solar system example? Now imagine working with more
complex transformations than we did, which were in fact realativly easy ones. Another important issue is alteration of a matrix during 
runtime. In the solar system we recalculated the whole matrix by multiplying the rotation with the translation, altough we only wanted to
modify the rotation. I many cases it is just to complicated or even impossible to reconstruct the single parts of a transformation. That is when
component transforms are coming into play. 

Component Transform cores are able to stores translation, rotation, scalation, scale orientation and a center point seperatly apart from each other
thus every component can be edited without afecting the other parts. There are appropiate getter and setter methods for these fields. The 
following little example will illustrate the usage of a component transform core

\code

ComponentTransformPtr ct = ComponentTransform::create();

beginEditCP(ct, ComponentTransform::TranslationFieldMask |
                ComponentTransform::RotationFieldMask);
                
    ct->setTranslation(Vec3f(20,0,0));
    ct->setRotation(Quaternion(Vec3f(0,1,0),PI/4));
    
endEditCP(ct, ComponentTransform::TranslationFieldMask |
              ComponentTransform::RotationFieldMask);

\endcode

If you now want to alter the rotation you only need to call the setRotation method and provide a new quaternion and that's it. The bad news is
that you might get the same multiplication order problems we had before, thus resulting in a undesired rotation of the object itslelf. That can be
adjusted with the center field which defines a position around the rotation will be calculated.

[TODO: verify this] 
For those of you who want to know what exactly happens: This is the way the final transformation matrix is calculated:

<PRE>
M = Translation * Center * Rotation * ScaleOrientation * Scale * -ScaleOrientation * -Center
</PRE>

\section TutorialNodeCoresMaterial Materials

We already had a short look at textures here: \ref TutorialBasicTutorial3. There are of cource a lot more possibilities than just to map an
image onto an object. Here you will find a more detailed overview about how to use materials in OpenSG. 

\subsection TutorialNodeCoresMaterialSimpleMaterial Simple Material

The Simple Material class provides an easy to use interface for materials without textures or other advanced fatures. It features all basic
attributes like diffuse and specular color, as well as transparency, emission, shininess ans ambien color. Here is an little example
of an red material that is 50% transparent and has a dark gray as ambient color

\code
SimpleMaterialPtr m = SimpleMaterial::create();

beginEditCP (m, SimpleMaterial::DiffuseColorFieldMask |
                SimpleMaterial::AmbientColorFieldMask |
                SimpleMaterial::TransparencyFieldMask);
                
    m->setDiffuse(Color3f(1,0,0));
    m->setAmbient(Color3f(0.2, 0.2, 0.2));
    m->setTransparency(0.5);

endEditCP   (m, SimpleMaterial::DiffuseColorFieldMask |
                SimpleMaterial::AmbientColorFieldMask |
                SimpleMaterial::TransparencyFieldMask);
\endcode


\image html red_transparent_material.png "50% transparent red Material on a sphere"
\image latex red_transparent_material.eps "50% transparent red Material on a sphere" width = 3cm

<I>
As you can see, there are artifacts on the sphere. You might know that transparent surfaces quickly get highly complicated to solve if some 
are occluding other transparent surfaces which is of course the case here. OpenSG can sort faces and render them from back to front (what is
actually needed to capture multi trancaprencies correctly) but OpenSG can do so only on the node level. That is sorting does not work within
a single node. 
</I>

<A HREF = "progs/07materials.cpp">progs/07materials.cpp</A> shows the implementation. Quite unsual might be the fact, that SimpleMaterial
is not derived from NodeCore and thus cannot be inserted as a core directly. 

One possibility is to use a material group. This class is nearly identical
to the usual group core but it has a setMaterial() method added with which you can assign a material to that core. Every node which is added
to the appropiate node containing such a core will be rendered with this material.

Another possibiliy is to set the material field in the geometry using setMaterial().

\subsection TutorialNodeCoresMaterialSimpleTexturedMaterial Simple Textured Material

You already saw simple textured material in action here : \ref TutorialBasicTutorial3. I will show some more interesting features in the next
tutorial!

\subsection TutorialNodeCoresMaterialChunks Chunks

A scene graph system is expected to do rendering as fast as possible. As I mentioned before, OpenGL state changes can be very expensive operations,
for example changing some color paramers of a material or light source. Loading and switching textures is even more expensive in most cases. 
Thus it is very important to handle these state changes in the most efficent way possible. It is very useful to group all primitives together 
which use the same set of OpenSG states. In addition to that is is necessary to minimize costs if the state is changed - i.e. changing only 
the diffuse color is more efficent than changing twelve states at once.

Of course that is not as easy as it sounds, unfortunately sorting all primitives in the most efficent manner is a NP-complete problem (If you are 
not familiar with complexity-therory: NP-complete problems are really, really bad). To simplify the problem OpenGL states that are usually changed
together have been grouped in larger pices : osg::StateChunks

[TODO: continue]

\section TutorialNodeCoresSwitch Switch

Switches are quite similar to switches in C++. You can add several children to a node with a switch core and depending on what you want to be
rendered you can tell the switch to render none, one specific or all of it's children. Please note that this behaviour is not restricted to 
rendering only but applies to every traversal of the graph. All children which are not selected by the switch are virtually cut off the graph 
until you change the setting of the switch.

The usage is very easy to handle. It behaves like a normal group node with some additional functionallity demonstarted in the next example

\code

SwitchPtr switch = switch::create();

//insert this sw into some node and add some children

beginEditCP(sw, Switch::ChoiceFieldMask);
    //select the second children to be rendered
    sw->setChoice(2);
    //please be careful not to select a non existend child
endEditCP(sw, Switch::ChoiceFieldMask);

//Switch::ALL or Switch::None would have selected all or no children

\endcode

\section TutorialNodeCoresLOD Level of Detail (LOD)

A must have feature for scene graph systems is the possibility to define some, often two or three, different models representing the same object
in different resolutions. The system will display one of the provided models depending on the distance from the user to the object. The 
advantage lies at hand: If you are close to the model it is rendered in high resolution thus details are well visible, if you are far
away the object is approximated by a handful polygons and thus saving memory and rendering time. The only problem occuring is when the actual 
swapping takes places. If the difference between the two models is too great the swap will be visible to the user. An idea is to morph 
dynamically between two of the key models, but OpenSG does not support morphing right know.
 
The usage of LOD cores is quite simple. Notice the class is called DistanceLOD and not LOD!

\code

DistanceLOD lod = DistanceLOD::create();
beginEditCP(lod);
    // this is supposed to be the center of the LOD modell,
    // that is, this is the point the ditance is measured to
    lod->setCenter(12,1,5);
    // now we add the distances when models will change
    lod->getMFRange()->push_back(6.0);
    lod->getMFRange()->push_back(12.0);
    lod->getMFRange()->push_back(24.0);
    
endEditCP(lod);
\endcode

The way we add the distance values might seem a bit unsual to you, but this is a very easy way to manipulate data if you are used to it. If you
want to refresh your knowledge about these multifield-things then just jump back to \ref BasicFieldContainerSingleMulti. The following figure
shows how the LOD object we just created works.

\image html lod.png "Example of a LOD setup"
\image latex lod.eps "Example of a LOD setup" width = 6cm

<I>
This figure illustrates how a level of detail object works. The numbers at the bottom are distances taken from the code example. These values are
of course highly depended on your environment, so these values may be totally useless for your application. You can see that the high detailed model
is rendered if the distance from the camera to the LOD center point is less than 6 units. Is the distance between 6 and 12 the medium resolution
model is rendered and so one. The lowest detailed model (in the case only a billboard) is rendered if the distance is greater than 24 units. Notice
that this is just one example, so the lowest detailed model must not be a billboard nor are you bound to four levels of detail - it is entirely up
to you. The polygon count given in the figure are rough possible values that would make sense in most cases, but they are no law!
</I>

\section TutorialNodeCoresTutorial Big Tutorial

Now it is finally time for a more exiting tutorial as we now have a basic knowledge of all the really most important aspects of OpenSG. What shall
we do this time? 

The fist thing we do is to setup a little LOD node containing three different levels of detail of a woman. These files are provided as VRML files
and can be found in the prog/data folder. As always, we choose <A HREF = "progrs/00framework.cpp">progs/00framework.cpp</A> as our starting point.

First of all add two new header files
<PRE>
    #include <OpenSG/OSGSceneFileHandler.h>
    #include <OpenSG/OSGDistanceLOD.h> 
</PRE>

Now replace the createScenegraph() method with following code

\code
NodePtr createScenegraph(){
    //At first we load all needed models from file
    NodePtr w_high = SceneFileHandler::the().read("data/woman_high.wrl");
    NodePtr w_medium = SceneFileHandler::the().read("data/woman_medium.wrl");
    NodePtr w_low = SceneFileHandler::the().read("data/woman_low.wrl");
    
    //we check the result
    if ((w_high == NullFC)&&(w_medium == NullFC)&&(w_low == NullFC)){
        std::cout 
            << "It was not possible to load all needed models from file" 
            << std::endl;
        return NullFC;
    }
    
    //now the LOD core
    DistanceLODPtr lod = DistanceLOD::create();
    beginEditCP(lod, DistanceLOD::CenterFieldMask | DistanceLOD::RangeFieldMask);
        lod->getSFCenter()->setValue(Pnt3f(0,0,0));
        lod->getMFRange()->push_back(200);
        lod->getMFRange()->push_back(500);
    endEditCP(lod, DistanceLOD::CenterFieldMask | DistanceLOD::RangeFieldMask);
    
    //the node containing the LOD core. The three models will be
    //added as its children
    NodePtr lodNode = Node::create();
    beginEditCP(lodNode);
        lodNode->setCore(lod);
        lodNode->addChild(w_high);
        lodNode->addChild(w_medium);
        lodNode->addChild(w_low);
    endEditCP(lodNode);
    
    NodePtr root = Node::create();
    beginEditCP(root);
        root->setCore(Group::create());
        root->addChild(lodNode);
    endEditCP(root);
    
    return root;
}

\endcode

You may now compile and execute this tutorial. When the window appears you will see the model of the woman. Right now the medium model is displayed
because our distance to the cener point (0,0,0) is between 200 and 500 units. If you move the camera closer (by holding right mouse button)
you can see how he model flips from medium to high resolution. The same happens of course if you move far away. The paramters were especially
choosen in that way, you can see the effect - in real life this is of course not what you want! Try to increase the range values by factor two or
three and you will not be able to see the flipping effect anymore.

Now lets us extend our little application with a switch. Under certain circumstances it could be useful to turn off the LOD object, but we do not
want to abandon the woman from our screen. We utilize a switch node which reacts to a specific key to switch between the LOD object and a "static"
version. Add the folowing code after the LOD node and before the root node is created

\code
    //create the node with switch core ********************
    SwitchPtr sw = Switch::create();
    beginEditCP(sw, Switch::ChoiceFieldMask);
        //Notice: the first choice is 0
        sw->setChoice(0);
    endEditCP(sw, Switch::ChoiceFieldMask);
    
    NodePtr switchNode = Node::create();
    beginEditCP(switchNode);
        switchNode->setCore(sw);
        switchNode->addChild(lodNode);
    endEditCP(switchNode);
    
    //end witch creation **********************************
\endcode

Now when the root node is created replace the line that says
<PRE>
    root->addChild(lodNode);
</PRE>
with
<PRE>
    root->addChild(switchNode);
</PRE>

The compiler needs to know two more include file:
<PRE>
    #include <OpenSG/OSGSwitch.h>
    #include <OpenSG/OSGSimpleAttachments.h>
</PRE>
The first should be obvious, the second is later needed to read names which were eventually assigned to nodes.

Now, if executed, everthing looks like it did before. We now want to add another copy of our highres model to our switch node. We could use
the scenefilehandler to load another instance of that file but that would be a waste of memory. A better aproach would be to simply reference the
geometry core by a second node, that is actually what the scenegraph is for. Unfortunately we have no appropiate GeometryPtr which points on 
our desired women mesh as we loaded it from file an got an NodePtr in return. So it is time for some fun and retrive that geometry from the
loaded graph.

What is our concern with that? well, if you construced the graph on your own, you have knowledge about where to find what. If you load models
from a file you cannot know what is all in there. This time we are lucky, because the model is not very complex. If we load it into a 3D software
like Studio Max or Cinema4D we can easily figure out that the name of the mesh (not the whole object) is "FACESET_woman". You can even figure that
out if you are reading the VRML file in a text editor - but do not expect that to work with huge and complex files!

As we know that our graph will consist of only a few nodes (probably not more than 20) we can be lazy when thinking about how to locate the
geometry node. So we will traverse the whole graph and check the name of every node if it matches the one we are looking for. Please notice that
you normally would do that by using traversal actions provided by OpenSG, but these will be discussed later in Chapter (xxx) so this time
we will do it by hand:

This method will search for a node called "FACESET_woman" starting with the node initially passed as argument

\code
// this function will return the node named "FACESET_Woman"
// if there is no such node NullFC will be returned
NodePtr checkName(NodePtr n){
    UInt32 children = n->getNChildren();
    
    //make sure a name existes
    if (getName(n))
        //check if it is the name we are looking for
        if (getName(n)== std::string("FACESET_Woman"))
            // We got the node!
            return n;
    
    //check all children
    for (int i = 0; i < children; i++){
        NodePtr r = checkName(n->getChild(i));
        if (r != NullFC)
            // if it is not NullFC it is the node we are looking for
            // so just pass it through
            return r;
    }
    // no children's name matches or there are no more childs
    // so return NullFC, indicating that the node was not found yet
    return NullFC;
}
\endcode

<I>
Maybe this function could use a bit more of explanation. It is a recursive function that will first check if the nodes name matches the (hardcoded)
search string, "FACESET_Woman" in this case. If that happen, this node is returned, else all children are checked the same way. If a node is
reached which is not the one we are looking for and it has no children then NullFC is returned, which is similar to a null-pointer. This function
ends up returning either the node named "FACESET_Woman" or NullFC.
</I>

Now we have the tools we searching, we just need to use them. Add this right before we leave the createScenegraph() function

\code
    // we know want to extract the mesh geometry out of the graph
    // it is sufficent to pass the model only as root for searching
    NodePtr womanGeometry = checkName(w_high);
\endcode
<I>
    It is possible, of course, to start searching from the root node, but this is not necessary as we know that the geometry is not to be found 
    outside the nodes used by our model. Additionally we have three different versions of this model loaded into our graph where every one has
    one such geometry node called FACESET_Woman. As we want only the one with high resolution we pass w_high as the starting point for the search
</I>

Well, we have now succesfully stored the correct node. Now we must extract the core out of the node. The following line of code, which has to 
be added directly after the last peace of code, does exactly that

\code
    GeometryPtr geo = GeometryPtr::dcast(womanGeometry->getCore());
\endcode
<I>
    This may look a little weird, but it's really not that bad. The getCore() method returns a "NodeCorePtr", which are all other core pointer
    classes are derived from. As we know that this specific node will contain geometry we can saftly cast it dynamically. As we will see later
    on it is not a big deal if you do not know which kind of core is stored in a node. OpenSG is reflective and thus you can obtain information
    about any core just by asking it (Chapter(xxx)). 
</I>

Finally we can now create a new node and reference the geometry core. We also want to translate the new node a bit in Order to see both of
the women. Insert this directly after the last line of code you just added.

\code
    //new node with "old" geometry core referenced
    NodePtr woman = Node::create();
    beginEditCP(woman);
        woman->setCore(geo);
    endEditCP(woman);
    
    //translate it a bit to see both women
    NodePtr womanTrans = Node::create();
    TransformPtr t = Transform::create();
    beginEditCP(t);
        Matrix m;
        m.setIdentity();
        m.setTranslate(Vec3f(0,0,200));
        t->setMatrix(m);
    endEditCP(t); 
    beginEditCP(womanTrans);
        womanTrans->setCore(t);
        womanTrans->addChild(woman);
    endEditCP(womanTrans);
    
    //add it to the root
    beginEditCP(root);
        root->addChild(womanTrans);
    endEditCP(root);
\endcode

<I>
After compiling and executing you can see that there are two identical models on your screen, but in a different color. How can that be? Materials
can be assigned directly to the geometry, but as I mentioned earlier, it is also possible to use a material group which assigns a material to all
its children without using the material field of the geometry. This is always the case when loading VRML files and this is therefore the reason why
we see two different materials on sceen. On the left side we have the original whereas on the right side we have the copied geometry with missing
information about a material because this was stored in one of the geometries parent nodes.
</I>

The next thing we want to add is a material for our woman copy. We won't use textures as we have already done that before, but we will use OpenSG
standard material.

Just add the code somewhere after we have defined the GeometryPtr geo

\code
    // generating a material *********************************
    
    SimpleMaterialPtr mat = SimpleMaterial::create();
    beginEditCP(mat);
        mat->setAmbient(Color3f(0.2,0.2,0.2));
        mat->setDiffuse(Color3f(0.6,0.3,0.1));
        mat->setSpecular(Color3f(1,1,1));
        mat->setShininess(0.8);
    endEditCP(mat);
    
    beginEditCP(geo, Geometry::MaterialFieldMask);
        geo->setMaterial(mat);
    endEditCP(geo, Geometry::MaterialFieldMask);
    
    // end material generation *******************************
\endcode

Now it is time to demonstrate the usage of the component transform core. We will a rotation, scalation and a tranlation at once and you will
see how easily these can be modified using a component transform core.

Fist create a new global variable
<PRE>
    ComponentTransformPtr ct;
</PRE>

Now add the following code directly before the root node is created in createScenegraph():

\code
// component transform ************************************
    NodePtr ctNode = Node::create();
    
    //this one is declared globally
    ct = ComponentTransform::create();
    beginEditCP(ct, ComponentTransform::TranslationFieldMask |
                    ComponentTransform::ScaleFieldMask |
                    ComponentTransform::RotationFieldMask);
    
        ct->setTranslate(Vec3f(0,0,200));
        ct->setScale(Vec3f(1,1,1));
        ct->setRotation(Quaternion(Vec3f(0,1,0),0));
        
    endEditCP(ct,   ComponentTransform::TranslationFieldMask |
                    ComponentTransform::ScaleFieldMask |
                    ComponentTransform::RotationFieldMask);
    
    beginEditCP(ctNode);
        ctNode->setCore(ct);
        ctNode->addChild(woman);
    endEditCP(ctNode);
    // end component transform ********************************
\endcode

We now need to integrate our new component transform into our scenegraph. As this one will replace the old translation you can delete the code
that creates the "normal" translation node. The application will still work if you leave it as it is, but this will result in useless code in your
program (We all know this problem, don't we...). 

For this to compile succesfully you need to add one more inlcude file
<PRE>
    #inlcude <OpenSG/OSGComponentTransform.h>
</PRE>

One thing still to do: change the child of the root node from the old transform node to the new one:
<PRE>
    root->addChild(ctNode);
</PRE>

After executing you will see that nothing visible has changed at all. Of course not, as the new component transform describes the same 
transformation as the one before. Well, to make it a bit more exciting we are going to modify the transformation every frame, which will 
show the advantages of the component transform.

We are gooing to let the user decide which kind of transformation will be applied. If he presses 's' a scalation will be applied, 't' is a 
translation whereas 'r' yields a rotation.

First we need two more global variables that will count the rendered frames so far and keeps track of the selected translation mode.
<PRE>
    UInt32 frame = 0;
    // 0 = translation
    // 1 = rotation
    // 2 = scalation
    UInt8 mode = 0;
</PRE>

Add a new callback functions to the registration in setupGLUT
<PRE>
    glutKeyboardFunc(keyboard);
</PRE>

And now add the keyboard function anywhere before the setupGLUT function

\code
void keyboard(unsigned char k, int x, int y){
    switch (k){
        case 't' : mode = 0; break;
        case 'r' : mode = 1; break;
        case 's' : mode = 2; break;
    }
}
\endcode

Finally exchange the display function with this code:

\code
void display(void)
{
    frame++;
    Real32 time = glutGet(GLUT_ELAPSED_TIME);
    
    beginEditCP(ct, ComponentTransform::TranslationFieldMask |
                    ComponentTransform::ScaleFieldMask |
                    ComponentTransform::RotationFieldMask);
    
        switch (mode){
            case 0 :
                ct->setTranslation(Vec3f(0,cos(time/2000.f)*100,200));
                break;
            case 1 :
                ct->setRotation(Quaternion(Vec3f(0,1,0), time/2000));
                break;
            case 2 :
                ct->setScale(Vec3f(cos(time/2000), sin(time/2000), tan(time/2000)));
                break;
            }
        
    endEditCP(ct,   ComponentTransform::TranslationFieldMask |
                    ComponentTransform::ScaleFieldMask |
                    ComponentTransform::RotationFieldMask);    
    
    mgr->redraw();
}   
\endcode
The final code can be found in file 08coresdemo3.cpp

<I>
You should really try the 's' key for scalation... nice isn't it. These strange effects occur, beacause we are using trigonometric functions which
will return zero periodically resulting in a reduction onto a plane if used for scalation. Actually if the argument (time/2000) becomes a multiple
of pi we have the scalation Vector (1,0,0) where the object is scaled down to a single line.
</I>

You see, that it is very easy and comfortable to edit parts of a transformation this way. If you would have used a standard transform core you
would have run into big trouble or you would have to store all three transformation parts seperatly and construct the final matrix every frame
by hand.

\section TutorialNodeCoresExercises Exercises

\subsection TutorialNodeCoresExercises1 Ex. Complete copy of the woman model


You might have noticed that when we were copying the geometry of the women, something was missing with the clone model. The eyes where not
copied. Why? They were not copied because the are a geometry node on their own, i.e. they are not contained in FACESET_woman. Figure out how
they are named and extend the search and copy function thus the eyes are correctly copied with the rest of the body.

<I>
Hint: To figure out the names, load the VRML file with a 3D modelling package or just read the file itself with a common text editor. 
It is really not that hard!
</I>

Next Chapter: \ref Geometry
*/

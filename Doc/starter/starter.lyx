#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass book
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
% \usepackage{a4}
\usepackage{babel}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\usepackage{color}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{setspace}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\float_placement htb
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4wide
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout LaTeX

% Create Title Page 
\layout LaTeX


\backslash 
singlespacing
\layout LaTeX


\backslash 
begin{titlepage}
\layout LaTeX


\backslash 
thispagestyle{empty}
\layout LaTeX


\backslash 
vspace*{
\backslash 
fill}
\layout LaTeX


\backslash 
begin{figure*}[htb] 
\layout LaTeX


\backslash 
begin{center} 
\layout LaTeX

% This breaks Postscript page numbers, include only when necessary
\layout LaTeX

%
\backslash 
includegraphics[height=3.5cm]{opensg_logo.eps} 
\layout LaTeX


\backslash 
end{center}
\layout LaTeX


\backslash 
end{figure*}
\layout LaTeX


\backslash 
begin{center} 
\layout LaTeX


\backslash 
vspace*{2cm}
\layout LaTeX


\backslash 
textbf{
\backslash 
Large OpenSG  }
\backslash 

\backslash 
[0.5
\backslash 
baselineskip] 
\layout LaTeX


\backslash 
textbf{
\backslash 
Large Starter Guide}
\backslash 

\backslash 
[2
\backslash 
baselineskip] 
\layout LaTeX


\backslash 
textbf{
\backslash 
Large Version 1.1.0}
\backslash 

\backslash 
[2
\backslash 
baselineskip] 
\layout LaTeX

Written by 
\backslash 

\backslash 
[
\backslash 
baselineskip] 
\layout LaTeX


\backslash 
textbf{
\backslash 
large Dirk Reiners 
\backslash 

\backslash 
 Johannes Behr 
\backslash 

\backslash 
 Gerrit Voss} 
\layout LaTeX


\backslash 
end{center}
\layout LaTeX


\backslash 
vspace*{
\backslash 
fill}
\layout LaTeX


\backslash 
end{titlepage}
\layout LaTeX


\backslash 
setcounter{page}{1}
\layout LaTeX


\backslash 
onehalfspacing
\layout LaTeX

\layout Standard


\lang american

\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Standard


\lang american

\begin_inset LatexCommand \listoffigures{}

\end_inset 


\layout Chapter

Introduction
\layout Standard

Welcome to the OpenSG starter guide.
 This document will help you understand the structure of the OpenSG system
 and the main classes that you need to know to write graphics programs using
 OpenSG.
 It started as a quick-start, but got a little big for that.
 ;) If you're not into reading text, take a look at the tutorial programs
 and come back when you need a little background for specific topics.
\layout Standard

It is not meant to be an introduction to computer graphics or real-time
 rendering.
 It would actually be useful to be somewhat familiar with another scene-graph
 system, but that's not mandatory.
\layout Standard

It does not explain every single function and its parameters, take a look
 at the Code documentation that is generated by doxygen for that.
 It will also not motivate the decisions taken and alternatives that were
 rejected, see the design document for that.
 This one is for jump-starting OpenSG usage.
\layout Standard

If you want to send feedback or have further questions you can send them
 either to the OpenSG developer list (
\family typewriter 
opensg-developer@lists.sf.net
\family default 
) or to us directly at 
\family typewriter 
feedback@opensg.org.
\layout Standard

This starter guide was written by the core team, but it wouldn't be what
 it is without the helpful reviews and comments by Marc Alexa and Patrick
 Dähne.
\layout Standard

This is for version 1.1.0, which is a developer release.
 Whcih menas that while we added a bunch of features, not a lot of documentation
 was changed.
 This will come for 1.2.
\layout Section

What is OpenSG?
\layout Standard

OpenSG is a real-time rendering system based on a scene-graph metaphor.
 It works along the lines of OpenInventor, Performer or Java3D, although
 it is probably closest to Performer.
 It supports parallel processing, albeit in a more general way, and will
 drive multiple displays for multi-screen stereo projection systems.
 The goal is to have something that handles multi-threaded data structures
 as simply as possible without compromising performance too much.
 It should also support heterogeneous multi-pipe applications, i.e.
 multiple different graphics cards running one application.
 Many things are quite easy to do with a little program, but are sometimes
 hard to fit into an existing system.
 Thus accessibility is an important goal, and we're striving to make OpenSG
 very extensible.
\layout Standard

It works on different Unix systems and Windows.
 It compiles with the Microsoft Visual Studio compiler, but that version
 has to use some extremely ugly kludges and is not always maintained, so
 using the Intel compiler, version 5.x, is recommended.
\layout Section

What is OpenSG not?
\layout Standard

OpenSG is not a complete VR system.
 Things like device access and interaction are left out on purpose, there
 are other systems for that.
\layout Section

Where to get it
\layout Standard

If you read this you probably have it already, otherwise take a look at
 http://www.opensg.org/ for the latest released version.
 You can also get it from SourceForge, which we use for project management,
 at http://www.sf.net/project/showfiles.php?group_id=5283.
\layout Standard

If you want to get access to the current development version you can get
 it from CVS, see http://sourceforge.net/cvs/?group_id=5283 for details.
 Nightly snapshots of the CVS source and libs are available at at www.opensg.org/d
ailybuild_logs.
\layout Section

Compilation
\layout Standard

Short version: 
\family typewriter 
./configure ; make
\family default 
 should work.
\layout Standard

Long version: OpenSG uses a relatively standard configure script to adapt
 the options it needs to the system it's compiled on.
 configure is also used to set up optional libraries that are available.
 For Windows you need to use the cygwin environment (http://sources.redhat.com/cyg
win/) to get the needed shell tools.
 There is a Visual Studio Workspace in 
\family typewriter 
Experimental/VS
\family default 
, but it is not actively maintained and thus probably out of date.
 We're working on an automatic way to create it, but right now you're probably
 better off with cygwin.
\layout Standard

Note that there are some constraints.
 You should install the Visual Studio and Intel compiler in their default
 locations (
\family typewriter 
...:
\backslash 
Program Files
\backslash 
...
\family default 
), otherwise the configure script will not find them.
 Mount the cygwin harddrive directly as 
\family typewriter 
/x
\family default 
, don't use 
\family typewriter 
/cygdrive/x
\family default 
.
 Install the GLUT in UNIX-style directories, i.e.
 
\family typewriter 
.../include/GL/glut.h
\family default 
 and 
\family typewriter 
.../lib/*dll+*lib
\family default 
, otherwise it won't be found.
 Note that you need to add the directory where the libs are created to your
 
\family typewriter 
PATH
\family default 
 or 
\family typewriter 
WINPATH
\family default 
 (or to the Windows environment variable 
\family typewriter 
PATH
\family default 
), or copy all the dlls to the directory where your programs are.
 Some of these will be lifted in the future, but that's the way it is right
 now.
\layout Standard

All options are optional.
 The most useful ones are 
\family typewriter 
--with-jpg[=<dir>]
\family default 
,
\family typewriter 
 --with-glut[=<dir>]
\family default 
, 
\family typewriter 
--with-qt[=<dir>]
\family default 
, 
\family typewriter 
--with-tif[=<dir>]
\family default 
 and 
\family typewriter 
--with-png[=<dir>]
\family default 
 which specify the directories where the specific libraries/header can be
 found.
 If you need to download these libraries, check http://www.opensg.org/prerequisite
s.EN.html for locations.
 All examples and tutorials use GLUT, so it's highly recommended to configure
 it.
 There are some other options that are less often needed, run 
\family typewriter 
configure --help
\family default 
 to get a full list.
\layout Standard

So for a standard Linux distribution you should call 
\family typewriter 
./configure --with-jpg --with-tif --with-png --with-qt=$QTDIR
\family default 
 to get a useful configuration.
\layout Standard

Configure creates a directory in Builds with a name specific for the current
 system, e.g.
 
\family typewriter 
Builds/i686-pc-linux-gnu-g++/
\family default 
.
 Go into this directory and call 
\family typewriter 
make
\family default 
 to create the libraries.
\layout Standard

In general you can call 
\family typewriter 
make help
\family default 
 in any directory with a makefile to get a list of supported targets in
 this directory.
\layout Standard

Not that OpenSG needs the GNU version of make.
 This is the default on Linux and Cygwin systems, so a simple 
\family typewriter 
make
\family default 
 is fine.
 On IRIX it's usually called gmake, if you don't have it you need to install
 it yourself.
 
\layout Section

System Structure
\layout Standard

The full OpenSG system consistes of several libraries.
 
\layout Standard

The Base library contains the low-level functions and basic classes like
 vectors and volumes.
 It also contains the operating system abstractions and the basic multi-threadin
g wrappers.
\layout Standard

The System library is the main library.
 It contains all the higher-level objects starting at the FieldContainer
 level.
 That includes all the scenegraph nodes and the actions to work on them.
 It includes the loaders for images and scene files, and the general window
 handling classes.
 In general, it includes everything the other libraries don't.
\layout Standard

For each window system that is supported there's a separate little library
 which contains the interface objects for that window system.
 Right now we have interfaces to X, WIN32, GLUT and QT.
\layout Section

Installation
\layout Standard

Call 
\family typewriter 
make install
\family default 
 to install the libraries in the place specified to 
\family typewriter 
configure
\family default 
, or 
\family typewriter 
/usr/local
\family default 
 per default.
 You can change the installation directory at install time by specifying
 it as 
\family typewriter 
make INSTALL_DIR=<dir> install
\family default 
.
 
\family typewriter 
make install
\family default 
 will copy all include files into a directory 
\family typewriter 
OpenSG
\family default 
 in 
\family typewriter 
$INSTALL_DIR/include
\family default 
 and the libs into 
\family typewriter 
$INSTALL_DIR/lib/dbg
\family default 
 or 
\family typewriter 
$INSTALL_DIR/lib/opt
\family default 
, depending on the optimization used.
 
\layout Standard

For a local install it's useful to use 
\family typewriter 
BUILD
\family default 
 as the prefix for configure, i.e.
 call configure 
\family typewriter 
--prefix=BUILD
\family default 
.
 This will install the system into the correct 
\family typewriter 
Builds/*
\family default 
 directory.
\layout Section

Making and executing the test programs
\layout Standard

To build the test programs, go into the 
\family typewriter 
BaseTest
\family default 
, 
\family typewriter 
SystemTest
\family default 
 etc.
 directories and call 
\family typewriter 
make
\family default 
 or 
\family typewriter 
make Tests
\family default 
.
 
\family typewriter 
make list
\family default 
 lists the available programs in the current directory.
 You can make a specific test program by running the listed command.
\layout Standard

To execute the test programs you need to have the OpenSG dynamic libraries
 in your library search path.
 For that it's easiest to locally install them as described before and call
 (csh/tcsh) 
\family typewriter 
setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:../lib/dbg
\family default 
 or (sh/bash) 
\family typewriter 
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:../lib/dbg
\family default 
.
 Then you can just run the test programs in the 
\family typewriter 
*Test
\family default 
 directory.
\layout Section

Making and executing the tutorials
\layout Standard

There are a number of tutorial examples in the tutorials directory.
 They are available in compiled form as a part of the binary distributions,
 but it is possible and probably the best way to start using OpenSG to change
 and recompile them.
\layout Standard

You need to make and install the libraries first.
 To actually create the tutorials on Unix just call 
\family typewriter 
make
\family default 
.
 For Windows there's a Visual Studio Workspace file in the binary distribution.
\layout Section

How to use it
\layout Subsection

Own projects
\layout Standard

OpenSG is just a library, so use it like any other library.
 
\layout Standard

It has an 
\family typewriter 
osg-config
\family default 
 script that emits the needed compiler options
\shape italic 
.
 
\shape default 
So you can call 
\family typewriter 
osg-config --cflags
\family default 
 to get the needed compiler options and 
\family typewriter 
osg-config --libs
\family default 
 to get the needed linker flags.
 You also need to tell it which of the available parts you want to use,
 so that it can include the needed flags for these, too.
 See 
\family typewriter 
tutorials/Makefile
\family default 
 for examples how to do that.
 
\layout Standard


\family typewriter 
osg-config
\family default 
 actually has some more options to support platofrm independence better,
 but these are the most important ones.
\layout Subsection

Extending OpenSG
\layout Standard

Extending OpenSG is generally trivial: just add your files to the directories,
 they will automagically be picked up by the next compile.
 
\layout Standard

Adding new directories is a little more tricky.
 You need to add your directory to 
\family typewriter 
CommConf/common.libs.in
\family default 
.
 This is not difficult, but hard to explain.
 If you need to do that, take a look at the file, try it and if it doesn't
 work send us an email or use the developer list on SourceForge.
\layout Standard

If you need new libraries you have to add them to the configure script .
 Copy some of the given examples or ask us for help.
\layout Standard

The following chapters introduce you to the main classes and concepts used
 in OpenSG.
 Again, they are not intended to explain every function and its parameters,
 see the doxygen documentation for that, and they are not meant to explain
 the reasons behind the design choices, see the design document for that.
\layout Chapter

OpenSG Basics
\layout Standard

All OpenSG symbols are part of the OSG name space, and they have no prefix.
 The actual files, including headers, all use the 
\family typewriter 
OSG
\family default 
 prefix.
\layout Section

Base types
\layout Standard

As one goal of OpenSG is the ability to run programs on a lot of different
 platforms, especially Unix and Windows, we have our own types which are
 guaranteed to have the same size on all platforms.
 
\layout Standard

We have our own bool type 
\family typewriter 
Bool
\family default 
, and signed and unsigned integers in all useful sizes: 
\family typewriter 
Int8
\family default 
, 
\family typewriter 
UInt8
\family default 
, 
\family typewriter 
Int16
\family default 
, 
\family typewriter 
UInt16
\family default 
, 
\family typewriter 
Int32
\family default 
, 
\family typewriter 
UInt32
\family default 
, 
\family typewriter 
Int64
\family default 
, 
\family typewriter 
UInt64
\family default 
 as well as the two usual float sizes 
\family typewriter 
Real32
\family default 
 and 
\family typewriter 
Real64
\family default 
.
 Some useful constant are available: 
\family typewriter 
Eps
\family default 
, 
\family typewriter 
Pi
\family default 
, 
\family typewriter 
Inf
\family default 
 and 
\family typewriter 
NegInf
\family default 
.
 A useful construct for template programming is the 
\family typewriter 
TypeConstants<type>
\family default 
 structure, which defines some standard functions/values for the given type,
 see 
\family typewriter 
OSGBaseTypes.h
\family default 
 for details.
\layout Section

Log
\layout Standard

All output that OpenSG generates is channeled through the Log class, which
 is defined in 
\family typewriter 
OSGLog.h
\family default 
.
 OpenSG supplies a global Log object that is used by the library, but the
 application can create its own logs, if needed.
\layout Standard

Every log message has one specific level.
 Available levels are 
\family typewriter 
FATAL
\family default 
, 
\family typewriter 
WARNING
\family default 
, 
\family typewriter 
NOTICE
\family default 
, 
\family typewriter 
INFO
\family default 
 and 
\family typewriter 
DEBUG
\family default 
.
 They are also numbered from 0 to 5.
 The verbosity of the system can be controlled by ignoring messages of specific
 levels.
 This can be achieved by calling 
\family typewriter 
osgLog().setLogLevel( <enum> );
\family default 
 or by setting the environment variable 
\family typewriter 
OSG_LOG_LEVEL
\family default 
.
\layout Standard

The system log has two different interfaces.
 One is based on C++ streams, one is based on C printf semantics.
 
\layout Standard

The stream interface can be used by using 
\family typewriter 
SFATAL
\family default 
, 
\family typewriter 
SWARNING
\family default 
, 
\family typewriter 
SNOTICE
\family default 
 or 
\family typewriter 
SINFO
\family default 
 instead of cout or cerr.
 Note that there is no 
\family typewriter 
SDEBUG
\family default 
 for efficiency reasons, as 
\family typewriter 
FDEBUG
\family default 
 can be compiled out.
 These print the position in the code where the log is executed.
 For multi-line outputs you'll only want that on the first line, for the
 other lines use 
\family typewriter 
PFATAL
\family default 
, 
\family typewriter 
PWARNING
\family default 
, 
\family typewriter 
PNOTICE
\family default 
 or 
\family typewriter 
PINFO
\family default 
.
 
\layout Standard

To synchronize multiple outputs from various threads all S* commands lock
 the stream.
 You have to use '
\family typewriter 
osg::endLog
\family default 
' (e.g.
 
\family typewriter 
SFATAL << 
\begin_inset Quotes eld
\end_inset 

Message
\begin_inset Quotes erd
\end_inset 

 << endLog;
\family default 
) to unlock the stream output.
 
\layout Standard

Example: 
\family typewriter 
SINFO << 
\begin_inset Quotes eld
\end_inset 

Line 1 of message 1
\begin_inset Quotes erd
\end_inset 

 << endl; PINFO << 
\begin_inset Quotes eld
\end_inset 

line2 of message 1
\begin_inset Quotes erd
\end_inset 

 << endLog; SINFO << 
\begin_inset Quotes eld
\end_inset 

Message 2
\begin_inset Quotes erd
\end_inset 

 << endLog;
\family default 
.
\layout Standard

The C interface tries to mimic the printf semantics.
 The following functions can be used for that: 
\family typewriter 
FFATAL
\family default 
, 
\family typewriter 
FWARNING
\family default 
, 
\family typewriter 
FNOTICE
\family default 
, 
\family typewriter 
FINFO
\family default 
 and 
\family typewriter 
FDEBUG
\family default 
.
 The only difference to 
\family typewriter 
printf
\family default 
 is that they have to be called with double parentheses, i.e.
 
\family typewriter 
FWARNING((
\begin_inset Quotes eld
\end_inset 

What do you mean by %s?
\begin_inset Quotes erd
\end_inset 

, s));
\family default 
.
 The nice thing about the C style interface is that the whole output can
 be compiled out.
 Actually, the 
\family typewriter 
FDEBUG
\family default 
 (( )) are only compiled in when 
\family typewriter 
OSG_DEBUG
\family default 
 is set.
 The 
\family typewriter 
OSG_DEBUG
\family default 
 define is automatically set while compiling the system in debug (default)
 mode.
\layout Standard

The user can activate/deactivate various elements per log message at runtime
 by changing the 
\family typewriter 
LogHeaderElem
\family default 
 mask.
 The following elements are supported right now: 
\layout Standard


\family typewriter 
LOG_BEGIN_NEWLINE_HEADER
\family default 
 (creates an extra newline in front of every output), 
\family typewriter 
LOG_TYPE_HEADER
\family default 
 (writes the Level (e.g.
 WARNING) as first element), 
\family typewriter 
LOG_TIMESTAMP_HEADER
\family default 
 (writes a timestamp), 
\family typewriter 
LOG_MODULE_HEADER
\family default 
 (writes the name of the current module), 
\family typewriter 
LOG_FILE_HEADER
\family default 
 (writes the source file name), 
\family typewriter 
LOG_LINE_HEADER
\family default 
 (writes the source line number) and 
\family typewriter 
LOG_END_NEWLINE_HEADER
\family default 
 (creates an extra newline at the end) 
\layout Standard

When unchanged, the time stamp will be the time in seconds since the program
 started.
 The user can set/reset the time stamp at any time (e.g.
 
\family typewriter 
osgLog().resetRefTime())
\family default 
.
\layout Section

Time & Date
\layout Standard

To wrap time and date handling we have a little abstraction for them.
 
\layout Standard


\family typewriter 
getSystemTime()
\family default 
 returns the current time since system has been started in seconds, using
 the highest resolution timer available.
\layout Standard

The Date class provides a second resolution time stamp, factored into second,
 minute, hour, day, month and year.
 Date::setSystemDate() can be used to set it to the current date/time.
\layout Section

Math
\layout Standard

Of course every scene-graph needs the basic math objects like Vectors, Points,
 Matrices, Quaternions etc., and OpenSG is no exception.
\layout Subsection

Matrices
\layout Standard

OpenSG matrices are similar to the OpenGL matrices in their storage structure
 and conventions, i.e.
 a matrix is per default a 4x4 
\family typewriter 
Real32
\family default 
 matrix, and the multiplication convention is just like OpenGL's: 
\begin_inset Formula \( v'=M*v \)
\end_inset 

.
 
\layout Standard

The matrix is stored column major and access methods respect the storage
 format, i.e.
 
\family typewriter 
matrix[0]
\family default 
 yields the first column.
 This is also true for the vector-based constructor.
 However, the constructor taking 16 single elements expects its parameters
 row-major like the matrix is written on paper.
\layout Standard

The positive side effect of this setup is the ability to access the base
 vectors of the matrix' coordinate space by accessing the vectors, i.e.
 
\family typewriter 
matrix[3]
\family default 
 is the translation to the origin of the local coordinate space.
 This is useful if you want to create your matrices from vectors, if you
 don't want to do that, don't worry about it.
\layout Standard

Setting the contents of a matrix is done by the 
\family typewriter 
setValues()
\family default 
 methods, accessing the values via the 
\family typewriter 
[]
\family default 
 operator for access to single columns or by using 
\family typewriter 
getValues()
\family default 
 to get a pointer to the first element.
 In general most classes in OpenSG that keep an array of elements allow
 access to them via 
\family typewriter 
getValues()
\family default 
.
\layout Standard

If you need to create a matrix for a specific transformation, use the 
\family typewriter 
setTransform()
\family default 
 methods, which create a matrix that executes the given transformation.
\layout Standard

Matrices also supply the standard set of matrix operations like 
\family typewriter 
det()
\family default 
, 
\family typewriter 
det3()
\family default 
, 
\family typewriter 
invert()
\family default 
, 
\family typewriter 
transpose()
\family default 
, 
\family typewriter 
mult()
\family default 
 and 
\family typewriter 
multLeft()
\family default 
.
 There are some variants that change the matrix in place, return their results
 in a different matrix or get their source data from a different matrix,
 see the class docs for details.
 
\layout Standard

The default vector/point multiplication methods 
\family typewriter 
multMatrixVec()
\family default 
 and 
\family typewriter 
multMatrixPnt()
\family default 
 assume that the matrix only uses the standard 3x4 elements.
 To use the full 4x4 matrix use 
\family typewriter 
multFullMatrixPnt()
\family default 
.
 As Vectors have a 
\begin_inset Formula \( w \)
\end_inset 

 coordinate of 0, compared to points which have 
\begin_inset Formula \( w=1 \)
\end_inset 

, they don't need a full transform.
\layout Subsection

Vectors/Points/Colors
\layout Standard

OpenSG is different from most other systems in differentiating between vectors,
 points and colors.
 
\layout Standard

Vectors are the most common class, and they should behave like every other
 vector library on the planet.
 They are templated to simplify having variants, and the standard ones that
 are available are 
\family typewriter 
Vec4ub
\family default 
, 
\family typewriter 
Vec2s
\family default 
, 
\family typewriter 
Vec2f
\family default 
, 
\family typewriter 
Vec3f
\family default 
 and 
\family typewriter 
Vec4f
\family default 
.
 They have operators for the scalar operations, and methods for everything
 else, see the doxygen docs for 
\family typewriter 
osg::VectorInterface
\family default 
 for details.
 Conceptually, the 3 element vector has a w coordinate of 0, thus there
 is no full matrix multiplication for vectors.
\layout Standard

Points represent positions in space, and as such they are more restricted
 than vectors.
 The available variants are 
\family typewriter 
Pnt2f
\family default 
, 
\family typewriter 
Pnt3f
\family default 
 and 
\family typewriter 
Pnt4f
\family default 
.
 Some vector operations (dot, cross, etc.) don't make sense for points.
 Points can be subtracted (creating a vector), scaled and a vector can be
 added to or subtracted from them.
 If you want to represent a position, use a point.
 It helps keeping the concepts in order and not mix up everything just because
 it has the same data.
 If you really need to get from a point to a vector, you can use 
\family typewriter 
Vector &osg::Point.toVector()
\family default 
 to cast the point to a vector.
 When multiplied with a matrix, the w coordinate is set as 1 for 3 element
 points.
 
\layout Standard

Colors are RGB vectors, which also have access functions to the named components.
 They also allow access via the HSV color model and scalar multiplication,
 but no other operations.
 
\layout Subsection

Quaternions
\layout Standard

Quaternions are the standard way to represent rotations.
 OpenSG quaternions feature the standard set of methods to get and set the
 rotations, in variants for radians and degrees.
 The standard order of the components is 
\family typewriter 
x
\family default 
,
\family typewriter 
y
\family default 
,
\family typewriter 
z
\family default 
,
\family typewriter 
w
\family default 
.
 The standard operations (
\family typewriter 
length
\family default 
, 
\family typewriter 
normalize
\family default 
, 
\family typewriter 
mult
\family default 
) are available, as well as 
\family typewriter 
slerp
\family default 
 and 
\family typewriter 
multVec
\family default 
.
\layout Section

Line 
\begin_inset LatexCommand \label{sec:line}

\end_inset 


\layout Standard

A Line defines a ray in space.
 It is defined by an origin and a direction, which is stored normalized.
 Lines can be constructed from two points or directly from a point and a
 direction.
 
\layout Standard

A line can be intersected with all the bounding volumes and geometry.
 Only the positive parameter range of the line is intersected.
\layout Standard

The line can also find the closest point on itself to a given point or another
 line.
\layout Section

Plane
\layout Standard

A Plane defines a 3D infinite half-space.
 It is defined by a normal and the distance from the origin, and can be
 constructed from all useful combinations of points and vectors.
\layout Standard

Planes can also be intersected with infinite lines, if needed.
 Points can be tested for lying on the plane, or being in the positive half-spac
e of the plane.
\layout Section

Volumes
\layout Standard

Volumes are primarily used for bounding geometry to speed up culling or
 intersection tests.
 All Volumes are derived from 
\family typewriter 
Volume
\family default 
.
 The supported volumes are the usual 
\family typewriter 
BoxVolume
\family default 
, defined by min and max points, the 
\family typewriter 
SphereVolume
\family default 
, defined by center and radius, and the 
\family typewriter 
FrustumVolume
\family default 
, which is defined by 6 planes and primarily used to define the viewing
 frustum.
\layout Standard

Volumes are created empty (i.e.
 zero volume) and can be changed by extending them by a point or another
 volume.
 All volumes have a variety of access functions, some specific to the type
 of volume, some general.
 Every volume supports 
\family typewriter 
getBounds()
\family default 
 to access the min/max points, 
\family typewriter 
getCenter()
\family default 
 and 
\family typewriter 
getScalarVolume()
\family default 
 to access the volume measure.
 Volumes can be intersected with points, lines and other volumes, and they
 can be transformed by a matrix.
\layout Standard

Volumes can be in one of several states.
 The default state is valid, special states are invalid, empty, infinite
 and static.
 There are specific functions to set them to any one of those states and
 to check if they are in any of those states.
\layout Standard

Invalid volumes have to be set to valid explicitly, before extending them
 has any effect.
 
\family typewriter 
setEmpty()
\family default 
 makes it valid implicitly.
 The states except empty define how extensions and intersections are handled.
 Invalid volumes stay invalid and ignore changes, static and infinite volumes
 keep their values and are not changed by extensions.
 Intersecting an infinite volume is always true, just as intersecting an
 empty volume is never true.
 
\layout Section

Threads
\layout Standard

OpenSG supports a thread abstraction to support efficient threading on all
 supported platforms.
 On Windows that means Windows threads, on Irix sproc() is used, for every
 other system pthreads are used.
\layout Standard

Every thread uses a 
\family typewriter 
Thread
\family default 
 object for thread-specific data, most of which is needed for thread-safe
 data, see 
\begin_inset LatexCommand \ref{threadsafety}

\end_inset 

.
 To create a new thread, the Thread object has a 
\family typewriter 
run()
\family default 
 method, which executes a given function in a new thread.
 
\layout Standard

For thread synchronization 
\family typewriter 
Lock
\family default 
 and 
\family typewriter 
Barrier
\family default 
 objects are available.
 They act like standard locks and barriers, see the doc for details.
\layout Section

Image
\begin_inset LatexCommand \label{sec:image}

\end_inset 


\layout Standard

Defines and holds a 1D/2D/3D image and optionally a mipmap pyramid and/or
 a list of equally sized frames with a single frameDelay.
 Various pixelTypes are supported to handle gray and RGB color images with
 or without alpha channel.
 The image data starts in the lower left (front) corner and all bytes for
 a single pixel (e.g.
 RGB) are stored sequentially in memory.
 They are not organized in separate layers or channels.
 
\layout Standard

An Image is only a container for the pixel data and image description.
 It does not create or handle any OpenGL state elements.
 However, image objects are utilized to handle the data for texture (e.g.
 SimpleTextureMaterial) or bitmap objects (e.g.
 ImageForeground).
 
\layout Standard

The system provides loaders and writers for various formats (see section
 
\begin_inset LatexCommand \ref{imageLoaderSection}

\end_inset 

).
 The graph loaders (e.g.
 OSGLoader, VRMLLoader) use image loaders to fetch the raster data.
 
\layout Section

IDString
\layout Standard

A primitive string class.
 Mainly used for string IDs (e.g.
 node type names).
 It is not a generic class like the std::string implementation.
 It's only for internal use to built efficient maps for names, not for applicati
on use.
 If you need a string class use std::string instead.
 
\layout Standard

We decided to create our own specific string class since the std::string
 did not provide all features we needed (e.g.
 shared memory pointer, automatic preferred pointer comparison when comparing
 objects)
\layout Section

Functors
\layout Standard

Functors are the main method for OpenSG to call configurable actions.
 Functors wrap calls to a standard function, to a member of a specific instance
 or to a member of the first parameter.
 
\layout Standard

Functors will have to be redesigned for 1.1, as they don't compile using
 the Microsoft Visual Studio compiler.
 :( Thus we don't talk much about them here, if you need to add a new action
 or GL object, send us mail.
\layout Chapter

Fields and FieldContainers
\begin_inset LatexCommand \label{sec:Fields_and_FieldContainer}

\end_inset 


\layout Standard

One central goal in OpenSG's design is easy to use thread-safe data.
 To do that right, you need to replicate the data so that every thread can
 have its private copy (called aspect) to work on.
 At some point these different copies will have to be synchronized, and
 then the parts that actually changed need to be copied from one aspect
 to another.
 To do that, the system needs to know what actually changed.
 As C++ is not reflective, i.e.
 the classes cannot tell the system which members they have, OpenSG needs
 to keep track of the changes.
 That's what Fields and FieldContainers are for.
\layout Section

Creating a FieldContainer instance
\begin_inset LatexCommand \label{fcinstance}

\end_inset 


\layout Standard

FieldContainer can be created in two ways: By using the 
\family typewriter 
FieldContainerFactory
\family default 
 or from the class's prototype.
 You cannot create instances of FieldContainers neither by creating automatic
 or static variables nor by calling 
\family typewriter 
new
\family default 
.
 You have to use the mentioned two ways.
\layout Standard

For generic loaders it is useful to create an object by name, and this is
 what the factory is for.
 The factory is a singleton, the single instance can be accessed via 
\family typewriter 
FieldContainerFactory::the()
\family default 
, which has functions to create arbitrary field containers, with some special
 versions to directly create different subsets of field containers (Nodes,
 NodeCores, Attachments).
\layout Standard

For reasons connected to multi-threading (s.
 
\begin_inset LatexCommand \ref{threadsafety}

\end_inset 

) specific kinds of pointers have to be used.
 For every FieldContainer type 
\family typewriter 
fc
\family default 
 there is a specific pointer type 
\family typewriter 
fcPtr
\family default 
.
 It has all the features of a standard pointer, i.e.
 it can be dereferenced via 
\family typewriter 
->
\family default 
 and it can be downcasted to a derived type by 
\family typewriter 
DerivedPtr.dcast( ParentPtr );
\family default 
.
\layout Standard

Creating a new instance of a specific class is done by calling 
\family typewriter 
fcPtr var=fcPtr::create()
\family default 
.
 
\layout Section

Reference counting
\layout Standard

FieldContainers are reference-counted.
 They are created with a reference count of 0, and the reference count can
 be manipulated through 
\family typewriter 
addRefCP()
\family default 
 and 
\family typewriter 
subRefCP()
\family default 
.
 
\layout Standard

The system increases the reference count only when it stores a reference
 to an object in the system, e.g.
 when a node is attached to another node.
 It does not increase the reference counter for every parameter that is
 passed around, the pointers mentioned in 
\begin_inset LatexCommand \ref{fcinstance}

\end_inset 

 are not smart pointers.
\layout Standard

The reference count is decreased when an object is removed from the system,
 e.g.
 when a node is detached from another node, or explicitly using 
\family typewriter 
subRefCP()
\family default 
.
 If the reference count goes to or below 0, the object is removed.
 Note that objects are created with a reference count of zero, so if a new
 object (refCnt: 0) is attached to a node (increasing the refCnt to 1) and
 removed later on (decreasing it to 0), it will be destroyed.
 Increasing the reference count before removing it is needed to prevent
 the destruction.
\layout Section

Manipulation
\layout Standard

The FieldContainer is the basic unit for multi-thread safety.
 To synchronize changes between different copies of the data the system
 needs to know when and what changed.
 
\layout Standard

This has to be done explicitly by the program.
 Thus, before changing a FieldContainer 
\family typewriter 
beginEditCP(fcPtr, fieldMask);
\family default 
 has to be called.
 After the changes to the FieldContainer are done this also has to be communicat
ed by calling 
\family typewriter 
endEditCP(fcPtr, fieldMask);
\family default 
.
 Here,
\family typewriter 
 fcPtr
\family default 
 is the pointer to the FieldContainer being changed, 
\family typewriter 
fieldMask
\family default 
 is a bit mask describing the fields that are changed.
 
\layout Standard

Every FieldContainer defines constants for all its fields that can be used
 to set up this mask.
 The naming convention is 
\family typewriter 
<FieldContainer>::<FieldName>FieldMask
\family default 
, e.g.
 
\family typewriter 
Geometry::PositionsFieldMask
\family default 
.
 These masks can be 
\family typewriter 
or
\family default 
-ed together to create the full mask of fields that are changed.
\layout Section

Fields
\layout Standard

All data in FieldContainers is organized in fields.
 There are two general types of fields, fields for single values (SFields)
 and fields for multiple values (MFields).
 For the standard types and most pointer and ptr types there are predefined
 instances of both types of fields.
\layout Subsection

Single Fields
\layout Standard

Single fields hold, as the name says, a single value.
 Their content can be accessed directly using 
\family typewriter 
getValue();
\family default 
 and 
\family typewriter 
setValue();
\family default 
.
 It can also be copied from another field of the same type by 
\family typewriter 
setValue();
\family default 
 (for fields of the same type) or by 
\family typewriter 
setAbstrValue();
\family default 
 (for fields which have the same type, but are given as an abstract field).
\layout Subsection

Multi Fields
\layout Standard

Multi fields hold multiple values.
 They are realized as STL vectors and offer a similar interface.
 The field defines types for iterators and references, and the standard
 
\family typewriter 
begin()
\family default 
, 
\family typewriter 
end()
\family default 
, 
\family typewriter 
front()
\family default 
, 
\family typewriter 
back()
\family default 
, 
\family typewriter 
push_back()
\family default 
, 
\family typewriter 
insert()
\family default 
, 
\family typewriter 
erase(), clear()
\family default 
, 
\family typewriter 
size()
\family default 
, 
\family typewriter 
resize(),
\family default 
 
\family typewriter 
reserve()
\family default 
 and other functions.
\layout Standard

In addition, Multi fields have an interface reminiscent of single fields.
 It features the 
\family typewriter 
setValue()
\family default 
 variants mentioned above and indexed variants like 
\family typewriter 
getValue(const UInt32 index)
\family default 
 and 
\family typewriter 
setValue(const FieldTypeT &value, const UInt32 index)
\family default 
 methods.
 It also features an OpenSG-style 
\family typewriter 
getSize()
\family default 
 method.
\layout Subsection

FieldContainer Fields
\layout Standard

Each attribute has a name, e.g.
 
\family typewriter 
someValue
\family default 
, and every field container has a set of standard access functions to access
 its fields.
 The field itself can be accessed via 
\family typewriter 
getSFSomeValue()
\family default 
 or 
\family typewriter 
getMFSomeValue()
\family default 
 for single or multiple value fields respectively.
\layout Standard

For SFields containers features 
\family typewriter 
getSomeValue()
\family default 
 and 
\family typewriter 
setSomeValue()
\family default 
 direct access methods.
 The MField 
\family typewriter 
getSomeValue()
\family default 
 method returns the whole field, just like the 
\family typewriter 
getMFSomeValue()
\family default 
 method.
 Some field containers have more access functions, often something like
 an 
\family typewriter 
addSomeValue()
\family default 
 method to simplify adding data to multi fields.
 See the field container docs for details.
\layout Section

Nodes and NodeCores
\layout Standard

Of course the most important structures in a scene-graph are the actual
 nodes that make up the graph.
\layout Standard

OpenSG uses a somewhat different approach than many other systems.
 A node is split into two parts: the 
\family typewriter 
Node
\family default 
 and a 
\family typewriter 
NodeCore
\family default 
 (s.
 fig 
\begin_inset LatexCommand \ref{singleParentFig}

\end_inset 

), both of which are FieldContainers, so all that has been said before applies
 to them.
\layout Standard

A 
\family typewriter 
Node
\family default 
 keeps the general information: a children list, a parent pointer, a bounding
 volume and a core pointer.
 Note that the node itself contains no information about its type (e.g.
 transform, group, etc.).
 A 
\family typewriter 
Node
\family default 
 cannot be shared, every node can only be at one place in the graph, thus
 a single parent pointer is enough.
 All nodes together define the topology of the graph, without defining any
 content.
 Actions that depend on a position in the graph, like accessing the accumulated
 matrix to the world coordinate system or the world bounding volume, have
 to be done on the node, as it uniquely defines and identifies the position
 in the graph.
\layout Standard

A 
\family typewriter 
NodeCore
\family default 
 carries the differentiating information for a node.
 There are 
\family typewriter 
NodeCore
\family default 
s for all the different functions needed in the tree: groups, transformations,
 geometry and many more.
 
\family typewriter 
NodeCore
\family default 
s can be shared between different nodes, thus they keep an array or actually
 a MultiField of 
\family typewriter 
Node
\family default 
 pointers.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 238 304
file node_core_share.eps
width 4 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{singleParentFig}

\end_inset 

Single Parent Scene
\end_float 
\layout Section

FieldContainer attachments
\layout Standard

OpenSG field containers and nodes do not feature an unused pointer to attach
 data, usually called user data in other systems.
 Instead, many field containers feature a map to attach specific kinds of
 field containers called attachments.
 The most important ones are 
\family typewriter 
Node
\family default 
s and 
\family typewriter 
NodeCore
\family default 
s, but many other like 
\family typewriter 
Window
\family default 
, 
\family typewriter 
Viewport
\family default 
, 
\family typewriter 
Camera
\family default 
, etc.
 are derived from 
\family typewriter 
AttachmentContainer
\family default 
 and, therefore, can carry attachments.
\layout Standard

Attachments have to be derived from 
\family typewriter 
Attachment
\family default 
 (see 
\begin_inset LatexCommand \ref{sec:creating_new_fcs}

\end_inset 

 for details how to do that).
 There are also predefined attachments, right now the only one is 
\family typewriter 
NameAttachment
\family default 
, which allows assigning a name to the field containers.
\layout Standard

Every 
\family typewriter 
AttachmentContainer
\family default 
 can hold an arbitrary number of attachments.
 Attachments are divided into separate groups, and there can be only one
 attachment of every group attached to an AC.
 Most attachments are a group, but if needed new ones can be used as replacement
s for their parents.
\layout Section

Data separation & Thread safety
\begin_inset LatexCommand \label{threadsafety}

\end_inset 


\layout Standard

One of the primary design goals of OpenSG is supporting multi-threaded applicati
ons.
 For asynchronous threads that means that every thread might need its private
 copy of the data.
 To combine that with easy usability and efficient access we decided to
 replicate at the field container level.
 
\layout Standard

When a field container is created not only one instance is created but multiple,
 per default 2.
 These are called aspects, and every running thread is associated with one
 of them.
 Whenever data is changed in a thread, only the aspect that's associated
 with it is changed, the rest is left as is.
\layout Chapter

Special Node Cores
\layout Standard

NodeCores define the specific behavior of the scene-graph nodes.
 Note that we refer to the combination of a Node and the respective NodeCore
 with the core's name, i.e.
 a Group node is a Node with a Group NodeCore.
\layout Section

Group
\layout Standard

A Group is the simplest NodeCore, it doesn't do much.
 If asked to do something it calls its children to do the same thing, if
 asked for information it gathers it from the children.
 Really basic.
\layout Section

Switch
\layout Standard

A Switch node allows to select one of its children for traversal instead
 of all of them (as for the other nodes).
\layout Section

Transform
\layout Standard

A Transform Core is the basic means of moving objects around the scene.
 It keeps a single Matrix that is applied to all its children.
\layout Section

ComponentTransform
\layout Standard

A ComponentTransform is close to a Transform, but the transformation is
 defined in an easier to use way, the same way it is done in systems like
 OpenInventor or VRML.
 It consists of a center and a rotation around that center, followed by
 a scale relative to a given scaleOrientation, which is finally followed
 by a translation.
\layout Section

DistanceLOD
\layout Standard

Levels of Detail are a simple way of increasing rendering performance.
 The basic idea is to have a number of differently detailed versions of
 an object and use low-res versions for objects that are far away.
 
\layout Standard

A DistanceLOD is the simplest version, which switches versions based on
 distance to the viewer.
 There is a distance associated with every child of the Node, the details
 follow the VRML specification.
\layout Section

Lights
\layout Standard

A Light defines a source of light in the scene.
 Generally, two types of information are of interest: The position of the
 light source (geometry), and what elements of the scene are lit (semantics).
 Since the graph structure essentially describes the semantics of the scene,
 the node containing the Light describes what is lit: The subgraph attached
 to the Light.
 Necessarily, the position in space of a Light has to be defined by other
 means than the accumulated transform to the Light's node as the subgraphs
 position and orientation might coincide with the light source's.
\layout Standard

To define the position and orientation of the light a separate node, a 
\shape italic 
beacon
\shape default 
, is used.
 The light has a SFNodePtr to reference the beacon, which can be anywhere
 in the scene.
 A light is positioned in the coordinate system of the beacon.
 Tip: Using the beacon of the camera (see 
\begin_inset LatexCommand \ref{sec:camera}

\end_inset 

) as the beacon of a light source creates a headlight.
\layout Standard

Every light is closely related to OpenGL's light specification.
 It has a diffuse, specular and ambient color.
\layout Standard

Additionally it can be switched on and off using the 
\family typewriter 
on
\family default 
 field.
\layout Subsection

DirectionalLight
\layout Standard

The DirectionalLight just has a direction.
 To use it as a headlight use (0,0,-1) as a direction.
\layout Subsection

PointLight
\layout Standard

The Pointlight has a position to define its location.
 In addition, as it really is located in the scene, it has an attenuation
 parameters to change the light's intensity depending on the distance to
 the light.
\layout Subsection

SpotLight
\layout Standard

The SpotLight adds a direction to the PointLight and a spotCutOff angle
 to define the area that's lit.
 To define the light intensity fallof within that area the spotExponent
 field is used.
\layout Section

Geometry
\layout Standard

Geometries make up the leaves of the graph and ultimately define what's
 being rendered.
 Geometry has to be flexible, to accommodate the needs of the application.
 Different data types for the data that defines the geometry are useful,
 as well as different indexing capabilities to reuse data as much as possible.
 On the other hand, it also has to be efficient to render.
 Flexibility and performance don't always go well together, thus, there
 are some simplifications to make.
\layout Standard

OpenSG geometry is modeled closely following OpenGL.
 The data that make up the geometry are stored in separate arrays.
 Positions, Colors, Normals and Texture Coordinates all have their own arrays,
 (or MultiFields, to stay in OpenSG terminology)).
 As OpenGL can handle a lot of different formats for the data, some of which
 might be more appropriate due to speed and memory consumption than others,
 depending on the application, OpenSG features different version of this
 data, allowing all the variants that OpenGL allows.
 To allow that with type safety and without having a separate geometry class
 for every possible combination the data fields are stored in separate field
 containers, so called GeoProperties.
 There are separate GeoProperties for different attributes, and variants
 for different data types for each kind of GeoProperty.
 The most prominent types are probably 
\family typewriter 
GeoPositions3f
\family default 
 for 
\family typewriter 
Pnt3f
\family default 
 positions, 
\family typewriter 
GeoNormals3f
\family default 
 for 
\family typewriter 
Vec3f
\family default 
 normals, 
\family typewriter 
GeoColors3f
\family default 
 for 
\family typewriter 
Color3f
\family default 
 colors and 
\family typewriter 
GeoTexCoords2f
\family default 
 for 
\family typewriter 
Vec2f
\family default 
 texture coordinates, but all other variants are possible.
 
\layout Standard

As properties only have a single field they can mimic that field by exposing
 parts of the standard MultiField interface for their contents, so you can
 use a GeoProperty pretty much just like a MultiField.
 One problem with the type variety is that writing functions that work on
 every type of property can become tedious, as you have to have a big switch
 for every kind of data that could arrive.
 To make that easier for every property there is defined generic format,
 e.g.
 for Positions the format is Pnt3f.
 A property has a getValue()/setValue() interface for these generic types,
 i.e.
 every property, no matter in what format it stores the data, can be used
 as if it used the generic format.
 Of course, this is not as efficient as directly accessing the data, but
 if speed is not the highest priority or as a fall-back it's quite useful.
 And, finally, GeoProperties feature an interface for OpenGL vertex arrays,
 giving access to the data and the types involved, which is used for rendering.
\layout Standard

In addition to the above-mentioned data there are some other GeoProperties.
 OpenSG allows multiple primitive types per geometry, i.e.
 you can freely mix triangles, triangle strips and polygons in a single
 geometry node.
 The GeoPTypes property defines the type of the primitives used.
 Right now, it only exists as a GeoPTypesUI32 variant, but others may follow.
 The number of vertices per primitive is defined by another property, the
 GeoPLengths property.
 This, too, only exists in a GeoPLengthsUI32 variant right now.
 
\layout Standard

Using these properties it is possible to define geometry (see fig.
 
\begin_inset LatexCommand \ref{fig:geo_non_indexed}

\end_inset 

).
 Note that OpenSG inherits the constraints and specifications that concern
 geometry from OpenGL.
 Vertex orientation is counterclockwise when seen from the outside, and
 concave polygons are not supported.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 476 225
file geo_nonindexed.eps
width 3 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:geo_non_indexed}

\end_inset 

Non-Indexed Geometry
\end_float 
One additional advantage of separating properties from Geometry is the ability
 to share properties between geometry NodeCores.
 As geometries can only have one material right now that's useful for simplifyin
g the handling of objects with multiple materials.
\layout Standard

This simple geometry has one problem: there is no way to reuse vertex data.
 When a vertex is to be used multiple times, it has to be replicated, which
 can increase the amount of memory needed significantly.
 Thus, some sort of indexing to reuse vertices is needed.
 You can guess what's coming? Right, another property.
\layout Standard

Indices are stored in the GeoIndices property, which only exists in the
 GeoIndicesUI32 variant right now.
 When indices are present the given lengths define how many indices are
 used to define the primitive, while that actual data is indexed by the
 indices (see fig.
 
\begin_inset LatexCommand \ref{fig:geo_indexed}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 476 225
file geo_indexed.eps
width 3 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:geo_indexed}

\end_inset 

Indexed Geometry
\end_float 
Indexed geometry is very close to OpenGL, and probably the most often used
 type of geometry.
 It doesn't handle all the cases, though.
\layout Standard

Sometimes vertices need different additional attributes, even though they
 have the same position.
 One example are discontinuities in texture coordinates, e.g.
 when texturing a simple cube.
 The edges of the cube don't necessarily use the same texture coordinate.
 To support that a single indexed geometry has to replicate the vertices.
\layout Standard

To get around that you need multiple indices per vertex to index the different
 attributes.
 Adding an index for every attribute would blow up the geometry significantly
 and not necessarily make it easier to use.
 We decided to use another way: interleaved indices (see fig.
 
\begin_inset LatexCommand \ref{fig:geo_multi_index}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 476 212
file geo_multiindexed.eps
width 3 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:geo_multi_index}

\end_inset 

Multi-Indexed Geometry
\end_float 
Interleaved indices require every vertex to hold multiple indices.
 Which index is used for what attribute is defined by a separate indexMapping
 field.
 The indexMapping field is a UInt32 MultiField.
 The possible values are bitwise combinations of the available attribute
 masks: Geometry::MapPosition, Geometry::MapNormal etc.
 The length of the indexMapping defines how many indices are used per vertex.
 If it's not set a single index for all available properties is used (or
 none at all).
\layout Standard

In addition to the properties geometry keeps a MaterialPtr to define the
 material that's used for rendering the geometry (see sec.
 
\begin_inset LatexCommand \ref{sec:materials}

\end_inset 

) and a flag that activates caching the geometry in OpenGL display lists.
 As geometry rendering is not optimized very much right now that's the best
 way to get decent performance.
 Display lists are turned on by default.
\layout Subsection

Geometry Iterators
\layout Standard

The above setup is very nice and flexible to define: you can mix different
 kinds of primitives in an object, you can have properties and different
 kinds and the indexing allows the reuse of some or all of the data.
\layout Standard

From the other side of the fence things look difficult: if you want to walk
 over all triangles of a geometry to calculate the average triangle size
 or the surface area, or for calculating face normals or for whatever reason
 you have to take care of all the flexibility and be prepared for lots of
 different ways to define geometry.
\layout Standard

To simplify that the concept of a geometry iterator has been introduced.
 A geometry iterator allows to iterate over a given geometry primitive by
 primitive, face by face (a face being a triangle or quad), or triangle
 by triangle.
 
\layout Standard

All of them are used like STL iterators: the geometry has methods to pass
 the first or last+1th iterator (
\family typewriter 
begin()
\family default 
 and 
\family typewriter 
end()
\family default 
) , and to step from one element to the next use 
\family typewriter 
++
\family default 
.
 They can also unify the different indices: when using an iterator you can
 access the index value for each attribute of each vertex of the iterator
 separately.
 Or you can directly access the data that's behind the index in its generic
 form.
 
\layout Standard

If you're used to having a separate Face object that keeps all the data
 for a separate face, the Iterators pretty much mimic that behavior.
 The one thing you can't do using iterators is changing the data.
\layout Standard

The 
\family typewriter 
PrimitiveIterator
\family default 
 is the basic iterator that just iterates through the 
\family typewriter 
GeoPTypes
\family default 
 property and gives access to the primitive's data.
 It is useful to solve the index mapping complications and to get access
 to the generic data, but it's primarily a base class for the following
 two iterator types.
\layout Standard

The 
\family typewriter 
FaceIterator
\family default 
 only iterates over polygonal geometry and ignores points and lines.
 It also splits the geometry into triangles or quads.
 
\layout Standard

The 
\family typewriter 
TriangleIterator
\family default 
 behaves like the 
\family typewriter 
FaceIterator
\family default 
, but it also splits Quads into two triangles, thus it does an implicit
 triangulation.
 As OpenSG just like OpenGL doesn't support concave geometry that's not
 as hard as it sounds.
\layout Standard

The iterators can also be used to indicate a specific primitive/face/triangle.
 Each of these has an associated index that the iterator keeps and that
 can be accessed using 
\family typewriter 
getIndex()
\family default 
.
 A new iterator can be used to 
\family typewriter 
seek()
\family default 
 a given primitive/face/triangle again and work on it.
 This is used for example in the 
\family typewriter 
IntersectAction
\family default 
.
\layout Chapter

Materials
\begin_inset LatexCommand \label{sec:materials}

\end_inset 


\layout Standard

Materials define the surface properties of the geometry.
 For the standard Phong lighting model that OpenGL uses these are ambient,
 diffuse and specular color as well as shininess.
 However, this is an area where extensions are added at an amazing pace.
 The purpose of materials is to add a level of abstraction and give the
 user an easy to use interface to define surface properties without having
 to worry about how to realize this.
\layout Standard

Thus, every geometry needs to have a material associated with it by means
 of the 
\family typewriter 
material
\family default 
 field.
\layout Standard

This area is quickly expanding, so what we have right now is just the beginning.
\layout Section

Material types
\layout Standard

Right now there are only the simple materials that OpenGL supports.
 
\layout Subsection


\family typewriter 
SimpleMaterial
\layout Standard


\family typewriter 
SimpleMaterial
\family default 
 is a pretty direct mapping from OpenGL.
 It has colors for 
\family typewriter 
ambient
\family default 
, 
\family typewriter 
diffuse
\family default 
, 
\family typewriter 
specular
\family default 
 and 
\family typewriter 
emission
\family default 
 properties, and a 
\family typewriter 
shininess
\family default 
 value.
 In addition to that it has a 
\family typewriter 
transparency
\family default 
 setting, ranging from 0 for opaque to 1 for fully transparent.
 
\layout Standard

There are two other attributes in a 
\family typewriter 
SimpleMaterial
\family default 
 that control the appearance of an object.
 One is the 
\family typewriter 
lit
\family default 
 attribute, which defines if the material is influenced by light sources
 at all.
 If it isn't, the color is directly taken from the 
\family typewriter 
diffuseColor
\family default 
 component and other color attributes are ignored.
 
\layout Standard

The other attribute is the 
\family typewriter 
colorMaterial
\family default 
 field, which defines how colors that are given in the geometry influence
 the lighting calculation.
 By default they replace the diffuse color only.
 Possible values are taken from the 
\family typewriter 
glColorMaterial()
\family default 
 call, the most useful being 
\family typewriter 
GL_DIFFUSE_AND_SPECULAR
\family default 
.
 One possible value that is not used by 
\family typewriter 
glColorMaterial()
\family default 
 is 
\family typewriter 
GL_NONE
\family default 
, which switches off the color material handling and thus ignores colors
 that are given in the geometry.
\layout Subsection


\family typewriter 
TexturedSimpleMaterial
\layout Standard


\family typewriter 
TexturedSimpleMaterial
\family default 
 is derived from 
\family typewriter 
SimpleMaterial
\family default 
 and adds a texture.
 The texture is defined by an image (see 
\begin_inset LatexCommand \ref{sec:image}

\end_inset 

 for details on how to define or load an image).
 
\layout Standard

Additionally there are some parameters to define the behavior of a texture.
 
\family typewriter 
magFilter
\family default 
 and 
\family typewriter 
minFilter
\family default 
 define how to scale the texture image up or down, legal values taken from
 
\family typewriter 
glTexParameter()
\family default 
.
 The most useful ones are 
\family typewriter 
GL_NEAREST
\family default 
 or 
\family typewriter 
GL_LINEAR
\family default 
 for 
\family typewriter 
magFilter
\family default 
, and additionally 
\family typewriter 
GL_LINEAR_MIPMAP_LINEAR
\family default 
 for 
\family typewriter 
minFilter
\family default 
.
 
\layout Standard


\family typewriter 
envMode
\family default 
 defines how a color from the texture is combined with a color from the
 lighting calculation.
 The default is 
\family typewriter 
GL_REPLACE
\family default 
 which completely ignores the lighting color.
 Other useful values are 
\family typewriter 
GL_MODULATE
\family default 
, which just multiplies the two, and 
\family typewriter 
GL_DECAL
\family default 
, which interpolates between lighting and texture based on the texture's
 alpha channel.
\layout Standard

Finally, a texture can be used as a spherical environment map to simulate
 a reflective object by setting the 
\family typewriter 
envMap
\family default 
 field to 
\family typewriter 
true
\family default 
.
 Spherical environment maps need to display the image of a reflective sphere
 in the middle of the environment that is being reflected.
 
\layout Chapter

Action and Traversals
\layout Standard

Creating the scene-graph is just the first step, and not really useful in
 itself.
 Something needs to be done with it.
 Actions on the graph usually take the form of a traversal which goes through
 the nodes one by one and calls an appropriate action for each one on the
 way.
\layout Standard

These are called Actions in OpenSG, and there are a number of predefined
 actions:
\layout Itemize

Render
\layout Itemize

Intersect
\layout Section

Usage
\layout Standard

Actions use the same syntax for creating as actions that FieldContainers
 use, as they also use a prototype for that.
 Thus you need to call 
\family typewriter 
ActionType::create
\family default 
 to get a new one.
 They are not FieldContainers, though, so simple pointers are OK.
\layout Standard

To execute an action on a graph you apply it to the graph (
\family typewriter 
action->apply(graph);
\family default 
) or to a list of nodes (
\family typewriter 
action->apply(vector<NodePtr>::iterator begin, vector<NodePtr>::iterator
 end);
\family default 
).
\layout Section

RenderAction
\layout Standard

RenderAction is the primary means of transforming the scene-graph into an
 image.
 It does view volume culling and state sorting by building a draw tree.
 It also handles transparent objects by rendering them last and back to
 front sorted.
 Put simple it does what a decent scene-graph needs to do.
 
\layout Standard

To use it just create one and pass it to the OpenSG 
\family typewriter 
Window
\family default 
 object (see sec.
 
\begin_inset LatexCommand \ref{sec:window}

\end_inset 

).
\layout Standard

It is possible to turn the view volume culling off using the 
\family typewriter 
setFrustumCulling
\family default 
() method.
 For debugging it is possible to turn the frustum update off (
\family typewriter 
setAutoFrustum(
\family default 
)) and to make the system render the tested bounding volumes (
\family typewriter 
setVolumeDraw()
\family default 
).
\layout Section

IntersectAction
\layout Standard


\family typewriter 
IntersectAction
\family default 
 is used for sending rays into the scene and retrieving the first object
 hit.
 Right now, intersection testing is not very optimized, which is OK for
 selecting an object, but probably too slow for programmatic use.
\layout Standard

A ray is defined by a 
\family typewriter 
Line
\family default 
 (see sec.
 
\begin_inset LatexCommand \ref{sec:line}

\end_inset 

) and optionally a maximum distance.
 It can either be set at construction time or by 
\family typewriter 
setLine()
\family default 
.
 To test the ray for intersection, apply the action to the root of the possible
 intersection objects.
\layout Standard

If the ray hits an object 
\family typewriter 
didHit(
\family default 
) will return true.
 In that case, detailed info about what was hit and where can be accessed
 through 
\family typewriter 
getHitT()
\family default 
, 
\family typewriter 
getHitPoint()
\family default 
, 
\family typewriter 
getHitObject()
\family default 
 and 
\family typewriter 
getHitTriangle()
\family default 
.
\layout Section

Simple Traversal
\begin_inset LatexCommand \label{sec:simple_traversal}

\end_inset 


\layout Standard

Actions are somewhat complicated to derive and, furthermore, they manage
 callback functors on a 
\family typewriter 
NodeCore
\family default 
 basis.
 Sometimes it's easier to just define a function that is called for every
 node in a graph.
 That's what 
\family typewriter 
traverse()
\family default 
 is for.
\layout Standard


\family typewriter 
traverse()
\family default 
 takes a 
\family typewriter 
NodePtr
\family default 
 to define the graph and a functor to define the function to be called for
 every node as parameters.
 The functor just gets the traversed node as a parameter 
\layout Section

Write your own action handler
\layout Standard

Don't.
 Actions are being completely redesigned for 1.1 to become more flexible
 and clean.
 Use the available actions and try to stay with the 
\family typewriter 
traverse()
\family default 
 function (see 
\begin_inset LatexCommand \ref{sec:simple_traversal}

\end_inset 

) for now.
 
\layout Standard

If you really need to do your own action take a look at 
\family typewriter 
IntersectAction
\family default 
, it shows what you need to implement.
 Talk to us before you do it, though, maybe the redesign is already usable
 so you can base your new stuff on that.
\layout Chapter

Window
\begin_inset LatexCommand \label{sec:window}

\end_inset 


\layout Standard

Windows are the general connection between OpenSG and the windowing system
 used by the application/platform.
 OpenSG itself does not open its own windows, that has to be done by the
 application.
 Using GLUT it's pretty trivial, take a look at the tutorial examples on
 how to do that.
 For other window systems its a little more work, but the goal is to have
 wrapper classes for the usual GUI toolkits like QT, Motif etc.
 that simplify the task.
 We have one for QT, 
\family typewriter 
OSGQGLManagedWidget
\family default 
, and are interested in similar ones for other Window systems.
\layout Section

Window
\layout Standard

A 
\family typewriter 
Window
\family default 
 is the connection between OpenSG and the window system used.
 There are variants for different supported window systems like X, WIN32,
 GLUT and QT.
 The OpenSG 
\family typewriter 
Window
\family default 
 object handles OpenGL context creation and activation/deactivation, and
 needs to be informed about resizes.
 It manages OpenGL objects like display lists and texture objects and is
 also responsible for OpenGL extension detection and functions.
\layout Standard

It doesn't do any input event handling or similar things, it's only for
 output and keeping the Viewports that fill the window and keep all the
 rendering parameters.
 See sec.
 
\begin_inset LatexCommand \ref{sec:simplescenemanager}

\end_inset 

 for an easy-to-use wrapper for setting these up.
 
\layout Section

Viewport
\layout Standard

A Viewport is a part of the window that is being rendered into.
 It can cover the whole window, but doesn't have to.
 The size of the viewport is defined by its left, right, bottom and top
 coordinates, given in OpenGL conventions, i.e.
 the bottom of the screen has the vertical coordinate 0.
 
\layout Standard

If the value is bigger than 1, it's a position in pixel.
 That's independent of the window size, if the window is smaller, parts
 of the viewport will be cut, if it's bigger parts of the window will not
 be covered.
 If they are between 0 and 1 (inclusively) they are relative to the window
 and are rescaled when the window is resized.
 If they are -1 they use the extreme applicable value, i.e.
 0 for left and bottom, 1 for right and top.
 For relative sizes the actual value used for right and top is 
\family typewriter 
value * size - 1
\family default 
.
 This allows abutting viewports by using the same relative values for right
 and left of the viewports that should fit.
 See fig.
 for an example.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 238 308
file viewports.eps
width 4 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:viewports}

\end_inset 

Viewports in differently sized windows
\end_float 
\layout Standard

To define what is being rendered a viewport stores the root node of the
 scene to be displayed, the camera to use and the background and foregrounds.
\layout Section

Camera
\begin_inset LatexCommand \label{sec:camera}

\end_inset 


\layout Standard

A camera defines the parts of the scene that are actually being rendered.
 The definition can be split in two parts: location and direction, and internal
 parameters.
\layout Standard

Position and orientation of the camera are defined by a node in the scene-graph,
 a beacon, similarly to the definition used by light sources.
 The camera uses the OpenGL defaults for specifying the used coordinate
 system, i.e.
 the camera looks along the negative Z coordinate, X points to the right
 and Y is up.
 Thus, to use a camera you need a beacon node in the scene to define its
 position.
 This can be an object you want to attach the camera to, but in general
 you'll probably have a Transform node somewhere close to the root to handle
 it.
\layout Standard

This gives full flexibility to use a simple matrix to define camera position
 and orientation, but can be tedious to specify.
 Many systems use a from-at-up convention to define camera parameters, i.e.
 you specify a viewer position, a point that should be in the center of
 the screen and the direction that should be up on the screen.
 The 
\family typewriter 
MatrixLookAt
\family default 
 functions from 
\family typewriter 
OSGMatrixUtility.h
\family default 
 can convert these settings into a matrix that can directly be used to specify
 the camera.
\layout Standard

The internal parameters of the camera can vary between different kinds of
 cameras.
 The only constant thing that a camera for OpenGL needs are the near and
 far clip distances, which are defined in the general Camera class.
 The others are defined in the specific camera classes.
\layout Subsection

Perspective Camera
\layout Standard

The standard camera used for OpenGL rendering is a perspective camera.
 The only additional attribute it has is the vertical field of view, in
 radians.
 The horizontal field of view is automatically adjusted to the window size
 to create a square aspect ratio.
\layout Section

Background
\layout Standard

A background defines how the window is cleared before anything is rendered.
 There are a couple of different backgrounds.There can be only one background
 per viewport.
\layout Subsection


\family typewriter 
SolidBackground
\layout Standard


\family typewriter 
SolidBackground
\family default 
 is the simplest variant, it just fills the background with a single color
 given in its 
\family typewriter 
color
\family default 
 field.
\layout Subsection


\family typewriter 
GradientBackground
\layout Standard


\family typewriter 
GradientBackground
\family default 
 fills the background with a color gradient.
 To specify the gradient a color has to be associated with a vertical position
 in the window (0 being at the bottom, 1 being at the top).
 The 
\family typewriter 
addColor()
\family default 
 method should be used for that.
\layout Section

Foreground
\layout Standard

A foreground can be used to render something on top of the scene-graph image.
 There can be an arbitrary number of active foregrounds.
 Right now the only foreground is 
\family typewriter 
ImageForeground
\family default 
.
\layout Subsection


\family typewriter 
ImageForeground
\layout Standard

ImageForeground renders images on top of the scene-graph image.
 The typical use is adding a logo to the image.
 
\layout Standard

Images have to be loaded as 
\family typewriter 
Image
\family default 
s, their position has to be defined as a 2D position in the 
\begin_inset Formula \( [0,1]x[0,1] \)
\end_inset 

 range and given to the 
\family typewriter 
addImage()
\family default 
 function.
\layout Section

SimpleSceneManager
\begin_inset LatexCommand \label{sec:simplescenemanager}

\end_inset 


\layout Standard

The SimpleSceneManager (SSM) is a utility class to simplify the creation
 of simple applications.
 It manages a single window with a single viewport and a minimal scene-graph
 with a beacon for the camera and a headlight.
 It keeps a Trackball to interactively manipulate the camera.
\layout Standard

It does not open a window itself, that is left to the user to keep the SSM
 useful for arbitrary window systems.
 The window has to be passed to the SSM by using 
\family typewriter 
setWindow()
\family default 
.
 That's one half of the necessary initialization.
 It can't handle input itself, the application has to pass it user input
 events.
 It's a lot simpler than it sounds, take a look at the tutorials to see
 how it works.
\layout Standard

The other half of the necessary initialization is telling SSM what to draw
 by calling 
\family typewriter 
setRoot()
\family default 
.
 That's it.
 It might be useful to call 
\family typewriter 
showAll()
\family default 
 to position the camera at a reasonable position, but that's not mandatory.
\layout Standard

The SSM can be used in conjunction with any window system, it has been integrate
d into an easy-to-use QT widget called 
\family typewriter 
OSGQGLWidget
\family default 
.
 See testManagedWindowQT_qt.cpp for an example on how to use it.
\layout Standard

As a little bonus, SSM can display the 
\begin_inset Quotes eld
\end_inset 

Powered by OpenSG
\begin_inset Quotes erd
\end_inset 

 logo.
 Just call 
\family typewriter 
useOpenSGLogo()
\family default 
 and you're done.
 ;)
\layout Chapter

Loader
\layout Standard

As OpenSG user/developer you can always instantiate all your nodes, cores
 or whatever objects you need one by one in your application code.
 
\layout Standard

In addition OpenSG also provides - as most scene-graph libraries - a set
 of loaders, which create a scene tree or image from a given file.
 The system creates singleton Handlers for both types (
\family typewriter 
SceneFileHandler
\family default 
 and 
\family typewriter 
ImageFileHandler
\family default 
), which handle all abstract requests.
 The concrete loaders are coded in mime/file type handlers (e.g.
 
\family typewriter 
OSGTIFImageFileType.h/OSGTIFImageFileType.cpp
\family default 
) and are automatically registered.
 
\layout Standard

The system architecture is designed to handle built-in types and to fetch
 loaders for a specific type on request.
 In the current version (1.0) only built-in types are provided since the
 meta interfaces may not be final yet.
 However the 1.0 version comes with a sufficient set of built-in loaders
 and you can always extend the library to handle you own file format.
\layout Section

Usage
\layout Standard

You can always use a specific loader directly, but in most cases you would
 ask the Handler (e.g.
 
\family typewriter 
SceneFileHandler
\family default 
) to load a file independent of the file type.
 There is always just one handler (it is a singleton object) you can access
 the object using the static 
\family typewriter 
the()
\family default 
 method (e.g.
 
\family typewriter 
osg::SceneFileType::the()
\family default 
).
 The Handler knows all the valid suffixes for every mime/file type and can
 pick the correct loader automatically.
 
\layout Standard

If you would like to get a loader for a specific type or suffix you can
 just ask the handler to find it (e.g.
 
\family typewriter 
SceneFileHandler::the().getFileType(
\begin_inset Quotes eld
\end_inset 

wrl
\begin_inset Quotes erd
\end_inset 

)
\family default 
).
\layout Subsection

Scene
\layout Standard

The Scene Handler provides two interfaces to load a scene: 
\family typewriter 
read
\family default 
 (returns a single root node or 
\family typewriter 
NullFC
\family default 
 on failure) or 
\family typewriter 
readTopNodes
\family default 
 (does not create an extra root but returns all top nodes ).
 
\layout Standard

Just use the Handler to find and use the correct type for the given suffix:
 
\family typewriter 
osg::NodePtr rootPtr = osg::SceneFileTypeSceneFileHandler::the().read(
\begin_inset Quotes eld
\end_inset 

test.wrl
\begin_inset Quotes erd
\end_inset 

)
\family default 
 for example would pick the VRML loader (suffix is 
\begin_inset Quotes eld
\end_inset 

wrl
\begin_inset Quotes erd
\end_inset 

), parse the file and return the result.
 
\layout Subsection

Image
\begin_inset LatexCommand \label{imageLoaderSection}

\end_inset 


\layout Standard

The image loader works more or less the same way as the scene loader.
 Let the singleton handler pick the mime type and just check the return
 value: 
\family typewriter 
osg::ImageFileHandler::the().read(
\begin_inset Quotes eld
\end_inset 

test.tif
\begin_inset Quotes erd
\end_inset 

) 
\family default 
for example would pick the tif loader (suffix 
\begin_inset Quotes eld
\end_inset 

tif
\begin_inset Quotes erd
\end_inset 

 ), start loading the file, and return the new 
\family typewriter 
Image
\family default 
 or 
\family typewriter 
Null
\family default 
.
\layout Section

Write our own
\layout Standard

For every new mime/file you have to write a new 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

Type
\begin_inset Quotes erd
\end_inset 


\family default 
 class (e.g.
 
\family typewriter 
FooImageType.h/FooImageType.cpp
\family default 
).
 Every Type is handled as a singleton object and must provide a 
\family typewriter 
the()
\family default 
 method to access the static instance.
 The class must be derived from the base Type (e.g.
 
\family typewriter 
ImageFileType
\family default 
) to be registered.
 You don't have to register the new type in any extra class.
 Just included it in the OpenSG source tree and it should work with the
 Handler.
\layout Subsection

Scene
\layout Standard

Since scene loaders are usually more complex and require sometimes some
 extra library they have extra directories for their sources (e.g.
 
\family typewriter 
OpenSG/Loader/WRL
\family default 
).
 To write your own scene handler perform the following steps:
\layout Enumerate

Create a new directory for your mime type (e.g.
 
\family typewriter 
OpenSG/Loader/FOO
\family default 
)
\layout Enumerate

Copy the code from a simple loader (e.g.
 
\family typewriter 
Loader/RAW
\family default 
)
\layout Enumerate

Change the file file/class name to match your type.
\layout Enumerate

Change the _suffixA values in the *.cpp file (e.g 
\family typewriter 
{
\begin_inset Quotes eld
\end_inset 

foo
\begin_inset Quotes erd
\end_inset 

}
\family default 
 ), you can includes as many valid suffixes as you want
\layout Enumerate

Write the 
\family typewriter 
read() 
\family default 
methods to load your type
\layout Enumerate

configure/make opensg libs
\layout Subsection

Image
\layout Standard

Image loaders are usually not too complex.
 They usually just use some external library (e.g.
 tifflib) to load the image data.
 Since the extra lib is usually not included in the opensg source tree we
 do not store the code in an extra, mime type specific directory.
 They are all stored in 
\family typewriter 
OpenSG/Image.
 
\layout Standard

To write you own image loader perform the following steps:
\layout Enumerate

Copy the code from a simple loader (e.g.
 
\family typewriter 
Image/PNMImageFileType.*
\family default 
)
\layout Enumerate

Change the file file/class name to match you type.
\layout Enumerate

Change the _suffixA values in the *.cpp file (e.g 
\family typewriter 
{
\begin_inset Quotes eld
\end_inset 

foo
\begin_inset Quotes erd
\end_inset 

}
\family default 
 ), you can includes as many valid suffixes as you want
\layout Enumerate

Change the 
\family typewriter 
getMimeType() 
\family default 
method in *.h to return the new mime type.
\layout Enumerate

Write the 
\family typewriter 
read()/write() 
\family default 
methods to load/write your type
\layout Enumerate

configure/make opensg libs
\layout Chapter

Creating new Field Types
\layout Standard

All the data that is kept in FieldConatiners has to be in Fields.
 Fields provide the interface for the reflecivity and generic access methods
 to work.
 They come in the two known variants single and multi field.
 To simplify creating new field types, they do not have to created explicitly.
 Instead there are templates SField and MField who take care of the implementati
on.
 All you need to provide is a Trait structure that defines the types needed
 and some type-specific functions.
\layout Standard

Note that field types for new FieldContainers (actually pointers to FieldContain
ers, as you can't instantiate them) can be created by fcdEdit automatically.
 So if you need fields for pointers to your containers, you don't have to
 follow the descriptions in this section.
\layout Standard

The trait has to be a concrete version 
\shape italic 
\color red
(What's the right name for this?)
\shape default 
\color default
 of FieldDataTrait<class type> and has to provide the following functions/types:
\layout Itemize

a DataType _type; which is used to uniquely identify the Field's type
\layout Itemize

an access method for the type: DataType &getType(void)
\layout Itemize

two methods to return the names of the field types: Char8 *getSName(void)
 and Char8 *getMName(void).
 The names are usually created by capitalizing the type name and prepending
 SF or MF, e.g.
 the matrix field names are SFMatrix and MFMatrix.
\layout Itemize

a method to get a default object to initialize the values: type getDefault(void).
\layout Itemize

two methods to convert a data element to and from a string: Bool getFromString(t
ype &outVal, const Char8 *&inVal); and void putToString(const type &inVal,
 string &outVal);.
 Note that these are optional in the sense that the system will work without
 them, but some important features will not work without them, so it's highly
 recommended to implement them.
\layout Itemize

In any case, if they are implemented or not, this has to be announced by
 adding an anonymous enum value for StringConvertable which can be a binary
 combination of ToStringConvertable and FromStringConvertable.
\layout Standard

Note that all functions have to be static, as the Trait class is not instanced,
 and that the Trait cannot have any virtual functions or data memebrs.
 It is not used to create actual objects, it's just a convenience container
 for the needed types/functions.
\layout Standard

The fields also need to be able to store themselves in a binary form.
 If the data structures used are contiguous in memory and don't use pointers
 this can easily be accomplished by deriving the FieldDataTrait<class type>
 from FieldTraitsRecurseBase<type>.
 It will copy the contents of the data types verbatim and back.
\layout Standard

This approach will not work as soon as there are pointers in the new structures,
 even simple things like STL vectors will not work that way.
\layout Standard

In these cases you need to implement the binary interface in the trait.
 It consists of three method, which exist for single and multiple elements
 of the type:
\layout Itemize

a method to calculate the size of the packed object: UInt32 getBinSize(const
 type &object); 
\layout Itemize

a method to put the object into a binary block: void copyToBin(BinaryDataHandler
 &mem, const type &object);
\layout Itemize

a method to receive the object from a binary memory block: void copyFromBin(Bina
ryDataHandler &mem, type &object);
\layout Standard

The last two methods work via a BinaryDataHandler, which abstracts a memory
 block.
 
\layout Chapter

Creating new FieldContainer classes
\begin_inset LatexCommand \label{sec:creating_new_fcs}

\end_inset 


\layout Standard

Most developers who use OpenSG as a scene-graph library will probable never
 create their own OpenSG FieldContainer classes.
 Similar to widget libs (e.g.
 qt, gtk) people just use instances (the widgets) but never create new classes.
 
\layout Standard

However, you can always extend the type system of OpenSG to integrate new
 cores (e.g.
 a fancy LOD switch) or application specific FieldContainers.
\layout Standard

FieldContainers are the system's central mechanisms to deal with any kind
 of thread safe data (see section 
\begin_inset LatexCommand \ref{sec:Fields_and_FieldContainer}

\end_inset 

).
 Therefore, the class declaration must include various extra meta information
 for the field and FieldContainer type handling.
 
\layout Standard

In most systems (e.g.
 Inventor), you would probably start writing a new class or node by just
 'copy and paste'-ing an existing implementation.
 However, since OpenSG needs all this extra meta data it is not a simple
 but very error prone process to create the field container source by hand.
 Instead, we provide a graphical tool to create and manage the FieldContainer
 description and implementation.
\layout Standard

The basic idea is that you use the 'field container description editor'
 ($OSGROOT/tools/fcdEdit) to create an XML file including the description
 of your FieldContainer fields and interfaces (see image 
\begin_inset LatexCommand \ref{fcdEditFig}

\end_inset 


\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 267 177
file fcd.eps
width 4 90
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fcdEditFig}

\end_inset 

FcdEdit
\end_float 
 ).
 The tool is also able to create all necessary C++ source files.
 The FieldContainer code is split into classes (e.g.
 for a Foo FieldContainer: FooBase and Foo).
 This strategy has various advantages:
\layout Description

Type 
\series bold 
system changes
\series default 
: If the OpenSG core team decides to change the code interface for the FieldCont
ainer type management we can just recreate the base classes from the XML
 description.
 No adaptations 'by hand' are needed.
\layout Description

Interface 
\series bold 
changes
\series default 
: If you would like to change the interface of your FieldContainer (e.g.
 add another field) later on you can just re-edit the XML file in fcdEdit
 and recreate the base classes.
 All necessary access methods are created automatically.
\layout Section

XML Description (Foo.fcd)
\layout Standard

Includes all field and meta descriptions for a single FieldContainer.
 Can be read and written by the fcdEdit tool.
 You should only change it by hand when you're sure of what you're doing.
 
\layout Section

Field Types (FooFields.h)
\layout Standard

Include the field and pointer declarations the the FieldContainer to be
 used in other FieldContainers as reference.
 You should not change the file by hand.
\layout Section

Base/Meta Type (FooBase.h, FooBase.inl, FooBase.cpp)
\layout Standard

Holds all the meta and field information.
 Do not change it by hand.
 Use the fcdEdit tool to create the files anew whenever you change the XML
 description.
 
\layout Section

'User Code' implementation (Foo.h, Foo.inl, Foo.cpp)
\layout Standard

Holds the 'user code'.
 The fcdEdit is able to create a skeleton for your FieldContainer implementation.
 The code does not include any meta information, therefore, it is not necessary
 to create it anew whenever you change the interface.
 
\layout Standard

Include new action handlers or whatever you need as functionality.
 
\layout Section

Prototype Replacement
\layout Standard

If you create a replacement for a system component, e.g.
 a smarter DistanceLOD node that can handle predictive LOD selection, and
 want the system to use your version of the DistanceLOD from now on you
 can do that.
 Internally all field container instances are created by cloning a prototype
 instance.
 You can access the prototype for a given FieldContainer via its class type
 which you can access using FC::getClassType().
 The class type has a setPrototype() method to assign the prototype.
 
\layout Standard

Be careful to only replace the prototype with classes derived from the original
 class, or the behavior of the system is undefined.
\layout Section

Initialization / Deinitalization
\layout Standard


\series bold 
\size larger 
\color red
GV: please check if this is correct
\layout Standard

As OpenSG uses object replication for thread-safe data, constructors and
 destructors are not always the right place for initialisation and deletion
 anymore.
 They are called for every aspect, which usually is more than once.
 For initialisation that should be done only once per object, the onCreate()
 method can be used.
 Similarly, onDestroy() is called once, when the object is destroyed.
\layout Standard

There is also a difference between the constructors.
 The copy constructor is called for every aspect of an object, the default
 constructor is only called once, during the static init phase, to create
 the initial prototype instance for the class.
 As code running in the static init phase faces some restrictions (e.g.
 the order of initializations is undefined, thus any other object might
 not yet have been initialized) a saver way to do class-global initializations
 was added.
 The initMethod() method is called during osgInit(), which is after all
 static inits are done.
\layout Standard

As a summary here's a list of when which method is called:
\layout Itemize

default constructor: once, during static init, to create the initial prototype
\layout Itemize

initMethod(): once, during osgInit()
\layout Itemize

copy constructor: during object instance creation, once for every aspect
\layout Itemize

onCreate(): during object instance creation, once
\layout Itemize

onDestroy(): during object instance deletion, once
\layout Itemize

destructor: during object instance deletion, once for every aspect
\layout Standard

onCreate() and on Destroy() are also called for the initial prototype creation.
 Not all prototypes might need the resources a real instance needs, and
 initial prototype creation is run during static init, where it might not
 be safe to access other classes.
 To allow a destinction between prototype creation and the standard running
 state of the system there's a global variable GlobalSystemState, which
 will be set to Startup during static init and Running after osgInit() is
 finished.
 During osgExit() it will be set to Shutdown.
\layout Standard


\latex latex 

\backslash 
begin{appendix}
\layout Chapter

Code Style
\layout Standard

We have a pretty tightly specified code style.
 The style has developed during the project, and not all code has been kept
 up-to-date with respect to the style.
 That will be fixed over time.
 
\layout Standard

But we're not religious about all the details.
 There are some basic rules that we would like code to be integrated into
 OpenSG to follow.
 See the OpenSG TWiki at http://opensg.sf.net/twiki/ for all the details.
\layout Section

Classes & Methods
\layout Standard

Classes should use nouns for names, methods should use the verb[adjective]noun
 convention.
 OpenSG uses a getValue()/setValue() convention for the data access interface,
 it would be good to follow that.
 Adding other interfaces is of course possible, but to reduce user surprise
 the standard one would be good.
\layout Section

Indents & Formatting
\layout Standard

This is an area of long and hard struggles, and everybody has his/her own
 comments.
 There are some things we expect to keep the code somewhat readable.
\layout Standard

Don't use Tabs for indenting, use spaces instead.
 Everybody uses a different TAB size (the core team used to use 2, 4 and
 8, and it consists of only three people), and looking at code indenting
 with a different tab-size is a pain.
 Spaces work around all that.
\layout Standard

Use an indent size of 4.
 That seems to be a good compromise for most people.
\layout Standard

Use ANSI styles braces i.e.
 put the 
\family typewriter 
{
\family default 
 and 
\family typewriter 
}
\family default 
 on their own line, do not attach it to the 
\family typewriter 
if
\family default 
 or 
\family typewriter 
for
\family default 
.
\layout Section

General Commenting
\layout Standard

We use doxygen to turn code into documentation, because it is so flexible
 and has nice output.
\layout Standard

Use the QT style for comments (
\family typewriter 
/*!
\family default 
), not the JavaDoc style.
 The former lets you define comments without a brief comment, which is what
 we want.
 
\layout Standard

Don't do brief comments, they clutter up the member list and very rarely
 add more information than the method name.
 Exception: classes.
 Put a brief class comment at the top of the header to help people understand
 what the class is about.
 Do use full comments where necessary.
 They're not always necessary for 
\family typewriter 
setValue()
\family default 
 style functions, though.
 
\layout Standard

Do comment the classes and data members, they are probably more important
 than the methods.
\layout Section

Headers
\layout Standard

The general idea behind the header styling is to keep them clean and concise.
 Many people use the headers as primary information sources, not the documentati
on.
 Cluttered up headers are really useless in that case.
\layout Standard

Generally there should only be one class per header/file, which is pretty
 much standard for C++ people.
 If you have minimal helper classes that don't have any use outside their
 user class you can keep them in the same header.
\layout Standard

The order of sections in a class definition should be 
\family typewriter 
public:
\family default 
, 
\family typewriter 
protected:
\family default 
, 
\family typewriter 
private:
\family default 
, to give people the parts that they can actually access at the top of the
 file.
\layout Standard

Don't put inline code into the headers, use a separate 
\family typewriter 
.inl
\family default 
 file for that.
 
\layout Standard

Don't document every method and member in the headers.
 Doing that makes the actual code get lost, comment them at the implementation
 point instead.
 Use groups (
\family typewriter 
/*! 
\backslash 
{ */
\family default 
) to group logically related methods into groups, don't bother to put a
 comment in front of every method.
\layout Section

Code Files
\layout Standard

Put an extensive class comment right after the includes (or before???),
 followed by the member documentation.
 
\layout Standard

The methods in the 
\family typewriter 
.cpp
\family default 
 should be in the same order that they are defined in in the header.
\layout Standard

Every non-static data member of a class must be initialized through the
 mem-initializer-list before the function body of the constructor is executed.
 Everything else will lead to big pains in the long run.
\layout Standard

That's about it.
 It isn't really that painful, is it?
\layout Chapter

fcdEdit Interface Components
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 482
file fcdEdit-numbered.eps
width 3 100
flags 11

\end_inset 


\end_float 
\layout Enumerate

Node name: don't include the OSG prefix
\layout Enumerate

System Component: needed to define the include convention, usually not used
 by applications.
\layout Enumerate

Parent field container; don't include the OSG prefix
\layout Enumerate

Is Parent a System Component: needed to define include convention.
 Has to be set when deriving from a system component.
\layout Enumerate

Library: Needed to distinguish between creating and using a DLL.
 For applications just set it to 
\family typewriter 
My
\family default 
 and copy the 
\family typewriter 
OSGMyDef.h
\family default 
 from examples/Cubes.
\layout Enumerate

PFTypes: choose the kinds of pointer fields that should be created.
 
\layout Enumerate

Structure: choose between an abstract and a concrete class.
\layout Enumerate

Field list, shows all field description in a vertical list
\layout Enumerate

Name of the Field
\layout Enumerate

Type of the Field, can be changed/extended with the 'Load Field Types/Reset
 Field Types' mechanisms, or just typed into the line
\layout Enumerate

Cardinality: defines the field to be a single or MultiField (can hold one
 value or any number (0-n))
\layout Enumerate

Access: private/protected/public c++ style access definition
\layout Enumerate

Visibility: internal/external; will be used to create various styles of
 documentation and to decide what is written to a file or not.
\layout Enumerate

Header: the header needed to define the type.
 If unset the system tries to guess.
 For internal types it's usually right, for your own types or external types
 you can directly enter the header here.
\layout Enumerate

DefaultValue: The default field value.
 Copied into the initialisation list of the constructor.
 Example: 
\family typewriter 
GL_POINT
\family default 
.
\layout Enumerate

DefaultHeader: The header that is needed to find the default value.
 Example: 
\family typewriter 
<GL/gl.h>
\layout Enumerate

Description: Text description of the Field
\layout Enumerate

New Field: creates a new field
\layout Enumerate

Delete Field: deletes the current field
\layout Enumerate

Clone Field: creates a new field description as a clone of the current field
\layout Enumerate

Up: Moves the current field one position up
\layout Enumerate

Down: Movies the current field one position down
\layout Enumerate

New: Restarts the process 
\layout Enumerate

Load: load an fcd file and replace the current settings
\layout Enumerate

Load Parent: non-functional right now.
 We don't know how to find the parent yet.
\layout Enumerate

ResetFieldTypes: Clear all the field types.
\layout Enumerate

LoadFieldTypes: Load your specific set of field types.
\layout Enumerate

Save: Save the settings to the fcd file they came from.
\layout Enumerate

Save as: Save the settings to an fcd file they came from.
\layout Enumerate

Write Field Container Base Code: Writes the current description as 
\family typewriter 
OSGFooBase.h
\family default 
, 
\family typewriter 
OSGFooBase.inl
\family default 
, 
\family typewriter 
OSGFooBase.cpp
\family default 
 and 
\family typewriter 
OSGFooFields.h
\family default 
.
\layout Enumerate

Write Field Container Code: Writes the current description as 
\family typewriter 
OSGFoo.h
\family default 
 
\family typewriter 
OSGFoo.inl 
\family default 
and 
\family typewriter 
OSGFoo.cpp
\layout Enumerate

About
\layout Enumerate

Exit
\layout Enumerate

Node Description: Description of the node that copied verbatim into the
 doxygen documentation
\layout Standard


\latex latex 

\backslash 
end{appendix}
\the_end

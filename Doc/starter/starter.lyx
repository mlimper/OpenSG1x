#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass book
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Title

OpenSG Starter guide
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Standard

Welcome to the OpenSG starter.
 This document will help you understand the structure of the OpenSG system
 and the main classes that you need to know to write graphics programs using
 OpenSG.
 
\layout Standard

It does not explain every single function and its parameters, take a look
 at the Code documentation that is generated by doxygen for that.
 It will also not motivate the decisions taken and alternatives that were
 rejected, see the design document for that.
 This is for jumpstarting OpenSG usage.
\layout Section

What is OpenSG
\layout Standard

OpenSG is a real-time rendering system based on a scenegraph metaphor.
 It works along the lines of OpenInventor, Performer or Java3D, although
 it is probably closest to Performer.
 It supports parallel processing, albeit in a more general way, and will
 drive multiple displays for multi-screen stereo projection systems.
 The goal is to have something that handles multi-threaded data structures
 as simply as possible without compromising performance too much.
 It should also support heterogeneous multi-pipe applications, i.e.
 multiple different graphics cards running one application.
 Many things are quite easy to do with a little program, but are sometimes
 hard to fit into an existing system.
 Thus accessibility is an important goal, and we're striving to make OpenSG
 very extendable.
\layout Standard

It works on different Unix systems and Windows.
 It compiles with the Microsoft Visual Studio compiler, but that version
 has to use some extremely ugly kludges and is not always maintained, so
 using the Intel compiler, version 5.x, is recommended.
\layout Section

What is OpenSG not
\layout Standard

OpenSG is not a complete VR system.
 Things like device access and interaction are left out on purpose, there
 are other systems for that.
\layout Section

Where do get it
\layout Standard

If you read this you probably have it already, otherwise take a look at
 http://www.opensg.org/download_e.html for the latest released version.
 You can also get it from SourceForge, which we use for project management,
 at http://www.sf.net/projects/showfiles.php?group_id=5283.
\layout Standard

If you want to get access to the current development version you can get
 it from CVS, see http://sourceforge.net/cvs/?group_id=5283 for details.
 A nightly snapshot of the CVS tree is also available at www.opensg.org/download/o
pensg_snapshot.tgz.
\layout Section

Compilation
\layout Standard

OpenSG uses a relatively standard configure script to adapt the options
 it needs to the system it's compiled on.
 configure is also used to set up optional libraries that are available.
 For Windows you need to use the cygwin environment (http://sources.redhat.com/cyg
win/) to get the needed shell tools.
 There is a Visual Studio Workspace in 
\family typewriter 
Experimental/VS
\family default 
, but it is not actively mainted and thus probably out of date.
 We're working on an automatic way to create it, but right now you're probably
 better off with cygwin.
\layout Standard

You need to set the 
\family typewriter 
--with-compiler=
\family default 
 option to sepcify the compiler you're going to use.
 All other options are optional.
 The most useful ones are 
\family typewriter 
--with-jpg[=<dir>]
\family default 
, 
\family typewriter 
--with-qt[=<dir>]
\family default 
, 
\family typewriter 
--with-tif[=<dir>]
\family default 
 and 
\family typewriter 
--with-png[=<dir>]
\family default 
 which specify the directories where the specific libraries/header can be
 found.
 There are some other options that are less often needed, run 
\family typewriter 
configure --help
\family default 
 to get a full list.
\layout Standard

So for a standard Linux distribution you should call 
\family typewriter 
./configure --with-compiler=g++ --with-jpg --with-tif --with-png --with-qt=$QTDIR
\family default 
 to get a useful configuration.
\layout Standard

Configure creates a directory in Builds with a name specific for the current
 system, e.g.
 
\family typewriter 
Builds/i686-pc-linux-gnu-g++/
\family default 
.
 Go into this directory and call 
\family typewriter 
make
\family default 
 to create the libraries.
\layout Standard

In general you can call 
\family typewriter 
make help
\family default 
 in any directory with a makefile to get a list of supported targets in
 this directory.
\layout Section

Installation
\layout Standard

Call 
\family typewriter 
make install
\family default 
 to install the libraries in the place specified to 
\family typewriter 
configure
\family default 
, or 
\family typewriter 
/usr/local
\family default 
 per default.
 You can change the installation directory at install time by specifying
 it as 
\family typewriter 
gmake INSTALL_DIR=<dir> install
\family default 
.
 
\family typewriter 
make install
\family default 
 will copy all include files into a directory 
\family typewriter 
OpenSG
\family default 
 in 
\family typewriter 
$INSTALL_DIR/include
\family default 
 and the libs into 
\family typewriter 
$INSTALL_DIR/lib/dbg
\family default 
 or 
\family typewriter 
$INSTALL_DIR/lib/opt
\family default 
, depending on the optimization used.
 For a local install it's useful to call 
\family typewriter 
make $INSTALL_DIR=`pwd` install
\family default 
, which will put everything in the current directory.
\layout Section

Making and executing the test programs
\layout Standard

To build the test programs, go into the 
\family typewriter 
*Test
\family default 
 directory and call make or make Tests.
 make list lists the available programs in the current directory.
 You can make a specific test program by running the listed command.
\layout Standard

To execute the test programs you need to have the library in your path.
 For that it's easiest to locally install them as described before and (csh/tcsh
) 
\family typewriter 
setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:../lib/dbg
\family default 
 or (sh/bash) 
\family typewriter 
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:../lib/dbg
\family default 
.
 Then you can just run the test programs in the 
\family typewriter 
*Test
\family default 
 directory.
\layout Section

How to use it
\layout Subsection

Own projects
\layout Standard

OpenSG is just a library, so use it like any other library.
 It has an 
\family typewriter 
opensg-config
\family default 
 script that emits the needed compiler options 
\shape italic 
(I hope it will...
 ;).
 
\shape default 
So you can call 
\family typewriter 
opensg-config --cflags
\family default 
 to get the needed compiler options and 
\family typewriter 
opensg-config --libs
\family default 
 to get the needed linker flags.
 See 
\family typewriter 
examples/*/Makefile
\family default 
 for examples how to do that.
\layout Subsection

Extending OpenSG
\layout Standard

Extending OpenSG is generally trivial: just add your files to the directories,
 they will automagically be picked up by the next compile.
 
\layout Standard

Adding new directories is a little more tricky.
 You need to add your directory to 
\family typewriter 
CommConf/common.libs.in
\family default 
.
 This is not difficult, but hard to explain.
 If you need to do that, take a look at the file, try it and if it doesn't
 work send us an email (
\family typewriter 
info@opensg.org
\family default 
).
\layout Standard

If you need new libraries you have to add them to the configure script .
 Copy some of the given examples or ask us for help.
\layout Standard

The following chapters introduce you to the main classes and concepts used
 in OpenSG.
 Again, they are not intended to explain every function and its parameters,
 see the doxygen documentation for that, and they are not meant to explain
 the reasons behind the design choices, see the design document for that.
\layout Chapter

OpenSG Basics
\layout Standard

All OpenSG symbols are part of the OSG namespace, and they have no prefix.
 The actual files, including headers, all use the 
\family typewriter 
OSG
\family default 
 prefix.
\layout Section

Base types
\layout Standard

As one goal of OpenSG is the ability to run programs on a lot of different
 platforms, especially Unix and Windows, we have our own types which are
 guaranteed to have the same size on all platforms.
 
\layout Standard

We have our own bool type 
\family typewriter 
Bool
\family default 
, and signed and unsigned integers in all useful sizes: 
\family typewriter 
Int8
\family default 
, 
\family typewriter 
UInt8
\family default 
, 
\family typewriter 
Int16
\family default 
, 
\family typewriter 
UInt16
\family default 
, 
\family typewriter 
Int32
\family default 
, 
\family typewriter 
UInt32
\family default 
, 
\family typewriter 
Int64
\family default 
, 
\family typewriter 
UInt64
\family default 
 as well as the two usual float sizes 
\family typewriter 
Real32
\family default 
 and 
\family typewriter 
Real64
\family default 
.
 Some useful constant are available: 
\family typewriter 
Eps
\family default 
, 
\family typewriter 
Pi
\family default 
, 
\family typewriter 
Inf
\family default 
 and 
\family typewriter 
NegInf
\family default 
.
 A useful construct for template programming is the 
\family typewriter 
TypeConstants<type>
\family default 
 structure, which defines some standard functions/values for the given type,
 see 
\family typewriter 
OSGBaseTypes.h
\family default 
 for details.
\layout Section

Log
\layout Standard

All output that OpenSG generates is channeled through the Log class, which
 is defined in 
\family typewriter 
OSGLog.h
\family default 
.
 OpenSG supplies a global Log object that isused by the library, but the
 application can create its own logs, if needed.
\layout Standard

Every log message has one specific level.
 The available levels are 
\family typewriter 
LOG
\family default 
, 
\family typewriter 
FATAL
\family default 
, 
\family typewriter 
WARNING
\family default 
, 
\family typewriter 
NOTICE
\family default 
, 
\family typewriter 
INFO
\family default 
 and 
\family typewriter 
DEBUG
\family default 
.
 They are also numbered from 0 to 5.
 The verbosity of the system can be controlled by ignoring messages of specific
 levels.
 This can be achieved by calling 
\family typewriter 
osgLog().setLogLevel( <enum> );
\family default 
 or by setting the environment variable 
\family typewriter 
OSG_LOG_LEVEL
\family default 
.
\layout Standard

The system log has two different interfaces.
 One is based on C++ streams, one is based on C printf semantics.
 
\layout Standard

The stream interface can be used by using 
\family typewriter 
SLOG
\family default 
, 
\family typewriter 
SFATAL
\family default 
, 
\family typewriter 
SWARNING
\family default 
, 
\family typewriter 
SNOTICE
\family default 
 or 
\family typewriter 
SINFO
\family default 
 instead of cout or cerr.
 Note that there is no 
\family typewriter 
SDEBUG
\family default 
 for efficiency reasons, as 
\family typewriter 
FDEBUG
\family default 
 can be compiled out.
 These print the position in the code where the log is executed.
 For multi-lines outputs you'll only want that on the first line, for the
 other lines use 
\family typewriter 
PLOG
\family default 
, 
\family typewriter 
PFATAL
\family default 
, 
\family typewriter 
PWARNING
\family default 
, 
\family typewriter 
PNOTICE
\family default 
 or 
\family typewriter 
PINFO
\family default 
.
 
\shape italic 
What about the lock/unlock stuff? How does that work?
\layout Standard

The C interface tries to mimic the printf semantics.
 The following functions can be used for that: 
\family typewriter 
FLOG
\family default 
, 
\family typewriter 
FFATAL
\family default 
, 
\family typewriter 
FWARNING
\family default 
, 
\family typewriter 
FNOTICE
\family default 
, 
\family typewriter 
FINFO
\family default 
 and 
\family typewriter 
FDEBUG
\family default 
.
 The only difference to 
\family typewriter 
printf
\family default 
 is that they have to be called with double parentheses, i.e.
 
\family typewriter 
FWARNING((
\begin_inset Quotes eld
\end_inset 

What do you mean by %s?
\begin_inset Quotes erd
\end_inset 

, s));
\family default 
.
 
\layout Section

Math
\layout Standard

Of course every scenegraph needs the basic math objects like Vectors, Points,
 Matrices, Quaternions etc., and OpenSG is no exception.
\layout Subsection

Matrices
\layout Standard

OpenSG matrices are similar to the OpenGL matrices in their storage structure
 and conventions, i.e.
 a matrix is per default a 4x4 
\family typewriter 
Real32
\family default 
 matrix, and the multiplication convention is just like OpenGL: 
\begin_inset Formula \( v'=M*v \)
\end_inset 

.
 
\layout Standard

The matrix is stored column major, not row major like standard C/C++ 2D
 arrays.
 So is vector access to the matrix' parts, i.e.
 
\family typewriter 
matrix[0]
\family default 
 is the first column, not the first row.
 This is also true for the vector-based constructor.
 It is not true for the constructor that takes 16 single elements, which
 expects its parameters row-major like the matrix is written on paper.
\layout Standard

The positive side effect of this setup is the ability to access the base
 vectors of the matrix' coordinate space by accessing the vectors, i.e.
 
\family typewriter 
matrix[3]
\family default 
 is the translation to the origin of the local coordinate space.
 This is useful if you want to create your matrices from vectors, if you
 don't want to do that, dont' worry about it.
\layout Standard

Setting the contents of a matrix is done by the 
\family typewriter 
setValues()
\family default 
 methods, accessing the values via the 
\family typewriter 
[]
\family default 
 operator for access to single columns or by using 
\family typewriter 
getValues()
\family default 
 to get a pointer to the first element.
 In general most classes in OpenSG that keep an array of elements allow
 access to them via 
\family typewriter 
getValues()
\family default 
.
\layout Standard

If you need to create a matrix for a specific transformation, use the 
\family typewriter 
setTransform()
\family default 
 methods, which create a matrix that executes the given transformation.
 There are also 
\family typewriter 
setScale()
\family default 
, 
\family typewriter 
setTranslate()
\family default 
, 
\family typewriter 
setRotate()
\family default 
 etc.
 methods, but these only set the specified aspect of the matrix and don't
 clear the rest, so be careful when using these.
\layout Standard

Matrices also supply the standard set of matrix operations like 
\family typewriter 
det()
\family default 
, 
\family typewriter 
det3()
\family default 
, 
\family typewriter 
invert()
\family default 
, 
\family typewriter 
transpose()
\family default 
, 
\family typewriter 
mult()
\family default 
 and 
\family typewriter 
multLeft()
\family default 
.
 There are some variantes that change the matrix in place, return their
 results in a different matrix or get their source data from a different
 matrix, see the class docs for details.
 
\shape italic 
What's the point of having both?
\layout Standard

The default vector/point multiplication methods 
\family typewriter 
multMatrixPnt()
\family default 
 and 
\family typewriter 
multMatrixVec()
\family default 
 assume that the matrix only uses the standard 3x4 elements.
 To use the full 4x4 matrix use 
\family typewriter 
multFullMatrixPnt()
\family default 
.
 As Vectors have a 
\begin_inset Formula \( w \)
\end_inset 

 coordinate of 0 they don't need a full transform.
\layout Subsection

Vectors/Points/Colors
\layout Standard

OpenSG is different from most other systems in differentiating between vectors,
 points and colors.
 Even though they are all classes containing 3 elements, the available operation
s differ.
\layout Standard

Points ...
\layout Section

StringID
\layout Standard

Do not use it.
 It is only for StringID which can have shared data.
 Use std::string instead.
\layout Section

Functors
\layout Standard

Moving target.
 Don not use it right now.
\layout Section

Time & Data
\layout Section

Line & Plane
\layout Section

Bounding Volume
\layout Section

Threads
\layout Section

Image
\layout Chapter

Fields and FieldContainers
\layout Standard

One central goal of the OpenSG design is easy to use thread-safe data.
 To do that right you need to replicate the data so that every thread can
 have its private copy (called aspect) to work on.
 At some point these different copies will have to be synchronized again,
 and then the parts that ctually changed need to be copied from one aspect
 to the other.
 To do that the system needs to know what actually changed, and to know
 that on a sub-class basis.
 As C++ is not reflective, i.e.
 the classes cannot tell the system which members they have, OpenSG needs
 to that itself.
 That's what Fields and FieldContainers are for.
\layout Section

Creating a FieldContainer instance
\layout Standard

factory,prototype blabla
\layout Section

Changing field values
\layout Standard

changelist blabla
\layout Section

FieldContainer attachments
\layout Standard

attachment blabla
\layout Section

Nodes and NodeCores
\layout Standard

single (see image 
\begin_inset LatexCommand \ref{singleParentFig}

\end_inset 


\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 238 304
file .backup/node_core_share.eps
width 4 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{singleParentFig}

\end_inset 

Single Parent Scene
\end_float 
) stuff
\layout Subsection

Node 
\layout Standard

volume stuff, toWord matrix
\layout Subsection

NodeCore 
\layout Chapter

Special Node Cores
\layout Description

Material chunk stuff
\layout Description

Geometry property stuff
\layout Chapter

Action and Traversals
\layout Section

Usage
\layout Section

Write our own action handler
\layout Chapter

Camera and Window
\layout Chapter

Loader
\layout Section

Usage
\layout Subsection

Scene
\layout Subsection

Image
\layout Section

Write our own
\layout Subsection

Scene
\layout Subsection

Image
\layout Chapter

Creating new FieldContainer classes
\layout Standard

fcdEdit (see image 
\begin_inset LatexCommand \ref{fcdEditFig}

\end_inset 


\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 267 177
file .backup/fcd.eps
width 4 90
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fcdEditFig}

\end_inset 

FcdEdit blabla
\end_float 
 ) stuff
\layout Section

XML Description (Foo.fcd)
\layout Section

Field Types (FooFields.h)
\layout Section

Base/Meta Type (FooBase.h, FooBase.inl, FooBase.cpp)
\layout Section

'User Code' implementation (Foo.h, Foo.inl, Foo.cpp)
\layout Standard


\begin_inset LatexCommand \listoffigures{}

\end_inset 


\layout Standard


\latex latex 

\backslash 
begin{appendix}
\layout Chapter

Code Style
\layout Chapter

fcdEdit description
\layout Standard

Code Style
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 484
file fcdEdit-numbered.eps
width 3 100
flags 11

\end_inset 


\layout Caption

\end_float 
\layout Enumerate

Node name; you don't have to include the OSG prefix
\layout Enumerate

System Component ?
\layout Enumerate

Parent field container; you dont have to include the OSG prefix
\layout Enumerate

Is Parent a System Component
\layout Enumerate

Library:
\layout Enumerate

PFTypes
\layout Enumerate

Structure
\layout Enumerate

Field list, shows all field description in a vertical list
\layout Enumerate

Name of the Field
\layout Enumerate

Type of the Field, can be changed/extended with the 'Load Field Types/Reset
 Field Types' mechanisms
\layout Enumerate

Cardinality: defines the field to be a single or multifield (can hold one
 value or any number (0-n))
\layout Enumerate

Access: private/protected/public c++ sty;e access definition
\layout Enumerate

Visibility: internal/external; will be used to create various styles of
 documentation
\layout Enumerate

Header: defines the type header, if unset ...
\layout Enumerate

DefaultValue: The default field value, prototype ?
\layout Enumerate

DefaultHeader: ?
\layout Enumerate

Description: Text description of the Field
\layout Enumerate

New Field: creates a new field
\layout Enumerate

Delete Field: deletes the current field
\layout Enumerate

Clone Field: creates a new field description as clone of the current field
\layout Enumerate

Up: Moves the current field one position up
\layout Enumerate

Down: Movies the current field one position down
\layout Enumerate

New: Restarts the process 
\layout Enumerate

Load:
\layout Enumerate

Load Parent:
\layout Enumerate

ResetFieldTypes:
\layout Enumerate

LoadFieldTypes;
\layout Enumerate

Save:
\layout Enumerate

Save as:
\layout Enumerate

Write Field Container Base Code: Writes the current description as FooBase.h,
 FooBase.inl and FooBase.cpp
\layout Enumerate

Write Field Container Code: Writes the current description as Foo.h Foo.inl
 and Foo.cpp
\layout Enumerate

About
\layout Enumerate

Exit
\layout Enumerate

Node Description: HTML ?
\layout Standard


\latex latex 

\backslash 
end{appendix}
\the_end

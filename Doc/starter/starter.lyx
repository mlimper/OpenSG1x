#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass book
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Title

OpenSG starter guide
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Standard

Welcome to the OpenSG starter.
 This document will help you understand the structure of the OpenSG system
 and the main classes that you need to know to write graphics programs using
 OpenSG.
 
\layout Standard

It does not explain every single function and its parameters, take a look
 at the Code documentation that is generated by doxygen for that.
 It will also not motivate the decisions taken and alternatives that were
 rejected, see the design document for that.
 This is for jumpstarting OpenSG usage.
\layout Standard

If you want to send feedback or have further questions you can send them
 either to the OpenSG developer list (
\family typewriter 
opensg-developer@lists.sf.net
\family default 
) or to us directly at 
\family typewriter 
info@opensg.org.
\layout Section

What is OpenSG
\layout Standard

OpenSG is a real-time rendering system based on a scenegraph metaphor.
 It works along the lines of OpenInventor, Performer or Java3D, although
 it is probably closest to Performer.
 It supports parallel processing, albeit in a more general way, and will
 drive multiple displays for multi-screen stereo projection systems.
 The goal is to have something that handles multi-threaded data structures
 as simply as possible without compromising performance too much.
 It should also support heterogeneous multi-pipe applications, i.e.
 multiple different graphics cards running one application.
 Many things are quite easy to do with a little program, but are sometimes
 hard to fit into an existing system.
 Thus accessibility is an important goal, and we're striving to make OpenSG
 very extendable.
\layout Standard

It works on different Unix systems and Windows.
 It compiles with the Microsoft Visual Studio compiler, but that version
 has to use some extremely ugly kludges and is not always maintained, so
 using the Intel compiler, version 5.x, is recommended.
\layout Section

What is OpenSG not
\layout Standard

OpenSG is not a complete VR system.
 Things like device access and interaction are left out on purpose, there
 are other systems for that.
\layout Section

Where do get it
\layout Standard

If you read this you probably have it already, otherwise take a look at
 http://www.opensg.org/download_e.html for the latest released version.
 You can also get it from SourceForge, which we use for project management,
 at http://www.sf.net/projects/showfiles.php?group_id=5283.
\layout Standard

If you want to get access to the current development version you can get
 it from CVS, see http://sourceforge.net/cvs/?group_id=5283 for details.
 Nightly snapshots of the CVS source and libs are available at at www.opensg.org/d
ailybuild_logs.
\layout Section

Compilation
\layout Standard


\shape italic 
(( Short version: 
\family typewriter 
./configure ; make
\family default 
 should work.
 ))
\layout Standard

Long version: OpenSG uses a relatively standard configure script to adapt
 the options it needs to the system it's compiled on.
 configure is also used to set up optional libraries that are available.
 For Windows you need to use the cygwin environment (http://sources.redhat.com/cyg
win/) to get the needed shell tools.
 There is a Visual Studio Workspace in 
\family typewriter 
Experimental/VS
\family default 
, but it is not actively mainted and thus probably out of date.
 We're working on an automatic way to create it, but right now you're probably
 better off with cygwin.
\layout Standard

You need to set the 
\family typewriter 
--with-compiler=
\family default 
 option to specify the compiler you're going to use.
 All other options are optional.
 The most useful ones are 
\family typewriter 
--with-jpg[=<dir>]
\family default 
, 
\family typewriter 
--with-qt[=<dir>]
\family default 
, 
\family typewriter 
--with-tif[=<dir>]
\family default 
 and 
\family typewriter 
--with-png[=<dir>]
\family default 
 which specify the directories where the specific libraries/header can be
 found.
 There are some other options that are less often needed, run 
\family typewriter 
configure --help
\family default 
 to get a full list.
\layout Standard

So for a standard Linux distribution you should call 
\family typewriter 
./configure --with-compiler=g++ --with-jpg --with-tif --with-png --with-qt=$QTDIR
\family default 
 to get a useful configuration.
\layout Standard

Configure creates a directory in Builds with a name specific for the current
 system, e.g.
 
\family typewriter 
Builds/i686-pc-linux-gnu-g++/
\family default 
.
 Go into this directory and call 
\family typewriter 
make
\family default 
 to create the libraries.
\layout Standard

In general you can call 
\family typewriter 
make help
\family default 
 in any directory with a makefile to get a list of supported targets in
 this directory.
\layout Section

Installation
\layout Standard

Call 
\family typewriter 
make install
\family default 
 to install the libraries in the place specified to 
\family typewriter 
configure
\family default 
, or 
\family typewriter 
/usr/local
\family default 
 per default.
 You can change the installation directory at install time by specifying
 it as 
\family typewriter 
gmake INSTALL_DIR=<dir> install
\family default 
.
 
\family typewriter 
make install
\family default 
 will copy all include files into a directory 
\family typewriter 
OpenSG
\family default 
 in 
\family typewriter 
$INSTALL_DIR/include
\family default 
 and the libs into 
\family typewriter 
$INSTALL_DIR/lib/dbg
\family default 
 or 
\family typewriter 
$INSTALL_DIR/lib/opt
\family default 
, depending on the optimization used.
 For a local install it's useful to call 
\family typewriter 
make $INSTALL_DIR=`pwd` install
\family default 
, which will put everything in the current directory.
\layout Section

Making and executing the test programs
\layout Standard

To build the test programs, go into the 
\family typewriter 
*Test
\family default 
 directory and call make or make Tests.
 make list lists the available programs in the current directory.
 You can make a specific test program by running the listed command.
\layout Standard

To execute the test programs you need to have the library in your path.
 For that it's easiest to locally install them as described before and (csh/tcsh
) 
\family typewriter 
setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:../lib/dbg
\family default 
 or (sh/bash) 
\family typewriter 
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:../lib/dbg
\family default 
.
 Then you can just run the test programs in the 
\family typewriter 
*Test
\family default 
 directory.
\layout Section

How to use it
\layout Subsection

Own projects
\layout Standard

OpenSG is just a library, so use it like any other library.
 It has an 
\family typewriter 
opensg-config
\family default 
 script that emits the needed compiler options 
\shape italic 
(I hope it will...
 ;).
 
\shape default 
So you can call 
\family typewriter 
opensg-config --cflags
\family default 
 to get the needed compiler options and 
\family typewriter 
opensg-config --libs
\family default 
 to get the needed linker flags.
 See 
\family typewriter 
examples/*/Makefile
\family default 
 for examples how to do that.
\layout Subsection

Extending OpenSG
\layout Standard

Extending OpenSG is generally trivial: just add your files to the directories,
 they will automagically be picked up by the next compile.
 
\layout Standard

Adding new directories is a little more tricky.
 You need to add your directory to 
\family typewriter 
CommConf/common.libs.in
\family default 
.
 This is not difficult, but hard to explain.
 If you need to do that, take a look at the file, try it and if it doesn't
 work send us an email or use the developer list on SourceForge.
\layout Standard

If you need new libraries you have to add them to the configure script .
 Copy some of the given examples or ask us for help.
\layout Standard

The following chapters introduce you to the main classes and concepts used
 in OpenSG.
 Again, they are not intended to explain every function and its parameters,
 see the doxygen documentation for that, and they are not meant to explain
 the reasons behind the design choices, see the design document for that.
\layout Chapter

OpenSG Basics
\layout Standard

All OpenSG symbols are part of the OSG namespace, and they have no prefix.
 The actual files, including headers, all use the 
\family typewriter 
OSG
\family default 
 prefix.
\layout Section

Base types
\layout Standard

As one goal of OpenSG is the ability to run programs on a lot of different
 platforms, especially Unix and Windows, we have our own types which are
 guaranteed to have the same size on all platforms.
 
\layout Standard

We have our own bool type 
\family typewriter 
Bool
\family default 
, and signed and unsigned integers in all useful sizes: 
\family typewriter 
Int8
\family default 
, 
\family typewriter 
UInt8
\family default 
, 
\family typewriter 
Int16
\family default 
, 
\family typewriter 
UInt16
\family default 
, 
\family typewriter 
Int32
\family default 
, 
\family typewriter 
UInt32
\family default 
, 
\family typewriter 
Int64
\family default 
, 
\family typewriter 
UInt64
\family default 
 as well as the two usual float sizes 
\family typewriter 
Real32
\family default 
 and 
\family typewriter 
Real64
\family default 
.
 Some useful constant are available: 
\family typewriter 
Eps
\family default 
, 
\family typewriter 
Pi
\family default 
, 
\family typewriter 
Inf
\family default 
 and 
\family typewriter 
NegInf
\family default 
.
 A useful construct for template programming is the 
\family typewriter 
TypeConstants<type>
\family default 
 structure, which defines some standard functions/values for the given type,
 see 
\family typewriter 
OSGBaseTypes.h
\family default 
 for details.
\layout Section

Log
\layout Standard

All output that OpenSG generates is channeled through the Log class, which
 is defined in 
\family typewriter 
OSGLog.h
\family default 
.
 OpenSG supplies a global Log object that isused by the library, but the
 application can create its own logs, if needed.
\layout Standard

Every log message has one specific level.
 The available levels are 
\family typewriter 
LOG
\family default 
, 
\family typewriter 
FATAL
\family default 
, 
\family typewriter 
WARNING
\family default 
, 
\family typewriter 
NOTICE
\family default 
, 
\family typewriter 
INFO
\family default 
 and 
\family typewriter 
DEBUG
\family default 
.
 They are also numbered from 0 to 5.
 The verbosity of the system can be controlled by ignoring messages of specific
 levels.
 This can be achieved by calling 
\family typewriter 
osgLog().setLogLevel( <enum> );
\family default 
 or by setting the environment variable 
\family typewriter 
OSG_LOG_LEVEL
\family default 
.
\layout Standard

The system log has two different interfaces.
 One is based on C++ streams, one is based on C printf semantics.
 
\layout Standard

The stream interface can be used by using 
\family typewriter 
SLOG
\family default 
, 
\family typewriter 
SFATAL
\family default 
, 
\family typewriter 
SWARNING
\family default 
, 
\family typewriter 
SNOTICE
\family default 
 or 
\family typewriter 
SINFO
\family default 
 instead of cout or cerr.
 Note that there is no 
\family typewriter 
SDEBUG
\family default 
 for efficiency reasons, as 
\family typewriter 
FDEBUG
\family default 
 can be compiled out.
 These print the position in the code where the log is executed.
 For multi-lines outputs you'll only want that on the first line, for the
 other lines use 
\family typewriter 
PLOG
\family default 
, 
\family typewriter 
PFATAL
\family default 
, 
\family typewriter 
PWARNING
\family default 
, 
\family typewriter 
PNOTICE
\family default 
 or 
\family typewriter 
PINFO
\family default 
.
 
\layout Standard

To synchronize multiple outputs from various threads all S* commands lock
 the stream.
 You have to use 'osg::endLog' (e.g.
 SFATAL << 
\begin_inset Quotes eld
\end_inset 

Message
\begin_inset Quotes erd
\end_inset 

 << endLog) to unlock the stream output.
 
\layout Standard

The C interface tries to mimic the printf semantics.
 The following functions can be used for that: 
\family typewriter 
FLOG
\family default 
, 
\family typewriter 
FFATAL
\family default 
, 
\family typewriter 
FWARNING
\family default 
, 
\family typewriter 
FNOTICE
\family default 
, 
\family typewriter 
FINFO
\family default 
 and 
\family typewriter 
FDEBUG
\family default 
.
 The only difference to 
\family typewriter 
printf
\family default 
 is that they have to be called with double parentheses, i.e.
 
\family typewriter 
FWARNING((
\begin_inset Quotes eld
\end_inset 

What do you mean by %s?
\begin_inset Quotes erd
\end_inset 

, s));
\family default 
.
 The nice think about the C style interace is that the hole output can be
 compiled out.
 Actually, the 
\family typewriter 
FDEBUG
\family default 
 (( )) are only compiled in when OSG_DEBUG is set.
 The OSG_DEBUG define is automatically set while compiling the system in
 debug (default) mode.
\layout Standard

The user can activate/deactivate various elements per log message turing
 runtime by changing the LogHeaderElem mask.
 The following elements are supported right know:
\layout Description

LOG_BEGIN_NEWLINE_HEADER creates a extra newline infront of every output
\layout Description

LOG_TYPE_HEADER writes the Level (e.g.
 WARNING) as first element
\layout Description

LOG_TIMESTAMP_HEADER writes a timestamp 
\layout Description

LOG_MODULE_HEADER writes the name of the current module 
\layout Description

LOG_FILE_HEADER writes the source file name
\layout Description

LOG_LINE_HEADER writes the source line number 
\layout Description

LOG_EEND_NEWLINE_HEADER creates a extra newline at the end 
\layout Standard

When unchanged, the timestamp will be the time in seconds since the programm
 started.
 The user can set/reset the timestamp at any time (e.g.
 osgLog().resetRefTime()).
\layout Section

Math
\layout Standard

Of course every scenegraph needs the basic math objects like Vectors, Points,
 Matrices, Quaternions etc., and OpenSG is no exception.
\layout Subsection

Matrices
\layout Standard

OpenSG matrices are similar to the OpenGL matrices in their storage structure
 and conventions, i.e.
 a matrix is per default a 4x4 
\family typewriter 
Real32
\family default 
 matrix, and the multiplication convention is just like OpenGL: 
\begin_inset Formula \( v'=M*v \)
\end_inset 

.
 
\layout Standard

The matrix is stored column major, not row major like standard C/C++ 2D
 arrays.
 So is vector access to the matrix' parts, i.e.
 
\family typewriter 
matrix[0]
\family default 
 is the first column, not the first row.
 This is also true for the vector-based constructor.
 It is not true for the constructor that takes 16 single elements, which
 expects its parameters row-major like the matrix is written on paper.
\layout Standard

The positive side effect of this setup is the ability to access the base
 vectors of the matrix' coordinate space by accessing the vectors, i.e.
 
\family typewriter 
matrix[3]
\family default 
 is the translation to the origin of the local coordinate space.
 This is useful if you want to create your matrices from vectors, if you
 don't want to do that, dont' worry about it.
\layout Standard

Setting the contents of a matrix is done by the 
\family typewriter 
setValues()
\family default 
 methods, accessing the values via the 
\family typewriter 
[]
\family default 
 operator for access to single columns or by using 
\family typewriter 
getValues()
\family default 
 to get a pointer to the first element.
 In general most classes in OpenSG that keep an array of elements allow
 access to them via 
\family typewriter 
getValues()
\family default 
.
\layout Standard

If you need to create a matrix for a specific transformation, use the 
\family typewriter 
setTransform()
\family default 
 methods, which create a matrix that executes the given transformation.
 There are also 
\family typewriter 
setScale()
\family default 
, 
\family typewriter 
setTranslate()
\family default 
, 
\family typewriter 
setRotate()
\family default 
 etc.
 methods, but these only set the specified aspect of the matrix and don't
 clear the rest, so be careful when using these.
\layout Standard

Matrices also supply the standard set of matrix operations like 
\family typewriter 
det()
\family default 
, 
\family typewriter 
det3()
\family default 
, 
\family typewriter 
invert()
\family default 
, 
\family typewriter 
transpose()
\family default 
, 
\family typewriter 
mult()
\family default 
 and 
\family typewriter 
multLeft()
\family default 
.
 There are some variantes that change the matrix in place, return their
 results in a different matrix or get their source data from a different
 matrix, see the class docs for details.
 
\shape italic 
What's the point of having both?
\layout Standard

The default vector/point multiplication methods 
\family typewriter 
multMatrixPnt()
\family default 
 and 
\family typewriter 
multMatrixVec()
\family default 
 assume that the matrix only uses the standard 3x4 elements.
 To use the full 4x4 matrix use 
\family typewriter 
multFullMatrixPnt()
\family default 
.
 As Vectors have a 
\begin_inset Formula \( w \)
\end_inset 

 coordinate of 0 they don't need a full transform.
\layout Subsection

Vectors/Points/Colors
\layout Standard

OpenSG is different from most other systems in differentiating between vectors,
 points and colors.
 
\layout Standard

Vectors are the most common class, and they should behave like pretty much
 every other vector library on the planet.
 They are templated to simplify having variants, and the standard ones that
 are available are 
\family typewriter 
Vec4ub
\family default 
, 
\family typewriter 
Vec2s
\family default 
, 
\family typewriter 
Vec2f
\family default 
, 
\family typewriter 
Vec3f
\family default 
 and 
\family typewriter 
Vec4f
\family default 
.
 They have operators for the scalar operations, and methods for everything
 else, see the doxygen docs for 
\family typewriter 
osg::VectorInterface
\family default 
 for details.
 Conceptually the 3 element vector has a w coordinate of 0, thus there is
 no full matrix multiplication for vectors.
\layout Standard

Points represent positions in space, and as such they are a little more
 restricted than vectors.
 The available variants are 
\family typewriter 
Pnt2f
\family default 
, 
\family typewriter 
Pnt3f
\family default 
 and 
\family typewriter 
Pnt4f
\family default 
.
 Most of the standard vector operations (dot, cross, etc.) don't make sense
 for points.
 They can be subtracted (creating a vector), scaled and a vector can be
 added to or subtraced from them.
 If you want to represent a position, use a point.
 It helps keeping the concepts in order and not mix up everything just because
 it has the same data.
 If you really need to get from a point to a vector, you can use 
\family typewriter 
Vector &osg::Point.toVector()
\family default 
 to cast the point to a vector.

\shape italic 
 should we do that? It would ease the pain, but undermine the distinction.
 
\shape default 
When multiplied with a matrix, the w coordinate is set as 1 for 3 element
 points.
 
\layout Standard

Colors are RGB vectors, which also have acces functions to the named components.
 They also allow acces via the HSV color model and scalar multiplication,
 but no other operations.
 
\shape italic 
should we change that? Derive them from vector?
\layout Subsection

Quaternions
\layout Standard

Quaternions are the standard way to represent rotations.
 OpenSG quaternions feature the standard set of methods to get and set the
 rotations, in variants for radians and degrees.
 The standard order of the components is 
\family typewriter 
x
\family default 
,
\family typewriter 
y
\family default 
,
\family typewriter 
z
\family default 
,
\family typewriter 
w
\family default 
.
 The standard operations (
\family typewriter 
length
\family default 
, 
\family typewriter 
normalize
\family default 
, 
\family typewriter 
mult
\family default 
) are available, as well as 
\family typewriter 
slerp
\family default 
 and 
\family typewriter 
multVec
\family default 
.
\layout Section

Functors
\layout Standard

Functors are the main method for OpenSG to call configurable actions.
 They are used in the Actions to call the actions for the node cores, and
 in the Window to call actions for the GL objects.
\layout Standard

The functors wrap calls to a standard function, to a member of a specific
 instance or to a member of the first parameter.
 
\layout Standard

They will have to be redesigned for 1.1, as they don't compile using the
 Microsoft Visual Studio compiler.
 :( Thus we don't talk much about them here, if you need to add a new action
 or GL object, send us mail.
\layout Section

Time & Date
\layout Standard

To wrap time and date handling we have a little abstraction for them.
 
\layout Standard


\family typewriter 
getSystemTime()
\family default 
 returns the current time since system start in seconds, using the highest
 resolution timer available.
\layout Standard

The Date class provides a second resolution timestamp, factored into second,
 minute, hour, day, month and year.
 Date::setSystemDate() can be used to set it to the current date/time.
\layout Section

Line 
\layout Standard

The Line defines a ray in space.
 It is defined by a start point and a direction, which is normalized, but
 doesn't have to be specified as such.
 Lines can be constructed from two points or directory from a point and
 a direction.
 
\layout Standard

A line can be intersected with all the bounding volumes and geometry.
 Only the positive half of the line is intersected.
\layout Standard

The line can also find the closest point on itself to a given point or another
 line.
\layout Section

Plane
\layout Standard

The Plane defines a 3D infinite halfspace.
 It is defined by a normal and the distance from the origin, and can be
 constructed from all useful combinations of points and vectors.
\layout Standard

Planes can also be intersected with infinite lines, if needed.
 Points can be tested for lying on the plane, or being in the positive halfspace
 of the plane.
\layout Section

Volumes
\layout Standard

Volumes are primarily used for bounding geometry to speed up culling or
 intersection tests.
 All Volumes are derived from 
\family typewriter 
Volume
\family default 
.
 The supported volumes are the usual 
\family typewriter 
BoxVolume
\family default 
, defined by min and max points, the 
\family typewriter 
SphereVolume
\family default 
, defined by center and radius, and the 
\family typewriter 
FrustumVolume
\family default 
, which is defined by 6 planes and primarily used to define the viewing
 frustum.
\layout Standard

Volumes are created empty and can be changed by extending them by a point
 or another volume.
 All volumes have sepcific access functions to access their attributes,
 but they also have generic access functions to simplify access to arbitrary
 volumes.
 Every volume supports 
\family typewriter 
getBounds()
\family default 
 to access the min/max points, 
\family typewriter 
getCenter()
\family default 
 and 
\family typewriter 
getScalarVolume()
\family default 
 to access the enclosed volume.
 Volumes can be intersected with points, lines and other volumes, and they
 can be transformed by a matrix.
\layout Standard

Volumes can be in one of several states.
 The default state is valid, special states are invalid, empty, infinite
 and static.
 There are specific functions to set them to any one of those states and
 to check if they are in any of those states.
\layout Standard

Invalid volumes have to be set to valid explicitly, before extending them
 has any effect.
 
\family typewriter 
setEmpty()
\family default 
 makes it valid implicitly.
 The states except empty define how extensions and intersections are handled.
 Invalid volumes stay invalid and ignore changes, static and infinite volumes
 keep their values and are not changed by extensions.
 Intersecting an infinite volume is always true, just as intersecting an
 empty volume is never true.
 
\layout Section

Threads
\layout Standard

OpenSG supports a thread abstraction to support efficient threading on all
 supported platforms.
 On Windows that means Windows threads, on Irix sproc() is used, for every
 other system pthreads are used.
\layout Standard

Every thread uses a 
\family typewriter 
Thread
\family default 
 object for thread-specific data, most of which is needed for thread-safe
 data, see 
\begin_inset LatexCommand \ref{threadsafety}

\end_inset 

.
 To create a new thread, the Thread object has a 
\family typewriter 
run()
\family default 
 method, which executes a given function in a new thread.
 
\layout Standard

For thread synchronization 
\family typewriter 
Lock
\family default 
 and 
\family typewriter 
Barrier
\family default 
 objects are available.
 They act like standard locks and barriers, see the doc for details.
\layout Section

Image
\layout Standard

Defines and holds a 1D/2D/3D image and optional a mipmap pyramid and/or
 an list of equally sized frames with a single frameDelay.
 Various pixelTypes are supported to handle grey and RGB color images with
 or without alpha channel.
 The image data starts in the lower left (front) corner and all bytes for
 a single pixel (e.g.
 RGB) are stored one after another in memoy.
 There are not organized in separate layers or channels.
 
\layout Standard

The Image is only a container for the pixel data and image descrition.
 It does not create or handle any OpenGL state elements.
 However, image objects are utilized to handle the data for texture (e.g.
 SimpleTextureMaterial) or bitmap objects (e.g.
 ImageForeground).
 
\layout Standard

The system provides loader and writer for various formats (see section 
\begin_inset LatexCommand \ref{imageLoaderSection}

\end_inset 

).
 The graph loader (e.g.
 OSGLoader, VRMLLoader) use the image loader to fetch the raster data.
 
\layout Section

IDString
\layout Standard

A very primitive string class.
 Mainly used for string IDs (e.g.
 node type names).
 It is not a generic class like the std::string implementation.
 It's only for internal use to built efficient maps for names, not for applicati
on use.
 If you need a string class use use std::string instead.
 
\layout Standard

We decided to create our own specific string class since the std::string
 did not provide all features we needed (e.g.
 shared memory pointer, automatic perfered pointer comparision when comparing
 objects)
\layout Chapter

Fields and FieldContainers
\begin_inset LatexCommand \label{sec:Fields_and_FieldContainer}

\end_inset 


\layout Standard

One central goal of the OpenSG design is easy to use thread-safe data.
 To do that right you need to replicate the data so that every thread can
 have its private copy (called aspect) to work on.
 At some point these different copies will have to be synchronized again,
 and then the parts that actually changed need to be copied from one aspect
 to the other.
 To do that the system needs to know what actually changed, and to know
 that on a sub-class basis.
 As C++ is not reflective, i.e.
 the classes cannot tell the system which members they have, OpenSG needs
 to that itself.
 That's what Fields and FieldContainers are for.
\layout Section

Creating a FieldContainer instance
\begin_inset LatexCommand \label{fcinstance}

\end_inset 


\layout Standard

FieldContainer can be created in two ways: via the 
\family typewriter 
FieldContainerFactory
\family default 
 or from the class's prototype.
 You can not create instances of FieldContainers either via creating automatic
 or static variables or via 
\family typewriter 
new
\family default 
, you have to use the mentioned two ways.
\layout Standard

For generic loaders it is useful to create an object by name, and this is
 what the factory is for.
 The factory is a singleton, the single instance can be accessed via 
\family typewriter 
FieldContainerFactory::the()
\family default 
, which has functions to create arbitrary field containers, with some special
 versions to directly create different subsets of field conatiners (Nodes,
 NodeCores, Attachments).
\layout Standard

For reasons connected to multi-thread support (s.
 
\begin_inset LatexCommand \ref{threadsafety}

\end_inset 

) specific kinds of pointers have to be used.
 For every FieldContainer type 
\family typewriter 
fc
\family default 
 there is a specific pointer type 
\family typewriter 
fcPtr
\family default 
.
 It has all the features of a standard pointer, i.e.
 it can be dereferenced via 
\family typewriter 
->
\family default 
 and it can be downcast to a derived type via 
\family typewriter 
DerivedPtr.dcast( ParentPtr );
\family default 
.
\layout Standard

Creating a new instance of a specific class is done by calling 
\family typewriter 
fcPtr var=fcPtr::create()
\family default 
.
 
\layout Section

Reference counting
\layout Standard

FieldContainers are reference counted.
 They are created with a reference count of 0, and the reference count can
 be manipulated via 
\family typewriter 
addRefCP()
\family default 
 and 
\family typewriter 
subRefCP()
\family default 
.
 
\layout Standard

The system increases the reference count only when it stores a reference
 to an object in the system, e.g.
 when a node is attached to another node.
 It does not increase the reference counter for every parameter that is
 passed around, the pointers mentioned in 
\begin_inset LatexCommand \ref{fcinstance}

\end_inset 

 are not smart pointers.
\layout Standard

The reference count is decreased when an object is removed from the system,
 e.g.
 when a node is detached from another node, or explicitly using 
\family typewriter 
subRefCP()
\family default 
.
 If the reference count goes to or below 0, the object is removed.
 Note that object are created with a reference count of zero, so if a new
 object (refCnt: 0) is attached to a node (increasing the refCnt to 1) and
 removed later on (decreasing it to 0), it will be destroyed.
 Increasing the reference count before ermoving it is needed to prevent
 the destruction.
 
\shape italic 
(we should fill the destroyed fcs with 0xdeadbeef or something similar.
 Does the recursive tree removal work right now?)
\layout Section

Fields
\layout Standard

All data in FieldContainers is organized in fields.
 There are two general types of fields, fields for single values (SFields)
 and fields for multiple values (MFields).
 For the standard types and most pointer and ptr types there are predefined
 instances of both types of fields.
\layout Subsection

Single Fields
\layout Standard

Single fields hold, as the name says, a single value as their content.
 This content can be accessed directly using 
\family typewriter 
getValue();
\family default 
 and 
\family typewriter 
setValue();
\family default 
.
 It can also be copied from another field of the same type via 
\family typewriter 
setValue();
\family default 
 (for fields of the same type) or by 
\family typewriter 
setAbstrValue():
\family default 
 (for fields which have the same type, but are given as an abstract field).
\layout Subsection

Multi Fields
\layout Standard

Multi fields hold, as the name says again, multiple values as their content.
 They are realized as STL vectors and offer a similar interface.
 The field defines types for iterators and references, and the standard
 
\family typewriter 
begin()
\family default 
, 
\family typewriter 
end()
\family default 
, 
\family typewriter 
front()
\family default 
, 
\family typewriter 
back()
\family default 
, 
\family typewriter 
push_back()
\family default 
, 
\family typewriter 
insert()
\family default 
, 
\family typewriter 
erase(), clear()
\family default 
, 
\family typewriter 
size()
\family default 
, 
\family typewriter 
resize(),
\family default 
 
\family typewriter 
reserve()
\family default 
 and other functions.
\layout Standard

In addition it has an interface closer to the single fields.
 It features the 
\family typewriter 
setValue()
\family default 
 variants mentioned above and indexed variants like 
\family typewriter 
getValue(const UInt32 index)
\family default 
 and 
\family typewriter 
setValue(const FieldTypeT &value, const UInt32 index)
\family default 
 methods.
 It also features an OpenSG-style 
\family typewriter 
getSize()
\family default 
 method.
\layout Subsection

FieldContainer Fields
\layout Standard

Each attribute has a name, e.g.
 
\family typewriter 
someValue
\family default 
, and every field container has a set of standard access functions to access
 its fields.
 The field itself can be accessed via 
\family typewriter 
getSFSomeValue()
\family default 
 or 
\family typewriter 
getMFSomeValue()
\family default 
 for single or multiple value fields respectively.
\layout Standard

For SFields containers features 
\family typewriter 
getSomeValue()
\family default 
 and 
\family typewriter 
setSomeValue()
\family default 
 direct access methods.
 The MField 
\family typewriter 
getSomeValue()
\family default 
 method returns the whole field, just like the 
\family typewriter 
getMFSomeValue()
\family default 
 method.
 Some field containers have more access functions, often something like
 an 
\family typewriter 
addSomeValue()
\family default 
 method to simplify adding data to multi fields.
 See the field container docs for details.
\layout Section

Nodes and NodeCores
\layout Standard

Of course the most important structures in a scenegraph are the actual nodes
 that make up the graph.
\layout Standard

OpenSG uses a somewhat different approach than many other systems.
 The node is split into two parts: the actual 
\family typewriter 
Node
\family default 
 and the 
\family typewriter 
NodeCore
\family default 
 (s.
 
\begin_inset LatexCommand \ref{singleParentFig}

\end_inset 

).
 
\layout Standard

The 
\family typewriter 
Node
\family default 
 keeps the general information: the children list, the parent pointer, the
 bounding volume and the core pointer.
 The 
\family typewriter 
Node
\family default 
 can not be shared, every node can only be at one place in the graph, thus
 a single parent pointer is enough.
 There is only one kind of node which kep sall the common information.
 Actions tht depend on the position in the graph, like accessing the accumulated
 matrix to the world coordinate system or the world bounding volume, have
 to be done on the node, as it uniquely defines and identifies the position
 in the graph.
\layout Standard

The 
\family typewriter 
NodeCore
\family default 
 carries the differentiating information for the node.
 There are 
\family typewriter 
NodeCore
\family default 
s for all the different functions needed in the tree: groups, transformations,
 geometry and many more.
 
\family typewriter 
NodeCore
\family default 
s can be shared between different nodes, thus they keep an array or actually
 a MultiField of 
\family typewriter 
Node
\family default 
 pointers.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 238 304
file node_core_share.eps
width 4 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{singleParentFig}

\end_inset 

Single Parent Scene
\end_float 
\layout Section

FieldContainer attachments
\layout Standard

OpenSG field containers and nodes do not feature an unused pointer to attach
 data, usually called user data in other systems.
 Instead, many field containers feature a map to attach specific kinds of
 field containers called attachments.
 The most important ones are 
\family typewriter 
Node
\family default 
s and 
\family typewriter 
NodeCore
\family default 
s, but many others which are not used in large numbers like 
\family typewriter 
Window
\family default 
, 
\family typewriter 
Viewport
\family default 
, 
\family typewriter 
Camera
\family default 
 etc.
 are derived from 
\family typewriter 
AttachmentContainer
\family default 
 and thus can carry attachments.
\layout Standard

The attachments themselves have to be derived from 
\family typewriter 
Attachment
\family default 
 (see 
\begin_inset LatexCommand \ref{sec:creating_new_fcs}

\end_inset 

 for details how to do that).
 There are also predefined attachments, right now the only one is 
\family typewriter 
NameAttachment
\family default 
, which allows assigning a name to the field containers.
\layout Standard

Every 
\family typewriter 
AttachmentContainer
\family default 
 can hold an arbitrary number of attachments.
 The attachments are divided into separate groups, and there can be only
 one attachment of every group attached to an AC.
 Most attachments are a group by themselves, but if needed new ones can
 be used as replacements for their parents.
 
\shape italic 
Is that true? The grouping is somewhat vague.
 
\layout Section

Data separation & Thread safety
\begin_inset LatexCommand \label{threadsafety}

\end_inset 


\layout Standard

One of the primary design goals of OpenSG is supporting multi-threaded applicati
ons.
 For asynchronous threads that means that every thread might need its private
 copy of the data.
 To combine that with easy usability and efficient access OpenSG...
\layout Standard

Duplicate Containers, shared MFIelds, Ptrs
\layout Chapter

Special Node Cores
\layout Section

Group
\layout Section

Transformation
\layout Section

Geometry
\layout Section

DistanceLOD
\layout Description

Material chunk stuff
\layout Description

Geometry property stuff
\layout Chapter

Action and Traversals
\layout Section

Usage
\layout Section

Simple Traversal
\layout Standard


\shape italic 
Need to write it.
 A simple functions that takes a fucntor and passes it every node, and another
 one that takes a function and a data pointer.
\layout Section

Write our own action handler
\layout Chapter

Window
\layout Section

Window
\layout Section

Viewport
\layout Section

Camera
\layout Section

Background
\layout Section

Foreground
\layout Chapter

Loader
\layout Section

Usage
\layout Subsection

Scene
\layout Subsection

Image
\begin_inset LatexCommand \label{imageLoaderSection}

\end_inset 


\layout Section

Write our own
\layout Subsection

Scene
\layout Subsection

Image
\layout Chapter

Creating new FieldContainer classes
\begin_inset LatexCommand \label{sec:creating_new_fcs}

\end_inset 


\layout Standard

Most developer which use OpenSG as scene graph library will probable never
 create own OpenSG FieldContainer classes.
 Simular to widget libs (e.g.
 qt,gtk) people just use inscances (the widgets) but never create new classes.
 
\layout Standard

However, you can always extend the type system of OpenSG to integrate new
 core (e.g.
 a fandy LOD switch) or application specific fielcontainer.
\layout Standard

Fieldcontainer are the system central mechanims to deal with any kind of
 thread save data (see section 
\begin_inset LatexCommand \ref{sec:Fields_and_FieldContainer}

\end_inset 

).
 Therefore, the class declaration must include various extra meta information
 for the field and fieldcontainer type handling.
 
\layout Standard

In most systems (e.g.
 Inventor), you would properply start to write a new class or node by just
 'copy and past' an existend implementation.
 However, since OpenSG needs all this extra meta data it is not a pleased
 but very error proning process to create the field container source by
 hand.
 Instatt, we provide a graphical tool to create and manage the fieldcontainer
 description and implementation.
\layout Standard

The basic idea is that you use de 'field container description editor' ($OSGROOT
/tools/fcdEdit) to create a XML file including the description of your fieldcont
ainer fields and interfaces (see image 
\begin_inset LatexCommand \ref{fcdEditFig}

\end_inset 


\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 267 177
file fcd.eps
width 4 90
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fcdEditFig}

\end_inset 

FcdEdit blabla
\end_float 
 ).
 The tools is also apple to create all the necessary c++ source files.
 The fieldcontainer code is splitted in to classes (e.g.
 for a Foo fieldcontainer: FooBase and Foo).
 This strategy has various advantages:
\layout Description

Type_system_changes: If the OpenSG core team would decide to change the
 code interface for the fieldcontainter type management we can just recreate
 the base classes from the XML description.
 No adaptions 'by hand' are needed.
\layout Description

Interface_changes: If you would like to change the interface of you fieldcontain
er (e.g.
 add another field) later on you can just reedit the xml file in fcdEdit
 and recreate the base classes.
 
\layout Section

XML Description (Foo.fcd)
\layout Standard

Includes all field and meta descriptions for a sincle fieldcontainer.
 Can be read and writen by the fcdEdit tool.
 You should not change it by hand.
 
\layout Section

Field Types (FooFields.h)
\layout Standard

Include the field and pointer declarations the the fieldcontainer to be
 used in other fieldcontainers fields as reference.
 You should not change the file by hand.
\layout Section

Base/Meta Type (FooBase.h, FooBase.inl, FooBase.cpp)
\layout Standard

Holds all the meta and field information.
 Do not change it by hand.
 Use the fcdEdit tool to create the files anew whenever you change the xml
 description.
 
\layout Section

'User Code' implementation (Foo.h, Foo.inl, Foo.cpp)
\layout Standard

Holds the 'user code'.
 The fcdEdit is able to create a skeleton for you fieldcontainer implementation.
 The code does not include any meta information therefor it is not necessary
 to create it anew whenever you change the interface.
 
\layout Standard

Include new action handler or whatever you need as functionality.
 
\layout Section

prototype replacement
\layout Standard


\begin_inset LatexCommand \listoffigures{}

\end_inset 


\layout Standard


\latex latex 

\backslash 
begin{appendix}
\layout Chapter

Code Style
\layout Standard

To be included: A short but sufficient code style description.
\layout Chapter

fcdEdit description
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 484
file fcdEdit-numbered.eps
width 3 100
flags 11

\end_inset 


\end_float 
\layout Enumerate

Node name; don't include the OSG prefix
\layout Enumerate

System Component: needed to define the include convention, usually not used
 by applications.
\layout Enumerate

Parent field container; dont include the OSG prefix
\layout Enumerate

Is Parent a System Component: needed to define include convention.
 has to be set when deriving from a system component.
\layout Enumerate

Library: 
\layout Enumerate

PFTypes
\layout Enumerate

Structure
\layout Enumerate

Field list, shows all field description in a vertical list
\layout Enumerate

Name of the Field
\layout Enumerate

Type of the Field, can be changed/extended with the 'Load Field Types/Reset
 Field Types' mechanisms
\layout Enumerate

Cardinality: defines the field to be a single or multifield (can hold one
 value or any number (0-n))
\layout Enumerate

Access: private/protected/public c++ sty;e access definition
\layout Enumerate

Visibility: internal/external; will be used to create various styles of
 documentation
\layout Enumerate

Header: defines the type header, if unset ...
\layout Enumerate

DefaultValue: The default field value, prototype ?
\layout Enumerate

DefaultHeader: ?
\layout Enumerate

Description: Text description of the Field
\layout Enumerate

New Field: creates a new field
\layout Enumerate

Delete Field: deletes the current field
\layout Enumerate

Clone Field: creates a new field description as clone of the current field
\layout Enumerate

Up: Moves the current field one position up
\layout Enumerate

Down: Movies the current field one position down
\layout Enumerate

New: Restarts the process 
\layout Enumerate

Load:
\layout Enumerate

Load Parent:
\layout Enumerate

ResetFieldTypes:
\layout Enumerate

LoadFieldTypes;
\layout Enumerate

Save:
\layout Enumerate

Save as:
\layout Enumerate

Write Field Container Base Code: Writes the current description as FooBase.h,
 FooBase.inl and FooBase.cpp
\layout Enumerate

Write Field Container Code: Writes the current description as Foo.h Foo.inl
 and Foo.cpp
\layout Enumerate

About
\layout Enumerate

Exit
\layout Enumerate

Node Description: HTML ?
\layout Standard


\latex latex 

\backslash 
end{appendix}
\the_end

#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass book
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
% \usepackage{a4}
\usepackage{babel}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\usepackage{color}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{setspace}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\float_placement htb
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4wide
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout LaTeX


\lang american
% Create Title Page 
\layout LaTeX


\lang american

\backslash 
singlespacing
\layout LaTeX


\lang american

\backslash 
begin{titlepage}
\layout LaTeX


\lang american

\backslash 
thispagestyle{empty}
\layout LaTeX


\lang american

\backslash 
vspace*{
\backslash 
fill}
\layout LaTeX


\lang american

\backslash 
begin{figure*}[htb] 
\layout LaTeX


\lang american

\backslash 
begin{center} 
\layout LaTeX


\lang american
% This breaks Postscript page numbers, include only when necessary
\layout LaTeX


\lang american

\backslash 
includegraphics[height=3.5cm]{opensg_logo.eps} 
\layout LaTeX


\lang american

\backslash 
end{center}
\layout LaTeX


\lang american

\backslash 
end{figure*}
\layout LaTeX


\lang american

\backslash 
begin{center} 
\layout LaTeX


\lang american

\backslash 
vspace*{2cm}
\layout LaTeX


\lang american

\backslash 
textbf{
\backslash 
Large OpenSG  }
\backslash 

\backslash 
[0.5
\backslash 
baselineskip] 
\layout LaTeX


\lang american

\backslash 
textbf{
\backslash 
Large Starter Guide}
\backslash 

\backslash 
[2
\backslash 
baselineskip] 
\layout LaTeX


\lang american

\backslash 
textbf{
\backslash 
Large Version 1.0}
\backslash 

\backslash 
[2
\backslash 
baselineskip] 
\layout LaTeX


\lang american
Written by 
\backslash 

\backslash 
[
\backslash 
baselineskip] 
\layout LaTeX


\lang american

\backslash 
textbf{
\backslash 
large Dirk Reiners 
\backslash 

\backslash 
 Johannes Behr 
\backslash 

\backslash 
 Gerrit Voss} 
\layout LaTeX


\lang american

\backslash 
end{center}
\layout LaTeX


\lang american

\backslash 
vspace*{
\backslash 
fill}
\layout LaTeX


\lang american

\backslash 
end{titlepage}
\layout LaTeX


\lang american

\backslash 
setcounter{page}{1}
\layout LaTeX


\lang american

\backslash 
onehalfspacing
\layout LaTeX

\layout Standard


\lang american

\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Standard


\lang american

\begin_inset LatexCommand \listoffigures{}

\end_inset 


\layout Chapter

Introduction
\layout Standard

Welcome to the OpenSG starter guide.
 This document will help you understand the structure of the OpenSG system
 and the main classes that you need to know to write graphics programs using
 OpenSG.
 It started as a quickstart, but got a little big for that.
 ;) If you're not into reading text, take a look at the tutorial programs
 and come back when you need a little background for specific topics.
\layout Standard

It is not meant to be an introduction to computer graphics or realtime rendering.
 It would actually be useful to be somewhat familiar with another scenegraph
 system, but that's not mandatory.
\layout Standard

It does not explain every single function and its parameters, take a look
 at the Code documentation that is generated by doxygen for that.
 It will also not motivate the decisions taken and alternatives that were
 rejected, see the design document for that.
 This one is for jumpstarting OpenSG usage.
\layout Standard

If you want to send feedback or have further questions you can send them
 either to the OpenSG developer list (
\family typewriter 
opensg-developer@lists.sf.net
\family default 
) or to us directly at 
\family typewriter 
feedback@opensg.org.
\layout Section

What is OpenSG?
\layout Standard

OpenSG is a real-time rendering system based on a scenegraph metaphor.
 It works along the lines of OpenInventor, Performer or Java3D, although
 it is probably closest to Performer.
 It supports parallel processing, albeit in a more general way, and will
 drive multiple displays for multi-screen stereo projection systems.
 The goal is to have something that handles multi-threaded data structures
 as simply as possible without compromising performance too much.
 It should also support heterogeneous multi-pipe applications, i.e.
 multiple different graphics cards running one application.
 Many things are quite easy to do with a little program, but are sometimes
 hard to fit into an existing system.
 Thus accessibility is an important goal, and we're striving to make OpenSG
 very extendable.
\layout Standard

It works on different Unix systems and Windows.
 It compiles with the Microsoft Visual Studio compiler, but that version
 has to use some extremely ugly kludges and is not always maintained, so
 using the Intel compiler, version 5.x, is recommended.
\layout Section

What is OpenSG not?
\layout Standard

OpenSG is not a complete VR system.
 Things like device access and interaction are left out on purpose, there
 are other systems for that.
\layout Section

Where to get it
\layout Standard

If you read this you probably have it already, otherwise take a look at
 http://www.opensg.org/ for the latest released version.
 You can also get it from SourceForge, which we use for project management,
 at http://www.sf.net/projects/showfiles.php?group_id=5283.
\layout Standard

If you want to get access to the current development version you can get
 it from CVS, see http://sourceforge.net/cvs/?group_id=5283 for details.
 Nightly snapshots of the CVS source and libs are available at at www.opensg.org/d
ailybuild_logs.
\layout Section

Compilation
\layout Standard

Short version: ./configure ; make should work.
\layout Standard

Long version: OpenSG uses a relatively standard configure script to adapt
 the options it needs to the system it's compiled on.
 configure is also used to set up optional libraries that are available.
 For Windows you need to use the cygwin environment (http://sources.redhat.com/cyg
win/) to get the needed shell tools.
 There is a Visual Studio Workspace in 
\family typewriter 
Experimental/VS
\family default 
, but it is not actively mainted and thus probably out of date.
 We're working on an automatic way to create it, but right now you're probably
 better off with cygwin.
\layout Standard

All options are optional.
 The most useful ones are 
\family typewriter 
--with-jpg[=<dir>]
\family default 
,
\family typewriter 
 --with-glut[=<dir>]
\family default 
, 
\family typewriter 
--with-qt[=<dir>]
\family default 
, 
\family typewriter 
--with-tif[=<dir>]
\family default 
 and 
\family typewriter 
--with-png[=<dir>]
\family default 
 which specify the directories where the specific libraries/header can be
 found.
 If you need to download these libraries, check http://www.opensg.org/prerequisite
s.EN.html for locations.
 All examples and tutorials use GLUT, so it's highly recommended to configure
 it.
 There are some other options that are less often needed, run 
\family typewriter 
configure --help
\family default 
 to get a full list.
\layout Standard

So for a standard Linux distribution you should call 
\family typewriter 
./configure --with-jpg --with-tif --with-png --with-qt=$QTDIR
\family default 
 to get a useful configuration.
\layout Standard

Configure creates a directory in Builds with a name specific for the current
 system, e.g.
 
\family typewriter 
Builds/i686-pc-linux-gnu-g++/
\family default 
.
 Go into this directory and call 
\family typewriter 
make
\family default 
 to create the libraries.
\layout Standard

In general you can call 
\family typewriter 
make help
\family default 
 in any directory with a makefile to get a list of supported targets in
 this directory.
\layout Section

Installation
\layout Standard

Call 
\family typewriter 
make install
\family default 
 to install the libraries in the place specified to 
\family typewriter 
configure
\family default 
, or 
\family typewriter 
/usr/local
\family default 
 per default.
 You can change the installation directory at install time by specifying
 it as 
\family typewriter 
gmake INSTALL_DIR=<dir> install
\family default 
.
 
\family typewriter 
make install
\family default 
 will copy all include files into a directory 
\family typewriter 
OpenSG
\family default 
 in 
\family typewriter 
$INSTALL_DIR/include
\family default 
 and the libs into 
\family typewriter 
$INSTALL_DIR/lib/dbg
\family default 
 or 
\family typewriter 
$INSTALL_DIR/lib/opt
\family default 
, depending on the optimization used.
 For a local install it's useful to call 
\family typewriter 
make INSTALL_DIR=`pwd` install
\family default 
, which will put everything in the current directory.
\layout Section

Making and executing the test programs
\layout Standard

To build the test programs, go into the 
\family typewriter 
*Test
\family default 
 directory and call make or make Tests.
 
\family typewriter 
make list
\family default 
 lists the available programs in the current directory.
 You can make a specific test program by running the listed command.
\layout Standard

To execute the test programs you need to have the library in your path.
 For that it's easiest to locally install them as described before and (csh/tcsh
) 
\family typewriter 
setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:../lib/dbg
\family default 
 or (sh/bash) 
\family typewriter 
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:../lib/dbg
\family default 
.
 Then you can just run the test programs in the 
\family typewriter 
*Test
\family default 
 directory.
\layout Section

Making and executing the tutorials
\layout Standard

There are a number of tutorial examples in the tutorials directory.
 You need to make and install the libraries first, before making them.
 To actually create them you'll probably have to adapt the 
\family typewriter 
common.*
\family default 
 files to your environment.
 This will become easier when we have our 
\family typewriter 
opensg-config
\family default 
 script, but right you'll have to do it manually.
\layout Section

How to use it
\layout Subsection

Own projects
\layout Standard

OpenSG is just a library, so use it like any other library.
 It has an 
\family typewriter 
opensg-config
\family default 
 script that emits the needed compiler options 
\shape italic 
(I hope it will...
 ;).
 
\shape default 
So you can call 
\family typewriter 
opensg-config --cflags
\family default 
 to get the needed compiler options and 
\family typewriter 
opensg-config --libs
\family default 
 to get the needed linker flags.
 See 
\family typewriter 
tutorials/Makefile
\family default 
 for examples how to do that.
\layout Subsection

Extending OpenSG
\layout Standard

Extending OpenSG is generally trivial: just add your files to the directories,
 they will automagically be picked up by the next compile.
 
\layout Standard

Adding new directories is a little more tricky.
 You need to add your directory to 
\family typewriter 
CommConf/common.libs.in
\family default 
.
 This is not difficult, but hard to explain.
 If you need to do that, take a look at the file, try it and if it doesn't
 work send us an email or use the developer list on SourceForge.
\layout Standard

If you need new libraries you have to add them to the configure script .
 Copy some of the given examples or ask us for help.
\layout Standard

The following chapters introduce you to the main classes and concepts used
 in OpenSG.
 Again, they are not intended to explain every function and its parameters,
 see the doxygen documentation for that, and they are not meant to explain
 the reasons behind the design choices, see the design document for that.
\layout Chapter

OpenSG Basics
\layout Standard

All OpenSG symbols are part of the OSG namespace, and they have no prefix.
 The actual files, including headers, all use the 
\family typewriter 
OSG
\family default 
 prefix.
\layout Section

Base types
\layout Standard

As one goal of OpenSG is the ability to run programs on a lot of different
 platforms, especially Unix and Windows, we have our own types which are
 guaranteed to have the same size on all platforms.
 
\layout Standard

We have our own bool type 
\family typewriter 
Bool
\family default 
, and signed and unsigned integers in all useful sizes: 
\family typewriter 
Int8
\family default 
, 
\family typewriter 
UInt8
\family default 
, 
\family typewriter 
Int16
\family default 
, 
\family typewriter 
UInt16
\family default 
, 
\family typewriter 
Int32
\family default 
, 
\family typewriter 
UInt32
\family default 
, 
\family typewriter 
Int64
\family default 
, 
\family typewriter 
UInt64
\family default 
 as well as the two usual float sizes 
\family typewriter 
Real32
\family default 
 and 
\family typewriter 
Real64
\family default 
.
 Some useful constant are available: 
\family typewriter 
Eps
\family default 
, 
\family typewriter 
Pi
\family default 
, 
\family typewriter 
Inf
\family default 
 and 
\family typewriter 
NegInf
\family default 
.
 A useful construct for template programming is the 
\family typewriter 
TypeConstants<type>
\family default 
 structure, which defines some standard functions/values for the given type,
 see 
\family typewriter 
OSGBaseTypes.h
\family default 
 for details.
\layout Section

Log
\layout Standard

All output that OpenSG generates is channeled through the Log class, which
 is defined in 
\family typewriter 
OSGLog.h
\family default 
.
 OpenSG supplies a global Log object that is used by the library, but the
 application can create its own logs, if needed.
\layout Standard

Every log message has one specific level.
 Available levels are 
\family typewriter 
LOG
\family default 
, 
\family typewriter 
FATAL
\family default 
, 
\family typewriter 
WARNING
\family default 
, 
\family typewriter 
NOTICE
\family default 
, 
\family typewriter 
INFO
\family default 
 and 
\family typewriter 
DEBUG
\family default 
.
 They are also numbered from 0 to 5.
 The verbosity of the system can be controlled by ignoring messages of specific
 levels.
 This can be achieved by calling 
\family typewriter 
osgLog().setLogLevel( <enum> );
\family default 
 or by setting the environment variable 
\family typewriter 
OSG_LOG_LEVEL
\family default 
.
\layout Standard

The system log has two different interfaces.
 One is based on C++ streams, one is based on C printf semantics.
 
\layout Standard

The stream interface can be used by using 
\family typewriter 
SLOG
\family default 
, 
\family typewriter 
SFATAL
\family default 
, 
\family typewriter 
SWARNING
\family default 
, 
\family typewriter 
SNOTICE
\family default 
 or 
\family typewriter 
SINFO
\family default 
 instead of cout or cerr.
 Note that there is no 
\family typewriter 
SDEBUG
\family default 
 for efficiency reasons, as 
\family typewriter 
FDEBUG
\family default 
 can be compiled out.
 These print the position in the code where the log is executed.
 For multi-line outputs you'll only want that on the first line, for the
 other lines use 
\family typewriter 
PLOG
\family default 
, 
\family typewriter 
PFATAL
\family default 
, 
\family typewriter 
PWARNING
\family default 
, 
\family typewriter 
PNOTICE
\family default 
 or 
\family typewriter 
PINFO
\family default 
.
 
\layout Standard

To synchronize multiple outputs from various threads all S* commands lock
 the stream.
 You have to use 'osg::endLog' (e.g.
 SFATAL << 
\begin_inset Quotes eld
\end_inset 

Message
\begin_inset Quotes erd
\end_inset 

 << endLog) to unlock the stream output.
 
\layout Standard

The C interface tries to mimic the printf semantics.
 The following functions can be used for that: 
\family typewriter 
FLOG
\family default 
, 
\family typewriter 
FFATAL
\family default 
, 
\family typewriter 
FWARNING
\family default 
, 
\family typewriter 
FNOTICE
\family default 
, 
\family typewriter 
FINFO
\family default 
 and 
\family typewriter 
FDEBUG
\family default 
.
 The only difference to 
\family typewriter 
printf
\family default 
 is that they have to be called with double parentheses, i.e.
 
\family typewriter 
FWARNING((
\begin_inset Quotes eld
\end_inset 

What do you mean by %s?
\begin_inset Quotes erd
\end_inset 

, s));
\family default 
.
 The nice thing about the C style interface is that the whole output can
 be compiled out.
 Actually, the 
\family typewriter 
FDEBUG
\family default 
 (( )) are only compiled in when 
\family typewriter 
OSG_DEBUG
\family default 
 is set.
 The 
\family typewriter 
OSG_DEBUG
\family default 
 define is automatically set while compiling the system in debug (default)
 mode.
\layout Standard

The user can activate/deactivate various elements per log message during
 runtime by changing the 
\family typewriter 
LogHeaderElem
\family default 
 mask.
 The following elements are supported right now: 
\layout Standard


\family typewriter 
LOG_BEGIN_NEWLINE_HEADER
\family default 
 (creates an extra newline in front of every output), 
\family typewriter 
LOG_TYPE_HEADER
\family default 
 (writes the Level (e.g.
 WARNING) as first element), 
\family typewriter 
LOG_TIMESTAMP_HEADER
\family default 
 (writes a timestamp), 
\family typewriter 
LOG_MODULE_HEADER
\family default 
 (writes the name of the current module), 
\family typewriter 
LOG_FILE_HEADER
\family default 
 (writes the source file name), 
\family typewriter 
LOG_LINE_HEADER
\family default 
 (writes the source line number) and 
\family typewriter 
LOG_END_NEWLINE_HEADER
\family default 
 (creates an extra newline at the end) 
\layout Standard

When unchanged, the timestamp will be the time in seconds since the programm
 started.
 The user can set/reset the timestamp at any time (e.g.
 
\family typewriter 
osgLog().resetRefTime())
\family default 
.
\layout Section

Time & Date
\layout Standard

To wrap time and date handling we have a little abstraction for them.
 
\layout Standard


\family typewriter 
getSystemTime()
\family default 
 returns the current time since system has been started in seconds, using
 the highest resolution timer available.
\layout Standard

The Date class provides a second resolution timestamp, factored into second,
 minute, hour, day, month and year.
 Date::setSystemDate() can be used to set it to the current date/time.
\layout Section

Math
\layout Standard

Of course every scenegraph needs the basic math objects like Vectors, Points,
 Matrices, Quaternions etc., and OpenSG is no exception.
\layout Subsection

Matrices
\layout Standard

OpenSG matrices are similar to the OpenGL matrices in their storage structure
 and conventions, i.e.
 a matrix is per default a 4x4 
\family typewriter 
Real32
\family default 
 matrix, and the multiplication convention is just like OpenGL's: 
\begin_inset Formula \( v'=M*v \)
\end_inset 

.
 
\layout Standard

The matrix is stored column major and access methods respect the storage
 format, i.e.
 
\family typewriter 
matrix[0]
\family default 
 yields the first column.
 This is also true for the vector-based constructor.
 However, the constructor taking 16 single elements expects its parameters
 row-major like the matrix is written on paper.
 
\emph on 
(Guys, this is weird!)
\layout Standard

The positive side effect of this setup is the ability to access the base
 vectors of the matrix' coordinate space 
\emph on 
(what should that be?)
\emph default 
 by accessing the vectors, i.e.
 
\family typewriter 
matrix[3]
\family default 
 is the translation to the origin of the local coordinate space 
\emph on 
(assuming w = 1...
 generally the column vectors describe what's being done to the components
 of the vector to be transformed, the row vectors the results per component.
 Neither access is necessarily preferable)
\emph default 
.
 This is useful if you want to create your matrices from vectors, if you
 don't want to do that, dont' worry about it.
 
\emph on 
(I would tend to recommend to waive this little discussion; it's more confusing
 then helping)
\layout Standard

Setting the contents of a matrix is done by the 
\family typewriter 
setValues()
\family default 
 methods, accessing the values via the 
\family typewriter 
[]
\family default 
 operator for access to single columns or by using 
\family typewriter 
getValues()
\family default 
 to get a pointer to the first element.
 In general most classes in OpenSG that keep an array of elements allow
 access to them via 
\family typewriter 
getValues()
\family default 
.
\layout Standard

If you need to create a matrix for a specific transformation, use the 
\family typewriter 
setTransform()
\family default 
 methods, which create a matrix that executes the given transformation.
 There are also 
\family typewriter 
setScale()
\family default 
, 
\family typewriter 
setTranslate()
\family default 
, 
\family typewriter 
setRotate(),
\family default 
 etc.
 methods, but these only set the respective parts of the matrix and don't
 clear the rest, so be careful when using these 
\emph on 
(so what happens to the scale if I set a rotation?)
\emph default 
.
\layout Standard

Matrices also supply the standard set of matrix operations like 
\family typewriter 
det()
\family default 
, 
\family typewriter 
det3()
\family default 
, 
\family typewriter 
invert()
\family default 
, 
\family typewriter 
transpose()
\family default 
, 
\family typewriter 
mult()
\family default 
 and 
\family typewriter 
multLeft()
\family default 
.
 There are some variants that change the matrix in place, return their results
 in a different matrix or get their source data from a different matrix,
 see the class docs for details.
 
\shape italic 
What's the point of having both?
\layout Standard

The default vector/point multiplication methods 
\family typewriter 
multMatrixPnt()
\family default 
 and 
\family typewriter 
multMatrixVec()
\family default 
 assume that the matrix only uses the standard 3x4 elements.
 To use the full 4x4 matrix use 
\family typewriter 
multFullMatrixPnt()
\family default 
.
 As Vectors have a 
\begin_inset Formula \( w \)
\end_inset 

 coordinate of 0 they don't need a full transform.
\layout Subsection

Vectors/Points/Colors
\layout Standard

OpenSG is different from most other systems in differentiating between vectors,
 points and colors.
 
\layout Standard

Vectors are the most common class, and they should behave like every other
 vector library on the planet.
 They are templated to simplify having variants, and the standard ones that
 are available are 
\family typewriter 
Vec4ub
\family default 
, 
\family typewriter 
Vec2s
\family default 
, 
\family typewriter 
Vec2f
\family default 
, 
\family typewriter 
Vec3f
\family default 
 and 
\family typewriter 
Vec4f
\family default 
.
 They have operators for the scalar operations, and methods for everything
 else, see the doxygen docs for 
\family typewriter 
osg::VectorInterface
\family default 
 for details.
 Conceptually the 3 element vector has a w coordinate of 0, thus there is
 no full matrix multiplication for vectors.
\layout Standard

Points represent positions in space, and as such they are more restricted
 than vectors.
 The available variants are 
\family typewriter 
Pnt2f
\family default 
, 
\family typewriter 
Pnt3f
\family default 
 and 
\family typewriter 
Pnt4f
\family default 
.
 Some vector operations (dot, cross, etc.) don't make sense for points.
 Points can be subtracted (creating a vector), scaled and a vector can be
 added to or subtraced from them.
 If you want to represent a position, use a point.
 It helps keeping the concepts in order and not mix up everything just because
 it has the same data.
 If you really need to get from a point to a vector, you can use 
\family typewriter 
Vector &osg::Point.toVector()
\family default 
 to cast the point to a vector.

\shape italic 
 should we do that? It would ease the pain, but undermine the distinction.
 
\shape default 
When multiplied with a matrix, the w coordinate is set as 1 for 3 element
 points.
 
\layout Standard

Colors are RGB vectors, which also have access functions to the named components.
 They also allow access via the HSV color model and scalar multiplication,
 but no other operations.
 
\shape italic 
should we change that? Derive them from vector?
\layout Subsection

Quaternions
\layout Standard

Quaternions are the standard way to represent rotations.
 OpenSG quaternions feature the standard set of methods to get and set the
 rotations, in variants for radians and degrees.
 The standard order of the components is 
\family typewriter 
x
\family default 
,
\family typewriter 
y
\family default 
,
\family typewriter 
z
\family default 
,
\family typewriter 
w
\family default 
.
 The standard operations (
\family typewriter 
length
\family default 
, 
\family typewriter 
normalize
\family default 
, 
\family typewriter 
mult
\family default 
) are available, as well as 
\family typewriter 
slerp
\family default 
 and 
\family typewriter 
multVec
\family default 
.
\layout Section

Line 
\begin_inset LatexCommand \label{sec:line}

\end_inset 


\layout Standard

A Line defines a ray in space.
 It is defined by an origin and a direction, which is stored normalized.
 Lines can be constructed from two points or directly from a point and a
 direction.
 
\layout Standard

A line can be intersected with all the bounding volumes and geometry.
 Only the positive parameter range of the line is intersected.
\layout Standard

The line can also find the closest point on itself to a given point or another
 line.
\layout Section

Plane
\layout Standard

A Plane defines a 3D infinite halfspace.
 It is defined by a normal and the distance from the origin, and can be
 constructed from all useful combinations of points and vectors.
\layout Standard

Planes can also be intersected with infinite lines, if needed.
 Points can be tested for lying on the plane, or being in the positive halfspace
 of the plane.
\layout Section

Volumes
\layout Standard

Volumes are primarily used for bounding geometry to speed up culling or
 intersection tests.
 All Volumes are derived from 
\family typewriter 
Volume
\family default 
.
 The supported volumes are the usual 
\family typewriter 
BoxVolume
\family default 
, defined by min and max points, the 
\family typewriter 
SphereVolume
\family default 
, defined by center and radius, and the 
\family typewriter 
FrustumVolume
\family default 
, which is defined by 6 planes and primarily used to define the viewing
 frustum.
\layout Standard

Volumes are created empty (i.e.
 zero volume) and can be changed by extending them by a point or another
 volume.
 All volumes have a variety of access functions, some specific to the type
 of volume, some general.
 Every volume supports 
\family typewriter 
getBounds()
\family default 
 to access the min/max points, 
\family typewriter 
getCenter()
\family default 
 and 
\family typewriter 
getScalarVolume()
\family default 
 to access the volume measure.
 Volumes can be intersected with points, lines and other volumes, and they
 can be transformed by a matrix.
\layout Standard

Volumes can be in one of several states.
 The default state is valid, special states are invalid, empty, infinite
 and static.
 There are specific functions to set them to any one of those states and
 to check if they are in any of those states.
\layout Standard

Invalid volumes have to be set to valid explicitly, before extending them
 has any effect.
 
\family typewriter 
setEmpty()
\family default 
 makes it valid implicitly.
 The states except empty define how extensions and intersections are handled.
 Invalid volumes stay invalid and ignore changes, static and infinite volumes
 keep their values and are not changed by extensions.
 Intersecting an infinite volume is always true, just as intersecting an
 empty volume is never true.
 
\layout Section

Threads
\layout Standard

OpenSG supports a thread abstraction to support efficient threading on all
 supported platforms.
 On Windows that means Windows threads, on Irix sproc() is used, for every
 other system pthreads are used.
\layout Standard

Every thread uses a 
\family typewriter 
Thread
\family default 
 object for thread-specific data, most of which is needed for thread-safe
 data, see 
\begin_inset LatexCommand \ref{threadsafety}

\end_inset 

.
 To create a new thread, the Thread object has a 
\family typewriter 
run()
\family default 
 method, which executes a given function in a new thread.
 
\layout Standard

For thread synchronization 
\family typewriter 
Lock
\family default 
 and 
\family typewriter 
Barrier
\family default 
 objects are available.
 They act like standard locks and barriers, see the doc for details.
\layout Section

Image
\begin_inset LatexCommand \label{sec:image}

\end_inset 


\layout Standard

Defines and holds a 1D/2D/3D image and optionally a mipmap pyramid and/or
 a list of equally sized frames with a single frameDelay.
 Various pixelTypes are supported to handle grey and RGB color images with
 or without alpha channel.
 The image data starts in the lower left (front) corner and all bytes for
 a single pixel (e.g.
 RGB) are stored sequentially in memoy.
 They are not organized in separate layers or channels.
 
\layout Standard

An Image is only a container for the pixel data and image descrition.
 It does not create or handle any OpenGL state elements.
 However, image objects are utilized to handle the data for texture (e.g.
 SimpleTextureMaterial) or bitmap objects (e.g.
 ImageForeground).
 
\layout Standard

The system provides loader and writer for various formats (see section 
\begin_inset LatexCommand \ref{imageLoaderSection}

\end_inset 

).
 The graph loaders (e.g.
 OSGLoader, VRMLLoader) use image loaders to fetch the raster data.
 
\layout Section

IDString
\layout Standard

A primitive string class.
 Mainly used for string IDs (e.g.
 node type names).
 It is not a generic class like the std::string implementation.
 It's only for internal use to built efficient maps for names, not for applicati
on use.
 If you need a string class use std::string instead.
 
\layout Standard

We decided to create our own specific string class since the std::string
 did not provide all features we needed (e.g.
 shared memory pointer, automatic preferred pointer comparison when comparing
 objects)
\layout Section

Functors
\layout Standard

Functors are the main method for OpenSG to call configurable actions.
 Functors wrap calls to a standard function, to a member of a specific instance
 or to a member of the first parameter.
 
\layout Standard

Functors will have to be redesigned for 1.1, as they don't compile using
 the Microsoft Visual Studio compiler.
 :( Thus we don't talk much about them here, if you need to add a new action
 or GL object, send us mail.
\layout Chapter

Fields and FieldContainers
\begin_inset LatexCommand \label{sec:Fields_and_FieldContainer}

\end_inset 


\layout Standard

One central goal in OpenSG's design is easy to use thread-safe data.
 To do that right, you need to replicate the data so that every thread can
 have its private copy (called aspect) to work on.
 At some point these different copies will have to be synchronized, and
 then the parts that actually changed need to be copied from one aspect
 to another.
 To do that, the system needs to know what actually changed.
 As C++ is not reflective, i.e.
 the classes cannot tell the system which members they have, OpenSG needs
 to keep track of the changes.
 That's what Fields and FieldContainers are for.
\layout Section

Creating a FieldContainer instance
\begin_inset LatexCommand \label{fcinstance}

\end_inset 


\layout Standard

FieldContainer can be created in two ways: By using the 
\family typewriter 
FieldContainerFactory
\family default 
 or from the class's prototype.
 You cannot create instances of FieldContainers neither by creating automatic
 or static variables nor by calling 
\family typewriter 
new
\family default 
.
 You have to use the mentioned two ways.
\layout Standard

For generic loaders it is useful to create an object by name, and this is
 what the factory is for.
 The factory is a singleton, the single instance can be accessed via 
\family typewriter 
FieldContainerFactory::the()
\family default 
, which has functions to create arbitrary field containers, with some special
 versions to directly create different subsets of field containers (Nodes,
 NodeCores, Attachments).
\layout Standard

For reasons connected to multi-threading (s.
 
\begin_inset LatexCommand \ref{threadsafety}

\end_inset 

) specific kinds of pointers have to be used.
 For every FieldContainer type 
\family typewriter 
fc
\family default 
 there is a specific pointer type 
\family typewriter 
fcPtr
\family default 
.
 It has all the features of a standard pointer, i.e.
 it can be dereferenced via 
\family typewriter 
->
\family default 
 and it can be downcasted to a derived type by 
\family typewriter 
DerivedPtr.dcast( ParentPtr );
\family default 
.
\layout Standard

Creating a new instance of a specific class is done by calling 
\family typewriter 
fcPtr var=fcPtr::create()
\family default 
.
 
\layout Section

Reference counting
\layout Standard

FieldContainers are reference-counted.
 They are created with a reference count of 0, and the reference count can
 be manipulated through 
\family typewriter 
addRefCP()
\family default 
 and 
\family typewriter 
subRefCP()
\family default 
.
 
\layout Standard

The system increases the reference count only when it stores a reference
 to an object in the system, e.g.
 when a node is attached to another node.
 It does not increase the reference counter for every parameter that is
 passed around, the pointers mentioned in 
\begin_inset LatexCommand \ref{fcinstance}

\end_inset 

 are not smart pointers.
\layout Standard

The reference count is decreased when an object is removed from the system,
 e.g.
 when a node is detached from another node, or explicitly using 
\family typewriter 
subRefCP()
\family default 
.
 If the reference count goes to or below 0, the object is removed.
 Note that objects are created with a reference count of zero, so if a new
 object (refCnt: 0) is attached to a node (increasing the refCnt to 1) and
 removed later on (decreasing it to 0), it will be destroyed.
 Increasing the reference count before removing it is needed to prevent
 the destruction.
 
\shape italic 
(we should fill the destroyed fcs with 0xdeadbeef or something similar.
 Does the recursive tree removal work right now?)
\layout Section

Manipulation
\layout Standard

The FieldContainer is the basic unit for multi-thread safety.
 To synchronize changes between different copies of the data the system
 needs to know when and what changed.
 
\layout Standard

This has to be done explicitly by the program.
 Thus, before changing a FieldContainer 
\family typewriter 
beginEditCP(fcPtr, fieldMask);
\family default 
 has to be called.
 After the changes to the FieldContainer are done this also has to be communicat
ed by calling 
\family typewriter 
endEditCP(fcPtr, fieldMask);
\family default 
.Here,
\family typewriter 
 fcPtr
\family default 
 is the pointer to the FieldContainer being changed, 
\family typewriter 
fieldMask
\family default 
 is a bitmask describing the fields that are changed.
 Every FieldContainer defines 
\layout Section

Fields
\layout Standard

All data in FieldContainers is organized in fields.
 There are two general types of fields, fields for single values (SFields)
 and fields for multiple values (MFields).
 For the standard types and most pointer and ptr types there are predefined
 instances of both types of fields.
\layout Subsection

Single Fields
\layout Standard

Single fields hold, as the name says, a single value.
 Their content can be accessed directly using 
\family typewriter 
getValue();
\family default 
 and 
\family typewriter 
setValue();
\family default 
.
 It can also be copied from another field of the same type by 
\family typewriter 
setValue();
\family default 
 (for fields of the same type) or by 
\family typewriter 
setAbstrValue();
\family default 
 (for fields which have the same type, but are given as an abstract field).
\layout Subsection

Multi Fields
\layout Standard

Multi fields hold multiple values.
 They are realized as STL vectors and offer a similar interface.
 The field defines types for iterators and references, and the standard
 
\family typewriter 
begin()
\family default 
, 
\family typewriter 
end()
\family default 
, 
\family typewriter 
front()
\family default 
, 
\family typewriter 
back()
\family default 
, 
\family typewriter 
push_back()
\family default 
, 
\family typewriter 
insert()
\family default 
, 
\family typewriter 
erase(), clear()
\family default 
, 
\family typewriter 
size()
\family default 
, 
\family typewriter 
resize(),
\family default 
 
\family typewriter 
reserve()
\family default 
 and other functions.
\layout Standard

In addition, Multi fields have an interface reminiscent of single fields.
 It features the 
\family typewriter 
setValue()
\family default 
 variants mentioned above and indexed variants like 
\family typewriter 
getValue(const UInt32 index)
\family default 
 and 
\family typewriter 
setValue(const FieldTypeT &value, const UInt32 index)
\family default 
 methods.
 It also features an OpenSG-style 
\family typewriter 
getSize()
\family default 
 method.
\layout Subsection

FieldContainer Fields
\layout Standard

Each attribute has a name, e.g.
 
\family typewriter 
someValue
\family default 
, and every field container has a set of standard access functions to access
 its fields.
 The field itself can be accessed via 
\family typewriter 
getSFSomeValue()
\family default 
 or 
\family typewriter 
getMFSomeValue()
\family default 
 for single or multiple value fields respectively.
\layout Standard

For SFields containers features 
\family typewriter 
getSomeValue()
\family default 
 and 
\family typewriter 
setSomeValue()
\family default 
 direct access methods.
 The MField 
\family typewriter 
getSomeValue()
\family default 
 method returns the whole field, just like the 
\family typewriter 
getMFSomeValue()
\family default 
 method.
 Some field containers have more access functions, often something like
 an 
\family typewriter 
addSomeValue()
\family default 
 method to simplify adding data to multi fields.
 See the field container docs for details.
\layout Section

Nodes and NodeCores
\layout Standard

Of course the most important structures in a scenegraph are the actual nodes
 that make up the graph.
\layout Standard

OpenSG uses a somewhat different approach than many other systems.
 A node is split into two parts: the 
\family typewriter 
Node
\family default 
 and a 
\family typewriter 
NodeCore
\family default 
 (s.
 
\begin_inset LatexCommand \ref{singleParentFig}

\end_inset 

).
 
\layout Standard

A 
\family typewriter 
Node
\family default 
 keeps the general information: a children list, a parent pointer, a bounding
 volume and a core pointer.
 Note that the node itself contains no information about its type (e.g.
 transform, group, etc.).
 A 
\family typewriter 
Node
\family default 
 cannot be shared, every node can only be at one place in the graph, thus
 a single parent pointer is enough.
 All nodes together define the topology of the graph, without defining any
 content.
 Actions that depend on a position in the graph, like accessing the accumulated
 matrix to the world coordinate system or the world bounding volume, have
 to be done on the node, as it uniquely defines and identifies the position
 in the graph.
\layout Standard

A 
\family typewriter 
NodeCore
\family default 
 carries the differentiating information for a node.
 There are 
\family typewriter 
NodeCore
\family default 
s for all the different functions needed in the tree: groups, transformations,
 geometry and many more.
 
\family typewriter 
NodeCore
\family default 
s can be shared between different nodes, thus they keep an array or actually
 a MultiField of 
\family typewriter 
Node
\family default 
 pointers.
\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 238 304
file node_core_share.eps
width 4 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{singleParentFig}

\end_inset 

Single Parent Scene
\end_float 
\layout Section

FieldContainer attachments
\layout Standard

OpenSG field containers and nodes do not feature an unused pointer to attach
 data, usually called user data in other systems.
 Instead, many field containers feature a map to attach specific kinds of
 field containers called attachments.
 The most important ones are 
\family typewriter 
Node
\family default 
s and 
\family typewriter 
NodeCore
\family default 
s, but many other like 
\family typewriter 
Window
\family default 
, 
\family typewriter 
Viewport
\family default 
, 
\family typewriter 
Camera
\family default 
, etc.
 are derived from 
\family typewriter 
AttachmentContainer
\family default 
 and, therefore, can carry attachments.
\layout Standard

Attachments have to be derived from 
\family typewriter 
Attachment
\family default 
 (see 
\begin_inset LatexCommand \ref{sec:creating_new_fcs}

\end_inset 

 for details how to do that).
 There are also predefined attachments, right now the only one is 
\family typewriter 
NameAttachment
\family default 
, which allows assigning a name to the field containers.
\layout Standard

Every 
\family typewriter 
AttachmentContainer
\family default 
 can hold an arbitrary number of attachments.
 Attachments are divided into separate groups, and there can be only one
 attachment of every group attached to an AC.
 Most attachments are a group, but if needed new ones can be used as replacement
s for their parents.
 
\shape italic 
Is that true? The grouping is somewhat vague.
 
\layout Section

Data separation & Thread safety
\begin_inset LatexCommand \label{threadsafety}

\end_inset 


\layout Standard

One of the primary design goals of OpenSG is supporting multi-threaded applicati
ons.
 For asynchronous threads that means that every thread might need its private
 copy of the data.
 To combine that with easy usability and efficient access we decided to
 replicate at the field container level.
 
\layout Standard

When a field container is created not only one instance is created but multiple,
 per default 2.
 These are called aspects, and every running thread is associated with one
 of them.
 Whenever data is changed in a thread, only the aspect that's associated
 with it is changed, the rest is left as is.
\layout Standard

shared MFIelds, Ptrs, begin/endEdit, Changelist sync
\layout Chapter

Special Node Cores
\layout Standard

NodeCores define the specific behaviour of the scenegraph nodes.
 Note that we refer to the combination of a Node and the respective NodeCore
 with the core's name, i.e.
 a Group node is a Node with a Group NodeCore.
\layout Section

Group
\layout Standard

A Group is the simplest NodeCore, it doesn't do much.
 If asked to do something it calls its children to do the same thing, if
 asked for information it gathers it from the children.
 Really basic.
\layout Section

Switch
\layout Standard

A Switch node allows to select one of its children for traversal instead
 of all of them (as for the other nodes).
\layout Section

Transform
\layout Standard

A Transform Core is the basic means of moving objects around the scene.
 It keeps a single Matrix that is applied to all its children.
\layout Section

ComponentTransform
\layout Standard

A ComponentTransform is close to a Transform, but the transformation is
 defined in an easier to use way, the same way it is done in systems like
 OpenInventor or VRML.
 It consists of a center and a rotation around that center, followed by
 a scale relative to a given scaleOrientation, which is finally followed
 by a translation.
\layout Section

DistanceLOD
\layout Standard

Levels of Detail are a simple way of increasing rendering performance.
 The basic idea is to have a number of differently detailed versions of
 an object and use low-res versions for objects that are far away.
 
\layout Standard

A DistanceLOD is the simplest version, which switches versions based on
 distance to the viewer.
 There is a distance associated with every child of the Node, the details
 follow the VRML specification.
\layout Section

Lights
\layout Standard

A Light defines a source of light in the scene.
 Generally, two types of information are of interested: The position of
 the light source (geometry), and what elements of the scene are lit (semantics).
 Since the graph structure essentially describes the semantics of the scene,
 the node containing the Light describes what is lit: The subgraph attached
 to the Light.
 Necessarily, the position in space of a Light has to be defined by other
 means than the accumulated transform to the Light's node as the subgraphs
 position and orientation might coincide with the light source's.
\layout Standard

To define the position and orientation of the light a separate node, a 
\shape italic 
beacon
\shape default 
, is used.
 The light has a SFNodePtr to reference the beacon, which can be anywhere
 in the scene.
 A light is positioned in the coordinate system of the beacon.
 Tip: Using the beacon of the camera (see 
\begin_inset LatexCommand \ref{sec:camera}

\end_inset 

) as the beacon of a light source creates a headlight.
\layout Standard

Every light is closely related to OpenGL's light specification.
 It has a diffuse, specular and ambient color.
\layout Standard

Additionally it can be switched on and off using the 
\family typewriter 
on
\family default 
 field.
\layout Subsection

DirectionalLight
\layout Standard

The DirectionalLight just has a direction.
 To use it as a headlight use (0,0,-1) as a direction.
\layout Subsection

PointLight
\layout Standard

The Pointlight has a position to define its location.
 In addition, as it really is located in the scene, it has an attenuation
 parameters to change the light's intensity depending on the distance to
 the light.
\layout Subsection

SpotLight
\layout Standard

The SpotLight adds a direction to the PointLight and a spotCutOff angle
 to define the area that's lit.
 To define the light intensity fallof within that area the spotExponent
 field is used.
\layout Section

Geometry
\layout Standard

Geometries make up the leaves of the graph and ultimately define what's
 being rendered.
 Geometry has to be flexible, to accomodate the needs of the application.
 Different data types for the data that defines the geometry are useful,
 as well as different indexing capabilities to reuse data as much as possible.
 On the other hand, it also has to be efficient to render.
 Flexibility and performance don't always go well together, thus, there
 are some simplifications to make.
\layout Standard

OpenSG geometry is modeled closely following OpenGL.
 The data that make up the geometry are stored in separate arrays.
 Positions, Colors, Normals and Texture Coordinates all have their own arrays,
 (or MultiFields, to stay in OpenSG terminology)).
 As OpenGL can handle a lot of different formats for the data, some of which
 might be more appropriate due to speed and memeory consumption than others,
 depending on the application, OpenSG features different version of this
 data, allowing all the variants that OpenGL allows.
 To allow that with type sefaty and without having a separate geometry class
 for every possible combination the data fields are stored in separate field
 containers, so called GeoProperties.
 There are separate GeoProperties for different attributes, and variants
 for different data types for each kind of GeoProperty.
 The most prominent types are probably GeoPositions3f for Pnt3f positions,
 GeoNormals3f for Vec3f normals, GeoColors3f for Color3f colors and GeoTexCoords
2f for Vec2f texture coordinates, but all other variants are possible.
 
\layout Standard

As properties only have a single field they can mimic that field by exposing
 parts of the standard MultiFeld interface for their contents, so you can
 use a GeoProperty pretty much just like a MultiField.
 One problem with the type variety is that writing functions that work on
 every type of property can become tedious, as you have to have a big switch
 for every kind of data that could arrive.
 To make that easier for every property there is defined generic format,
 e.g.
 for Positions the format is Pnt3f.
 A property has a getValue()/setValue() interface for these generic types,
 i.e.
 every porperty, no matter in what format it stores the data, can be used
 as if it used the generic format.
 Of course, this is not as efficient as directly accessing the data, but
 if speed is not the highest priority or as a fallback it's quite useful.
 And, finally, GeoProperties feature an interface for OpenGL vertex arrays,
 giving access to the data and the types involved, which is used for rendering.
\layout Standard

In addition to the abovementioned data there are some other GeoProperties.
 OpenSG allows multiple primitive types per geometry, i.e.
 you can freely mix triangles, triangle strips and polygons in a single
 geometry node.
 The GeoPTypes property defines the type of the primitives used.
 Right now, it only exists as a GeoPTypesUI32 variant, but others may follow.
 The number of vertices per primitive is defined by another property, the
 GeoPLengths property.
 This, too, only exists in a GeoPLengthsUI32 variant right now.
 
\layout Standard

Using these properties it is possible to define geometry (see fig.
 
\begin_inset LatexCommand \ref{fig:geo_non_indexed}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 476 225
file geo_nonindexed.eps
width 3 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:geo_non_indexed}

\end_inset 

Non-Indexed Geometry
\end_float 
One additional advantage of separating properties from Geometry is the ability
 to share properties between geometry nodecores.
 As geometries can only have one material right now that's useful for simplifyin
g the handling of objects with multiple materials.
\layout Standard

This simple geometry has one problem: there is no way to reuse vertex data.
 When a vertex is to be used multiple times, it has to be replicated, which
 can increase the amount of memory needed significantly.
 Thus, some sort of indexing to reuse vertices is needed.
 You can guess what's coming? Right, another property.
\layout Standard

Indices are stored in the GeoIndices property, which only exists in the
 GeoIndicesUI32 variant right now.
 When indices are present the given lengths define how many indices are
 used to define the primitive, while that actual data is indexed by the
 indices (see fig.
 
\begin_inset LatexCommand \ref{fig:geo_indexed}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 476 225
file geo_indexed.eps
width 3 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:geo_indexed}

\end_inset 

Indexed Geometry
\end_float 
Indexed geometry is very close to OpenGL, and probably the most often used
 type of geometry.
 It doesn't handle all the cases, though.
\layout Standard

Sometimes vertices need different additional attributes, even though they
 have the same position.
 One example are discontinuities in texture coordinates, e.g.
 when texturing a simple cube.
 The edges of the cube don't necessarily use the same texture coordinate.
 To support that a single indexed geometry has to replicate the vertices.
\layout Standard

To get around that you need multiple indices per vertex to index the different
 attributes.
 Adding an index for every attribute would blow up the geometry significantly
 and not neccessarily make it easier to use.
 We decided to use another way: interleaved indices (see fig.
 
\begin_inset LatexCommand \ref{fig:geo_multi_index}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 476 212
file geo_multiindexed.eps
width 3 80
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:geo_multi_index}

\end_inset 

Multi-Indexed Geometry
\end_float 
Interleaved indices require every vertex to hold multiple indices.
 Which index is used for what attribute is defined by a separate indexMapping
 field.
 The indexMapping field is a UInt32 multifield.
 The possible values are bitwise combinations of the available attribute
 masks: Geometry::MapPosition, Geometry::MapNormal etc.
 The length of the indexMapping defines how many indices are used per vertex.
 If it's not set a single index for all available properties is used (or
 none at all).
\layout Standard

In addition to the properties geometry keeps a MaterialPtr to define the
 material that's used for rendering the geometry (see sec.
 
\begin_inset LatexCommand \ref{sec:materials}

\end_inset 

) and a flag that activates caching the geometry in OpenGL display lists.
 As geometry rendering is not optimized very much right now that's the best
 way to get decent performance.
 Display lists are turned on by default.
\layout Subsection

Geometry Iterators
\layout Standard

The above setup is very nice and flexible to define: you can mix different
 kinds of primitives in an object, you can have properties and different
 kinds and the indexing allows the reuse of some or all of the data.
\layout Standard

From the other side of the fence things look difficult: if you want to walk
 over all traingles of a geometry to calculate the average triangle size
 or the surface area, or for calculating face normals or for whatever reason
 you have to take care of all the flexibility and be prepared for lots of
 different ways to define geometry.
\layout Standard

To simplify that the concept of a geometry iterator has been introduced.
 A geometry iterator allows to iterate over a given geometry primitive by
 primitive, face by face (a face being a triangle or quad), or triangle
 by triangle.
 
\layout Standard

All of them are used like STL iterators: the geometry has methods to pass
 the first or last+1th iterator (
\family typewriter 
begin()
\family default 
 and 
\family typewriter 
end()
\family default 
) , and to step from one element to the next use 
\family typewriter 
++
\family default 
.
 They can also unify the different indices: when using an iterator you can
 access the index value for each attribute of each vertex of the iterator
 separately.
 Or you can directly access the data that's behind the index in its generic
 form.
 
\layout Standard

If you're used to having a separate Face object that keeps all the data
 for a separate face, the Iterators pretty much mimic that behaviour.
 The one thing you can't do using iterators is changing the data.
\layout Standard

The 
\family typewriter 
PrimitiveIterator
\family default 
 is the basic iterator that just iterates through the 
\family typewriter 
GeoPTypes
\family default 
 property and gives access to the primitive's data.
 It is useful to solve the index mapping complications and to get access
 to the generic data, but it's primarily a base class for the following
 two iterator types.
\layout Standard

The 
\family typewriter 
FaceIterator
\family default 
 only iterates over polygonal geometry and ignores points and lines.
 It also splits the geometry into triangles or quads.
 
\layout Standard

The 
\family typewriter 
TriangleIterator
\family default 
 behaves like the 
\family typewriter 
FaceIterator
\family default 
, but it also splits Quads into two triangles, thus it does an implicit
 triangulation.
 As OpenSG just like OpenGL doesn't support concave geometry that's not
 as hard as it sounds.
\layout Standard

The iterators can also be used to indicate a specific primitive/face/triangle.
 Each of these has an associated index that the iterator keeps and that
 can be accessed using 
\family typewriter 
getIndex()
\family default 
.
 A new iterator can be used to 
\family typewriter 
seek()
\family default 
 a given primitive/face/triangle again and work on it.
 This is used for example in the 
\family typewriter 
IntersectAction
\family default 
.
\layout Chapter

Materials
\begin_inset LatexCommand \label{sec:materials}

\end_inset 


\layout Standard

Materials define the surface properties of the geometry.
 For the standard Phong lighting model that OpenGL uses these are ambient,
 diffuse and specular color as well as shininess.
 However, this is an area where extensions are added at an amazing pace.
 The purpose of materials is to add a level of abstraction and give the
 user an easy to use interface to define surface properties without having
 to worry about how to realize this.
\layout Standard

Thus, every geometry needs to have a material associated with it by means
 of the 
\family typewriter 
material
\family default 
 field.
\layout Standard

This area is quickly expanding, so what we have right now is just the beginning.
\layout Section

Material types
\layout Standard

Right now there are only the simple materials that OpenGL supports.
 
\layout Subsection


\family typewriter 
SimpleMaterial
\layout Standard


\family typewriter 
SimpleMaterial
\family default 
 is a pretty direct mapping from OpenGL.
 It has colors for 
\family typewriter 
ambient
\family default 
, 
\family typewriter 
diffuse
\family default 
, 
\family typewriter 
specular
\family default 
 and 
\family typewriter 
emission
\family default 
 properties, and a 
\family typewriter 
shininess
\family default 
 value.
 In addition to that it has a 
\family typewriter 
transparency
\family default 
 setting, ranging from 0 for opaque to 1 for fully transparent.
 
\layout Standard

There are two other attributes in a 
\family typewriter 
SimpleMaterial
\family default 
 that control the appearance of an object.
 One is the 
\family typewriter 
lit
\family default 
 attribute, which defines if the material is influenced by light sources
 at all.
 If it isn't, the color is directly taken from the 
\family typewriter 
diffuseColor
\family default 
 component and other color attributes are ignored.
 
\layout Standard

The other attribute is the 
\family typewriter 
colorMaterial
\family default 
 field, which defines how colors that are given in the geometry influence
 the lighting calculation.
 By default they replace the diffuse color only.
 Possible values are taken from the 
\family typewriter 
glColorMaterial()
\family default 
 call, the most useful being 
\family typewriter 
GL_DIFFUSE_AND_SPECULAR
\family default 
.
 One possible value that is not used by 
\family typewriter 
glColorMaterial()
\family default 
 is 
\family typewriter 
GL_NONE
\family default 
, which switches off the color material handling and thus ignores colors
 that are given in the geometry.
\layout Subsection


\family typewriter 
TexturedSimpleMaterial
\layout Standard


\family typewriter 
TexturedSimpleMaterial
\family default 
 is derived from 
\family typewriter 
SimpleMaterial
\family default 
 and adds a texture.
 The texture is defined by an image (see 
\begin_inset LatexCommand \ref{sec:image}

\end_inset 

 for details on how to define or load an image).
 
\layout Standard

Additionally there are some parameters to define the behaviour of a texture.
 
\family typewriter 
magFilter
\family default 
 and 
\family typewriter 
minFilter
\family default 
 define how to scale the texture image up or down, legal values taken from
 
\family typewriter 
glTexParameter()
\family default 
.
 The most useful ones are 
\family typewriter 
GL_NEAREST
\family default 
 or 
\family typewriter 
GL_LINEAR
\family default 
 for 
\family typewriter 
magFilter
\family default 
, and additionally 
\family typewriter 
GL_LINEAR_MIPMAP_LINEAR
\family default 
 for 
\family typewriter 
minFilter
\family default 
.
 
\layout Standard


\family typewriter 
envMode
\family default 
 defines how a color from the texture is combined with a color from the
 lighting calculation.
 The default is 
\family typewriter 
GL_REPLACE
\family default 
 which completely ignores the lighting color.
 Other useful values are 
\family typewriter 
GL_MODULATE
\family default 
, which just multiplies the two, and 
\family typewriter 
GL_DECAL
\family default 
, which interpolates between lighting and texture based on the texture's
 alpha channel.
\layout Standard

Finally, a texture can be used as a spherical environment map to simulate
 a reflective object by setting the 
\family typewriter 
envMap
\family default 
 field to 
\family typewriter 
true
\family default 
.
 Spherical environment maps need to display the image of a reflective sphere
 in the middle of the environment that is being reflected.
 
\layout Chapter

Action and Traversals
\layout Standard

Creating the scenegraph is just the first step, and not really useful in
 itself.
 Something needs to be done with it.
 Actions on the graph usually take the form of a traversal which goes through
 the nodes one by one and calls an appropriate action for each one on the
 way.
\layout Standard

These are called Actions in OpenSG, and there are a number of predefined
 actions:
\layout Itemize

Draw
\layout Itemize

Render
\layout Itemize

Intersect
\layout Section

Usage
\layout Standard

Actions use the same syntax for creating as actions that fieldcontainers
 use, as they also use a prototype for that.
 Thus you need to call 
\family typewriter 
ActionType::create
\family default 
 to get a new one.
 They are not fieldcontainers, though, so simple pointers are ok.
\layout Standard

To execute an action on a graph you apply it to the graph (
\family typewriter 
action->apply(graph);
\family default 
) or to a list of nodes (
\family typewriter 
action->apply(vector<NodePtr>::iterator begin, vector<NodePtr>::iterator
 end);
\family default 
).
\layout Section

DrawAction
\layout Standard

DrawAction is a simple traversal that directly calls OpenGL.
 It was the first attempt at rendering and has been superseded by 
\family typewriter 
RenderAction
\family default 
, so use that instead.
\layout Section

RenderAction
\layout Standard

RenderAction is the primary means of transforming the scenegraph into an
 image.
 It does view volume culling and state sorting by building a draw tree.
 It also handles transparent objects by rendering them last and back to
 front sorted.
 Put simple it does what a decent scenegraph needs to do.
 
\layout Standard

To use it just create one and pass it to the Window (see sec.
 
\begin_inset LatexCommand \ref{sec:window}

\end_inset 

).
\layout Standard

It is possible to turn the view volume culling off using the 
\family typewriter 
setFrustumCulling
\family default 
() method.
 For debugging it is possible to turn the frustum update off (
\family typewriter 
setAutoFrustum(
\family default 
)) and to make the system render the tested bounding volumes (
\family typewriter 
setVolumeDraw()
\family default 
).
\layout Section

IntersectAction
\layout Standard


\family typewriter 
IntersectAction
\family default 
 is used for sending rays into the scene and retrieving the first object
 hit.
 Right now, intersection testing is not very optimized, which is okay for
 selecting an object, but probably too slow for programmatic use.
\layout Standard

A ray is defined by a 
\family typewriter 
Line
\family default 
 (see sec.
 
\begin_inset LatexCommand \ref{sec:line}

\end_inset 

) and optionally a maximum distance.
 It can either be set at construction time or by 
\family typewriter 
setLine()
\family default 
.
 To test the ray for intersection, apply the action to the root of the possible
 intersection objects.
\layout Standard

If the ray hits an object 
\family typewriter 
didHit(
\family default 
) will return true.
 In that case, detailed info about what was hit and where can be accessed
 through 
\family typewriter 
getHitT()
\family default 
, 
\family typewriter 
getHitPoint()
\family default 
, 
\family typewriter 
getHitObject()
\family default 
 and 
\family typewriter 
getHitTriangle()
\family default 
.
\layout Section

Simple Traversal
\begin_inset LatexCommand \label{sec:simple_traversal}

\end_inset 


\layout Standard

Actions are somewhat complicated to derive and, furthermore, they manage
 callback functors on a 
\family typewriter 
NodeCore
\family default 
 basis.
 Sometimes it's easier to just define a function that is called for every
 node in a graph.
 That's what 
\family typewriter 
traverse()
\family default 
 is for.
\layout Standard


\family typewriter 
traverse()
\family default 
 takes a 
\family typewriter 
NodePtr
\family default 
 to define the graph and a functor to define the function to be called for
 every node as parameters.
 The functor just gets the traversed node as a parameter 
\layout Section

Write your own action handler
\layout Standard

Don't.
 Actions are being completely redesigned for 1.1 to become more flexible
 and clean.
 Use the available actions and try to stay with the 
\family typewriter 
traverse()
\family default 
 function (see 
\begin_inset LatexCommand \ref{sec:simple_traversal}

\end_inset 

) for now.
 
\layout Standard

If you really need to do your own action take a look at 
\family typewriter 
IntersectAction
\family default 
, it shows what you need to implement.
 Talk to us before you do it, though, maybe the redesign is already usable
 so you can base your new stuff on that.
\layout Chapter

Window
\begin_inset LatexCommand \label{sec:window}

\end_inset 


\layout Standard

Windows are the general connection between OpenSG and the windowing system
 used by the application/platform.
 OpenSG itself does not open its own windows, that has to be done by the
 application.
 Using GLUT it's pretty trivial, take a look at the tutorial examples on
 how to do that.
 For other window systems its a little more work, but the goal is to have
 wrapper classes for the usual GUI toolkits like QT, Motif etc.
 that simplify the task.
 We have one for QT, 
\family typewriter 
OSGQGLManagedWidget
\family default 
, and are interested in similar ones for other Window systems.
\layout Section

Window
\layout Standard

A Window is the connection to the window system used.
 There are variants for different supported window systems like X, WIN32,
 GLUT and QT.
 The OpenSG object handles OpenGL context creation and activation/deactivation,
 and needs to be informed about resizes.
 It manages OpenGL objects like display lists and texture objects and is
 also responsible for OpenGL extension detection and functions.
\layout Standard

It doesn't do any input event handling or similar things, it's only for
 output and keeping the Viewports that fill the window and keep all the
 rendering parameters.
 See sec.
 
\begin_inset LatexCommand \ref{sec:simplescenemanager}

\end_inset 

 for an easy-to-use wrapper for setting these up.
 
\layout Section

Viewport
\layout Standard

A Viewport is a part of the window that is being rendered into.
 It can cover the whole window, but doesn't have to.
 The size of the viewport is defined by its left, right, bottom and top
 coordinates, given in OpenGL conventions, i.e.
 the bottom of the screen has the vertical coordinate 0.
 
\layout Standard

If the value is bigger than 1, it's a position in pixel.
 That's independent of the window size, if the window is smaller, parts
 of the viewport will be cut, if it's bigger parts of the window will not
 be covered.
 If they are between 0 and 1 (inclusively) they are relative to the window
 and are rescaled when the window is resized.
 If they are -1 they use the extreme applicable value, i.e.
 0 for left and bottom, 1 for right and top.
 For relative sizes the actual value used for right and top is 
\family typewriter 
value * size - 1
\family default 
.
 This allows abutting viewports by using the same relative values for right
 and left of the viewports that should fit.
\layout Standard

To define what is being rendered a viewport stores the root node of the
 scene to be displayed, the camera to use and the background and foregrounds.
\layout Section

Camera
\begin_inset LatexCommand \label{sec:camera}

\end_inset 


\layout Standard

A camera defines the parts of the scene that are actually being rendered.
 The definition can be split in two parts: location and direction, and internal
 parameters.
\layout Standard

Position and orientation of the camera are defined by a node in the scenegraph,
 a beacon, similarly to the definition used by light sources.
 The camera uses the OpenGL defaults for specifying the used coordinate
 system, i.e.
 the camera looks along the negative Z coordinate, X points to the right
 and Y is up.
 Thus, to use a camera you need a beacon node in the scene to define its
 position.
 This can be an object you want to attach the camera to, but in general
 you'll probably have a Transform node somewhere close to the root to handle
 it.
\layout Standard

This gives full flexibility to use a simple matrix to define camera position
 and orientation, but can be tedious to specify.
 Many systems use a from-at-up convention to define camera parameters, i.e.
 you specify a viewer position, a point that should be in the center of
 the screen and the direction that should be up on the screen.
 The 
\family typewriter 
MatrixLookAt
\family default 
 functions from 
\family typewriter 
OSGMatrixUtility.h
\family default 
 can convert these settings into a matrix that can directly be used to specify
 the camera.
\layout Standard

The internal parameters of the camera can vary between different kinds of
 cameras.
 The only constant thing that a camera for OpenGL needs are the near and
 far clip distances, which are defined in the general Camera class.
 The others are defined in the specific camera classes.
\layout Subsection

Perspective Camera
\layout Standard

The standard camera used for OpenGL rendering is a perspective camera.
 The only additional attribute it has is the vertical field of view, in
 radians.
 The horizontal field of view is automatically adjusted to the window size
 to create a square aspect ratio.
\layout Section

Background
\layout Standard

A background defines how the window is cleared before anything is rendered.
 There are a couple of different backgrounds.There can be only one background
 per viewport.
\layout Subsection


\family typewriter 
SolidBackground
\layout Standard


\family typewriter 
SolidBackground
\family default 
 is the simplest variant, it just fills the background with a single color
 given in its 
\family typewriter 
color
\family default 
 field.
\layout Subsection


\family typewriter 
GradientBackground
\layout Standard


\family typewriter 
GradientBackground
\family default 
 fills the background with a color gradient.
 To specify the gradient a color has to be associated with a vertical position
 in the window (0 being at the bottom, 1 being at the top).
 The 
\family typewriter 
addColor()
\family default 
 method should be used for that.
\layout Section

Foreground
\layout Standard

A foreground can be used to render something on top of the scenegraph image.
 There can be an arbitrary number of active foregrounds.
 Right now the only foreground is 
\family typewriter 
ImageForeground
\family default 
.
\layout Subsection


\family typewriter 
ImageForeground
\layout Standard

ImageForeground renders images on top of the scenegraph image.
 The typical use is adding a logo to the image.
 
\layout Standard

Images have to be loaded as 
\family typewriter 
Image
\family default 
s, their position has to be defined as a 2D position in the 
\begin_inset Formula \( [0,1]x[0,1] \)
\end_inset 

 range and given to the 
\family typewriter 
addImage()
\family default 
 function.
\layout Section

SimpleSceneManager
\begin_inset LatexCommand \label{sec:simplescenemanager}

\end_inset 


\layout Standard

SimpleSceneManager is a utility class to simplify the creation of simple
 applications.
 It manages a single window with a single viewport and a minimal scenegraph
 with a beacon for the camera and a headlight.
 It keeps a Trackball to interactively manipulate the camera.
\layout Standard

It does not open a window itself, that is left to the user to keep the SSM
 useful for arbitrary window systems.
 The window has to be passed to the SSM by using 
\family typewriter 
setWindow()
\family default 
.
 That's one half of the necessary initialization.
 It can't handle input itself, the application has to pass it user input
 events.
 It's a lot simpler than it sounds, take a look at the tutorials to see
 how it works.
\layout Standard

The other half of the necessary initialization is telling SSM what to draw
 by calling 
\family typewriter 
setRoot()
\family default 
.
 That's it.
 It might be useful to call 
\family typewriter 
showAll()
\family default 
 to position the camera at a reasonable position, but that's not mandatory.
\layout Standard

The SSM can be used in conjunction with any window system, it has been integrate
d into an easy-to-use QT widget called 
\family typewriter 
OSGQGLWidget
\family default 
.
 See XXXX.cpp for an example on how to use it.
\layout Standard

As a little bonus, SSM can display the 
\begin_inset Quotes eld
\end_inset 

Powered by OpenSG
\begin_inset Quotes erd
\end_inset 

 logo.
 Just call 
\family typewriter 
useOpenSGLogo()
\family default 
 and you're done.
 ;)
\layout Chapter

Loader
\layout Standard

As OpenSG user/developer you can always instantiate all your nodes, cores
 or whatever objects you need one by one in your application code.
 
\layout Standard

In addition OpenSG also provides - as most scenegraph libraries - a set
 of loaders, which create a scene tree or image from a given file.
 The system creates singleton Handlers for both types (
\family typewriter 
SceneFileHandler
\family default 
 and 
\family typewriter 
ImageFileHandler
\family default 
), which handle all abstract requests.
 The concrete loaders are coded in mime/file type handler (e.g.
 
\family typewriter 
OSGTIFImageFileType.h/OSGTIFImageFileType.cpp
\family default 
) and are automatically registered.
 
\layout Standard

The system architecture is designed to handle built-in types and to fetch
 loaders for a specific type on request.
 In the current version (1.0) only built-in types are provided since the
 meta interfaces may not be final yet.
 However the 1.0 version comes with a sufficient set of built-in loaders
 and you can always extend the library to handle you own file format.
\layout Section

Usage
\layout Standard

You can always use a specific loader directly, but in most cases you would
 ask the Handler (e.g.
 
\family typewriter 
SceneFileHandler
\family default 
) to load a file indepentend of the file type.
 There is always just one handler (it is a singleton object) you can access
 the object using the static 
\family typewriter 
the()
\family default 
 method (e.g.
 
\family typewriter 
osg::SceneFileType::the()
\family default 
).
 The Handler knows all the valid suffixes for every mime/file type and can
 pick the correct loader automatically.
 
\layout Standard

If you would like to get a loader for a specific type or suffix you can
 just ask the handler to find it (e.g.
 
\family typewriter 
OSGSceneFileHandler::the().getFileType(
\begin_inset Quotes eld
\end_inset 

foo
\begin_inset Quotes erd
\end_inset 

)
\family default 
).
\layout Subsection

Scene
\layout Standard

The Scene Handler provides two interfaces to load a scene: 
\family typewriter 
read
\family default 
 (returns a single root node or 
\family typewriter 
NullFC
\family default 
 on failure) or 
\family typewriter 
readTopNodes
\family default 
 (does not create an extra root but returns all top nodes ).
 
\layout Standard

Just use the Handler to find and use the correct type for the given suffix:
 
\family typewriter 
osg::NodePtr rootPtr = osg::SceneFileType::the().read(
\begin_inset Quotes eld
\end_inset 

test.wrl
\begin_inset Quotes erd
\end_inset 

)
\family default 
 for example would pick the vrml loader (suffix is 
\begin_inset Quotes eld
\end_inset 

wrl
\begin_inset Quotes erd
\end_inset 

), parse the file and return the result.
 
\layout Subsection

Image
\begin_inset LatexCommand \label{imageLoaderSection}

\end_inset 


\layout Standard

The image loader works more or less the same way as the scene loader.
 Let the singleton handler pick the mime type and just check the return
 value: 
\family typewriter 
osg::ImageFileType::the().read(
\begin_inset Quotes eld
\end_inset 

test.tif
\begin_inset Quotes erd
\end_inset 

) 
\family default 
for example would pick the tif loader (suffix 
\begin_inset Quotes eld
\end_inset 

tif
\begin_inset Quotes erd
\end_inset 

 ), start loading the file, and return the new 
\family typewriter 
Image
\family default 
 or 
\family typewriter 
Null
\family default 
.
\layout Section

Write our own
\layout Standard

For every new mime/file you have to write a new 
\family typewriter 

\begin_inset Quotes eld
\end_inset 

Type
\begin_inset Quotes erd
\end_inset 


\family default 
 class (e.g.
 
\family typewriter 
FooImageType.h/FooImageType.cpp
\family default 
).
 Every Type is handled as a singleton object and must provide a 
\family typewriter 
the()
\family default 
 method to access the static instance.
 The class must be derived from the base Type (e.g.
 
\family typewriter 
ImageFileType
\family default 
) to be registered.
 You don't have to register the new type in any extra class.
 Just included it in the OpenSG source tree and it should work with the
 Handler.
\layout Subsection

Scene
\layout Standard

Since scene loader are usually more complex and require sometimes some extra
 library they are stored in extra directories (e.g.
 
\family typewriter 
OpenSG/Loader/OBJ
\family default 
).
 To write you own scene handler perform the following steps:
\layout Enumerate

Create a new directory for your mime type (e.g.
 
\family typewriter 
OpenSG/Loader/FOO
\family default 
)
\layout Enumerate

Copy the code from a simple loader (e.g.
 
\family typewriter 
Loader/RAW
\family default 
)
\layout Enumerate

Change the file file/class name to match your type.
\layout Enumerate

Change the _suffixA values in the *.cpp file (e.g 
\family typewriter 
{
\begin_inset Quotes eld
\end_inset 

foo
\begin_inset Quotes erd
\end_inset 

}
\family default 
 ), you can includes as many valid suffixes as you want
\layout Enumerate

Write the 
\family typewriter 
read() 
\family default 
methods to load your type
\layout Enumerate

configure/make opensg libs
\layout Subsection

Image
\layout Standard

Image loaders are usually not too complex.
 They just use some kind of extra lib (e.g.
 tiflib) to load the image data.
 Since the extra lib is usually not included in the opensg source tree we
 do not store the code in an extra, mime type specific directory.
 They are all stored in 
\family typewriter 
OpenSG/Image.
 
\layout Standard

To write you own image loader perform the following steps:
\layout Enumerate

Copy the code from a simple loader (e.g.
 
\family typewriter 
Image/PNMImageFileType.*
\family default 
)
\layout Enumerate

Change the file file/class name to match you type.
\layout Enumerate

Change the _suffixA values in the *.cpp file (e.g 
\family typewriter 
{
\begin_inset Quotes eld
\end_inset 

foo
\begin_inset Quotes erd
\end_inset 

}
\family default 
 ), you can includes as many valid suffixes as you want
\layout Enumerate

Change the 
\family typewriter 
getMimeType() 
\family default 
method in *.h to return the new mime type.
\layout Enumerate

Write the 
\family typewriter 
read()/write() 
\family default 
methods to load/write your type
\layout Enumerate

configure/make opensg libs
\layout Chapter

Creating new FieldContainer classes
\begin_inset LatexCommand \label{sec:creating_new_fcs}

\end_inset 


\layout Standard

Most developers who use OpenSG as a scenegraph library will probable never
 create their own OpenSG FieldContainer classes.
 Similar to widget libs (e.g.
 qt,gtk) people just use instances (the widgets) but never create new classes.
 
\layout Standard

However, you can always extend the type system of OpenSG to integrate new
 cores (e.g.
 a fancy LOD switch) or application specific fieldcontainers.
\layout Standard

Fieldcontainers are the system's central mechanisms to deal with any kind
 of thread safe data (see section 
\begin_inset LatexCommand \ref{sec:Fields_and_FieldContainer}

\end_inset 

).
 Therefore, the class declaration must include various extra meta information
 for the field and fieldcontainer type handling.
 
\layout Standard

In most systems (e.g.
 Inventor), you would probably start writing a new class or node by just
 'copy and paste'-ing an existing implementation.
 However, since OpenSG needs all this extra meta data it is not a simple
 but very error prone process to create the field container source by hand.
 Instead, we provide a graphical tool to create and manage the fieldcontainer
 description and implementation.
\layout Standard

The basic idea is that you use the 'field container description editor'
 ($OSGROOT/tools/fcdEdit) to create an XML file including the description
 of your fieldcontainer fields and interfaces (see image 
\begin_inset LatexCommand \ref{fcdEditFig}

\end_inset 


\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 267 177
file fcd.eps
width 4 90
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fcdEditFig}

\end_inset 

FcdEdit blabla
\end_float 
 ).
 The tool is also able to create all necessary C++ source files.
 The fieldcontainer code is split into classes (e.g.
 for a Foo fieldcontainer: FooBase and Foo).
 This strategy has various advantages:
\layout Description

Type_system_changes: If the OpenSG core team decides to change the code
 interface for the fieldcontainer type management we can just recreate the
 base classes from the XML description.
 No adaptions 'by hand' are needed.
\layout Description

Interface_changes: If you would like to change the interface of your fieldcontai
ner (e.g.
 add another field) later on you can just re-edit the XML file in fcdEdit
 and recreate the base classes.
 All necessary access methods are created automatically.
\layout Section

XML Description (Foo.fcd)
\layout Standard

Includes all field and meta descriptions for a single fieldcontainer.
 Can be read and written by the fcdEdit tool.
 You should only change it by hand when you're sure of what you're doing.
 
\layout Section

Field Types (FooFields.h)
\layout Standard

Include the field and pointer declarations the the fieldcontainer to be
 used in other fieldcontainers as reference.
 You should not change the file by hand.
\layout Section

Base/Meta Type (FooBase.h, FooBase.inl, FooBase.cpp)
\layout Standard

Holds all the meta and field information.
 Do not change it by hand.
 Use the fcdEdit tool to create the files anew whenever you change the xml
 description.
 
\layout Section

'User Code' implementation (Foo.h, Foo.inl, Foo.cpp)
\layout Standard

Holds the 'user code'.
 The fcdEdit is able to create a skeleton for your fieldcontainer implementation.
 The code does not include any meta information, therefore, it is not necessary
 to create it anew whenever you change the interface.
 
\layout Standard

Include new action handlers or whatever you need as functionality.
 
\layout Section

Prototype Replacement
\layout Standard

If you create a replacement for a system component, e.g.
 a smarter DistanceLOD node that can handle predictive LOD selection, and
 want the system to use your version of the DistanceLOD from now on you
 can do that.
 Internally all field container instances are created by cloning a prototype
 instance.
 You can access the prototype for a given fieldcontainer via its class type
 which you can access using FC::getClassType().
 The class type has a setPrototype() method to assign the prototype.
 
\layout Standard

Be careful to only replace the prototype with classes derived from the original
 class 
\shape italic 
(is that checked automatically? Should it?)
\shape default 
, or the behaviour of the system is undefined.
\layout Standard


\begin_inset LatexCommand \listoffigures{}

\end_inset 


\layout Standard


\latex latex 

\backslash 
begin{appendix}
\layout Chapter

Code Style
\layout Standard

We have a pretty tightly specified code style.
 The style has developed during the project, and not all code has been kept
 up-to-date with respect to the style.
 That will be fixed over time.
 
\layout Standard

But we're not religious about all the details.
 There are some basic rules that we would like code to be integrated into
 OpenSG to follow.
 See the TWiki for all the details.
\layout Section

Classes & Methods
\layout Standard

Classes should use nouns for names, methods should use the verb[adjective]noun
 convention.
 OpenSG uses a getValue()/setValue() convention for the data access interface,
 it would be good to follow that.
 Adding other interfaces is of course possible, but to reduce user surprise
 the standard one would be good.
\layout Section

Indents & Formatting
\layout Standard

This is an area of long and hard struggles, and everybody has his/her own
 comments.
 There are some things we expect to keep the code somewhat readable.
\layout Standard

Don't use TABs for indenting, use spaces instead.
 Everybody uses a different TAB size (the core team used to use 2, 4 and
 8, and it consists of only three people), and looking at code indenting
 with a different tabsize is a pain.
 Spaces work around all that.
\layout Standard

Use an indent size of 4.
 That seems to be a good compromise for most people.
\layout Standard

Use ANSI styles braces i.e.
 put the 
\family typewriter 
{
\family default 
 and 
\family typewriter 
}
\family default 
 on their own line, do not attach it to the 
\family typewriter 
if
\family default 
 or 
\family typewriter 
for
\family default 
.
\layout Section

General Commenting
\layout Standard

We use doxygen to turn code into documentation, because it is so flexible
 and has nice output.
\layout Standard

Use the QT style for comments (
\family typewriter 
/*!
\family default 
), not the JavaDoc style.
 The former lets you define comments without a brief comment, which is what
 we want.
 
\layout Standard

Don't do brief comments, they clutter up the member list and very rarely
 add more information than the method name.
 Exception: classes.
 Put a brief class comment at the top of the header to help people understand
 what the class is about.
 Do use full comments where necessary.
 They're not always necessary for 
\family typewriter 
setValue()
\family default 
 style functions, though.
 
\layout Standard

Do comment the classes and data members, they are probably more important
 than the methods.
\layout Section

Headers
\layout Standard

The general idea behind the header styling is to keep them clean and concise.
 Many people use the headers as primary information sources, not the documentati
on.
 Cluttered up headers are really useless in that case.
\layout Standard

Generally there should only be one class per header/file, which is pretty
 much standard for C++ people.
 If you have minimal helper classes that don't have any use outside their
 user class you can keep them in the same header.
\layout Standard

The order of sections in a class definition should be 
\family typewriter 
public:
\family default 
, 
\family typewriter 
protected:
\family default 
, 
\family typewriter 
private:
\family default 
, to give people the parts that they can actually access at the top of the
 file.
\layout Standard

Don't put inline code into the headers, use a separate 
\family typewriter 
.inl
\family default 
 file for that.
 
\layout Standard

Don't document every method and member in the headers.
 Doing that makes the actual code get lost, comment them at the implementation
 point instead.
 Use groups (
\family typewriter 
/*! 
\backslash 
{ */
\family default 
) to group logically related methods into groups, don't bother to put a
 comment in front of every method.
\layout Section

Code Files
\layout Standard

Put an extensive class comment right after the includes (or before???),
 followed by the member documentation.
 
\layout Standard

The methods in the 
\family typewriter 
.cpp
\family default 
 should be in the same order that they are defined in in the header.
\layout Standard

Every nonstatic data member of a class must be initialized through the mem-initi
alizer-list before the function body of the constructor is executed.
 Everything else will lead to big pains in the long run.
\layout Standard

That's about it.
 It isn't really that painful, is it?
\layout Chapter

fcdEdit description
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 595 482
file fcdEdit-numbered.eps
width 3 100
flags 11

\end_inset 


\end_float 
\layout Enumerate

Node name: don't include the OSG prefix
\layout Enumerate

System Component: needed to define the include convention, usually not used
 by applications.
\layout Enumerate

Parent field container; don't include the OSG prefix
\layout Enumerate

Is Parent a System Component: needed to define include convention.
 Has to be set when deriving from a system component.
\layout Enumerate

Library: 
\layout Enumerate

PFTypes: 
\layout Enumerate

Structure: 
\layout Enumerate

Field list, shows all field description in a vertical list
\layout Enumerate

Name of the Field
\layout Enumerate

Type of the Field, can be changed/extended with the 'Load Field Types/Reset
 Field Types' mechanisms
\layout Enumerate

Cardinality: defines the field to be a single or multifield (can hold one
 value or any number (0-n))
\layout Enumerate

Access: private/protected/public c++ sty;e access definition
\layout Enumerate

Visibility: internal/external; will be used to create various styles of
 documentation
\layout Enumerate

Header: defines the type header, if unset ...
\layout Enumerate

DefaultValue: The default field value, prototype ?
\layout Enumerate

DefaultHeader: ?
\layout Enumerate

Description: Text description of the Field
\layout Enumerate

New Field: creates a new field
\layout Enumerate

Delete Field: deletes the current field
\layout Enumerate

Clone Field: creates a new field description as clone of the current field
\layout Enumerate

Up: Moves the current field one position up
\layout Enumerate

Down: Movies the current field one position down
\layout Enumerate

New: Restarts the process 
\layout Enumerate

Load:
\layout Enumerate

Load Parent:
\layout Enumerate

ResetFieldTypes:
\layout Enumerate

LoadFieldTypes;
\layout Enumerate

Save:
\layout Enumerate

Save as:
\layout Enumerate

Write Field Container Base Code: Writes the current description as FooBase.h,
 FooBase.inl and FooBase.cpp
\layout Enumerate

Write Field Container Code: Writes the current description as Foo.h Foo.inl
 and Foo.cpp
\layout Enumerate

About
\layout Enumerate

Exit
\layout Enumerate

Node Description: HTML ?
\layout Standard


\latex latex 

\backslash 
end{appendix}
\the_end
